=pod

=head1 NAME

 CMP_CTX_create,
 CMP_CTX_init,
 CMP_CTX_delete,
 CMP_CTX_set1_referenceValue,
 CMP_CTX_set1_secretValue,
 CMP_CTX_set1_caCert,
 CMP_CTX_set1_clCert,
 CMP_CTX_set1_subjectName,
 CMP_CTX_set1_extCert,
 CMP_CTX_set1_newClCert,
 CMP_CTX_set0_pkey,
 CMP_CTX_set0_newPkey,
 CMP_CTX_set1_pkey,
 CMP_CTX_set1_newPkey,
 CMP_CTX_set1_transactionID,
 CMP_CTX_set1_senderNonce,
 CMP_CTX_set1_recipNonce,
 CMP_CTX_set1_protectionAlgor,
 CMP_CTX_set_protectionAlgor,
 CMP_CTX_set_compatibility,
 CMP_CTX_set1_serverName,
 CMP_CTX_set_option,
 CMP_CTX_caPubs_pop,
 CMP_CTX_caPubs_num,
 CMP_CTX_set1_caPubs,
 CMP_CTX_set1_extraCerts,
 CMP_CTX_extraCerts_push1, 
 CMP_CTX_extraCerts_num,
 CMP_CTX_set1_caExtraCerts,
 CMP_CTX_caExtraCerts_pop,
 CMP_CTX_caExtraCerts_num

=head1 SYNOPSIS

 #include <openssl/cmp.h>

 CMP_CTX *CMP_CTX_create();
 int CMP_CTX_init( CMP_CTX *ctx);
 void CMP_CTX_delete(CMP_CTX *ctx);

 int CMP_CTX_set1_referenceValue( CMP_CTX *ctx, const unsigned char *ref, size_t len);
 int CMP_CTX_set1_secretValue( CMP_CTX *ctx, const unsigned char *sec, const size_t len);
 int CMP_CTX_set1_caCert( CMP_CTX *ctx, const X509 *cert);
 int CMP_CTX_set1_clCert( CMP_CTX *ctx, const X509 *cert);
 int CMP_CTX_set1_subjectName( CMP_CTX *ctx, const X509_NAME *name);
 int CMP_CTX_set1_extCert( CMP_CTX *ctx, const X509 *cert);
 int CMP_CTX_set1_newClCert( CMP_CTX *ctx, const X509 *cert);
 int CMP_CTX_set0_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
 int CMP_CTX_set0_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
 int CMP_CTX_set1_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
 int CMP_CTX_set1_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
 int CMP_CTX_set1_transactionID( CMP_CTX *ctx, const ASN1_OCTET_STRING *id);
 int CMP_CTX_set1_senderNonce( CMP_CTX *ctx, const ASN1_OCTET_STRING *nonce);
 int CMP_CTX_set1_recipNonce( CMP_CTX *ctx, const ASN1_OCTET_STRING *nonce);
 int CMP_CTX_set1_protectionAlgor( CMP_CTX *ctx, const X509_ALGOR *algor);
 int CMP_CTX_set1_serverName( CMP_CTX *ctx, const char *name);
 int CMP_CTX_set1_serverPort( CMP_CTX *ctx, int port);
 X509 *CMP_CTX_caPubs_pop( CMP_CTX *ctx);
 int CMP_CTX_caPubs_num( CMP_CTX *ctx);
 int CMP_CTX_set1_caPubs( CMP_CTX *ctx, const STACK_OF(X509) *caPubs);

 int CMP_CTX_set1_extraCerts( CMP_CTX *ctx, const STACK_OF(X509) *extraCerts);
 int CMP_CTX_extraCerts_push1( CMP_CTX *ctx, const X509 *val);
 int CMP_CTX_extraCerts_num( CMP_CTX *ctx);
 X509 *CMP_CTX_caExtraCerts_pop( CMP_CTX *ctx);
 int CMP_CTX_caExtraCerts_num( CMP_CTX *ctx);

 #define CMP_ALG_PBMAC 1
 #define CMP_ALG_SIG   2
 int CMP_CTX_set_protectionAlgor( CMP_CTX *ctx, const int algId);

 #define CMP_COMPAT_RFC		1
 #define CMP_COMPAT_CRYPTLIB	2
 #define CMP_COMPAT_INSTA	3 - only supported when built with -DSUPPORT_OLD_INSTA
 #define CMP_COMPAT_INSTA_3_3	4
 int CMP_CTX_set_compatibility( CMP_CTX *ctx, const int mode);

 #define CMP_CTX_OPT_UNSET           0
 #define CMP_CTX_OPT_SET             1
 #define CMP_CTX_OPT_IMPLICITCONFIRM 1
 int CMP_CTX_set_option( CMP_CTX *ctx, const int opt, const int val);

=head1 DESCRIPTION

This is the context API for using CMP (Certificate Management Protocol)
with OpenSSL.

CMP_CTX_create() allocates and initialized an CMP_CTX structure.

CMP_CTX_init() initializes the context to default values. Compatibility
is set to RFC, transport to HTTP, proof-of-posession method to
POPOSigningKey

CMP_CTX_delete() frees any allocated non-ASN1 fields of CMP_CTX and
calls the ASN1 defined CMP_CTX_free() function to free the rest.

CMP_CTX_set1_referenceValue() sets the given referenceValue in the given
CMP_CTX structure.

CMP_CTX_set1_secretValue() sets the given secretValue in the given
CMP_CTX structure.

CMP_CTX_set1_caCert() sets the given CA Certificate in the given CMP_CTX
structure.

CMP_CTX_set1_clCert() sets the given Client Certificate in the given
CMP_CTX structure.

CMP_CTX_set1_subjectName() sets the subject name that will be used in
the CertTemplate structure when requesting a new certificate. Note that
if clCert or extCert are set, the name will be read from them and this
will be ignored.

CMP_CTX_set1_extCert() sets the given external X509 certificate (to be
used for in-band initialization), in the given CMP_CTX structure.

CMP_CTX_set1_newClCert() sets the given (newly obtained) Client
Certificate in the given CMP_CTX structure.

CMP_CTX_set0_pkey() sets the given EVP_PKEY structure, holding the
private and public keys, belonging to the Client Certificate, in the
given CMP_CTX structure.

CMP_CTX_set1_pkey() is the same as above, except that it does not
consume the pointer.

CMP_CTX_set0_newPkey() sets the given EVP_PKEY structure, holding the
private and public keys, which shall be certified, in the given CMP_CTX
structure

CMP_CTX_set1_newPkey() is the same as above, except that it does not
consume the pointer.

CMP_CTX_set1_transactionID() sets the given transaction ID in the given
CMP_CTX structure.

CMP_CTX_set1_senderNonce() sets the given sender nonce in the given
CMP_CTX structure.

CMP_CTX_set1_recipNonce() sets the given recip nonce in the given
CMP_CTX structure.

CMP_CTX_set1_protectionAlgor() sets the protection algorithm, which
shall be used for the CMP conversation, in the given CMP_CTX structure.

CMP_CTX_set1_serverName() sets the given server Address (as IP or name)
in the given CMP_CTX structure.

CMP_CTX_set1_serverPort() sets the port of the CMP server to connect to.

CMP_CTX_set_protectionAlgor() sets the given definition (CMP_ALG_PBMAG
or CMP_ALG_SIG) of the algorithm to use in the given CMP_CTX structure.

CMP_CTX_set_compatibility() sets the given compatibility in the given
CMP_CTX structure. This is needed since the CMP RFC can be interpreted
in different ways so certain implementations may react different than
others. Available Options are CMP_COMPAT_RFC for strict RFC conformace,
CMP_COMPAT_CRYPTLIB for Cryptlib adaption, CMP_COMPAT_INSTA for Insta
Certifier version < 3.3 adaption (only supported when built with
-DSUPPORT_OLD_INSTA) and CMP_COMPAT_INSTA_3_3 for Insta Certifier
version => 3.3 adaption.

CMP_CTX_set_option() sets the given values to the options
(e.g. CMP_CTX_OPT_IMPLICITCONFIRM) in the given CMP_CTX structure. The
values can be CMP_CTX_OPT_UNSET or CMP_CTX_OPT_SET. Options are always
set to UNSET when the CMP_CTX structure is initialized.

CMP_CTX_caPubs_num() can be used after an Initial Request or Key Update
request to check the number of CA certificates that were sent from the
server.

CMP_CTX_caPubs_pop() pops one CA certificates of the stack of received
CA certs and returns it

CMP_CTX_set1_caPubs() copies the given caPubs stack to the context so
that it may be accessed later by CMP_CTX_caPubs_num() and
CMP_CTX_caPubs_pop().

CMP_CTX_set1_extraCerts() sets the stack of extraCerts that will be sent
by the client with an initial/key update/certification requiest.

CMP_CTX_extraCerts_push1() adds the given certificate to the extraCerts
stack, without consuming the pointer.
 
CMP_CTX_extraCerts_num() returns the number of certificates in the
extraCerts stack.
                                        
CMP_CTX_caExtraCerts_num() returns the number of certificates that were
received from the CA in an initialization/certification/key update
response.

CMP_CTX_caExtraCerts_pop() pops and returns one certificate off the
stack of extra certificates received from the CA.

=head1 NOTES

CMP is defined in RFC 4210 (and CRMF in RFC 4211).

The implementation of CMP for OpenSSL is still work in progress. The API
might change every release!

=head1 RETURN VALUES

CMP_CTX_create() returns a pointer to an initialized CMP_CTX structure.

All other functions return 0 on error, 1 on success.

=head1 EXAMPLE

The following code does an Initial Request with a Cryptlib CA:

	cmp_ctx = CMP_CTX_create();
	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
	CMP_CTX_set1_referenceValue( cmp_ctx, idString, idStringLen);
	CMP_CTX_set1_secretValue( cmp_ctx, password, passwordLen);
	CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
	CMP_CTX_set1_caCert( cmp_ctx, caCert);
	CMP_CTX_set_compatibility( cmp_ctx, CMP_COMPAT_CRYPTLIB);

	CMP_new_http_bio( &cbio, opt_serverName, opt_serverPort);

	initialClCert = CMP_doInitialRequestSeq( cbio, cmp_ctx);
	BIO_free(cbio);

The following code does an Initial Request with an Insta CA, using an
external identity certificate (Appendix E.7):

	cmp_ctx = CMP_CTX_create();
	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
	CMP_CTX_set1_referenceValue( cmp_ctx, idString, idStringLen);
	CMP_CTX_set1_extCert( cmp_ctx, externalCert);
	CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
	CMP_CTX_set1_caCert( cmp_ctx, caCert);
	CMP_CTX_set_compatibility( cmp_ctx, CMP_COMPAT_CRYPTLIB);

	CMP_new_bio( &cbio, opt_serverName, opt_serverPort);

	initialClCert = CMP_doInitialRequestSeq( cbio, cmp_ctx);
	BIO_free(cbio);

Here externalCert is an X509 certificate granted to the EE by another CA
which is trusted by the current CA the code will connect to.


The following code does an Key Update Request with an Insta Certifier CA
version =>3.3:

	cmp_ctx = CMP_CTX_create();
	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
	CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
	CMP_CTX_set0_newPkey( cmp_ctx, updatedPkey);
	CMP_CTX_set1_clCert( cmp_ctx, initialClCert);
	CMP_CTX_set1_caCert( cmp_ctx, caCert);
	CMP_CTX_set_compatibility( cmp_ctx, CMP_COMPAT_INSTA_3_3);

	CMP_new_bio( &cbio, opt_serverName, opt_serverPort);

	updatedClCert = CMP_doKeyUpdateRequestSeq( cbio, cmp_ctx);
	BIO_free(cbio);

The following code does an Key Update Request with a Cryptlib CA:

	cmp_ctx = CMP_CTX_create();
	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
	CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
	CMP_CTX_set0_newPkey( cmp_ctx, updatedPkey);
	CMP_CTX_set1_clCert( cmp_ctx, initialClCert);
	CMP_CTX_set1_caCert( cmp_ctx, caCert);
	CMP_CTX_set_compatibility( cmp_ctx, CMP_COMPAT_CRYPTLIB);

	CMP_new_http_bio( &cbio, opt_serverName, opt_serverPort);

	updatedClCert = CMP_doKeyUpdateRequestSeq( cbio, cmp_ctx);
	BIO_free(cbio);

The following code does an Key Update Request with an Insta Certifier CA:

	cmp_ctx = CMP_CTX_create();
	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
	CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
	CMP_CTX_set0_newPkey( cmp_ctx, updatedPkey);
	CMP_CTX_set1_clCert( cmp_ctx, initialClCert);
	CMP_CTX_set1_caCert( cmp_ctx, caCert);
	CMP_CTX_set_compatibility( cmp_ctx, CMP_COMPAT_INSTA);

	CMP_new_bio( &cbio, opt_serverName, opt_serverPort);

	updatedClCert = CMP_doKeyUpdateRequestSeq( cbio, cmp_ctx);
	BIO_free(cbio);

=head1 TODO

A lot!

=head1 SEE ALSO

CMP_sessions, CMP_http
