Index: openssl-1.0.0i-cmp/apps/cmp.c
===================================================================
--- openssl-1.0.0i-cmp/apps/cmp.c	(revision 0)
+++ openssl-1.0.0i-cmp/apps/cmp.c	(revision 469)
@@ -0,0 +1,702 @@
+/* vim: set cinoptions={1s: */
+/* apps/cmp.c
+ */
+/* ====================================================================
+ * Originally written by Miikka Viljanen
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2012 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+#include <openssl/opensslconf.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "apps.h"
+
+#define CONFIG_FILE "openssl.cnf"
+#define CMP_SECTION "cmp"
+#undef PROG
+#define PROG	cmp_main
+
+#if !defined(HAVE_CURL) || defined(OPENSSL_NO_CMP)
+
+int MAIN(int argc, char **argv)
+    {
+    BIO_puts(bio_err, "error: openssl was compiled without libcurl or with cmp support disabled\n");
+    OPENSSL_EXIT(0);
+    }
+
+#else
+
+#include <openssl/cmp.h>
+#include <openssl/crmf.h>
+#include <openssl/pem.h>
+
+typedef enum { CMP_IR,
+               CMP_KUR,
+               CMP_CR,
+               CMP_RR,
+               CMP_CKUANN,
+    } cmp_cmd_t;
+
+typedef enum { OPT_BOOL, OPT_NUM, OPT_TXT } opttype_t;
+typedef struct 
+    {
+    const char *name;
+    const char *help;
+    opttype_t type;
+    union {
+        char **txt;
+        long *num;
+        } v;
+    } opt_t;
+
+static char *opt_server=NULL;
+static char *server_address=NULL;
+static long  server_port=0;
+static char *opt_path="/";
+
+static char *opt_cmd_s=NULL;
+static int   opt_cmd=-1;
+static char *opt_user=NULL;
+static char *opt_pass=NULL;
+
+static char *opt_cert=NULL;
+static char *opt_key=NULL;
+static char *opt_keypass=NULL;
+
+static char *opt_certout=NULL;
+static char *opt_newkey=NULL;
+static char *opt_newkeypass=NULL;
+
+static char *opt_cacert=NULL;
+static char *opt_trusted=NULL;
+static char *opt_untrusted=NULL;
+static char *opt_keyfmt_s="PEM";
+static char *opt_certfmt_s="PEM";
+static int   opt_keyfmt=FORMAT_PEM;
+static int   opt_certfmt=FORMAT_PEM;
+static char *opt_engine=NULL;
+static long  opt_validate_path=0;
+
+static char *opt_extcerts=NULL;
+static char *opt_subject=NULL;
+static char *opt_recipient=NULL;
+
+static char *opt_cacertsout=NULL;
+static char *opt_extracertsout=NULL;
+
+static opt_t cmp_opts[]={
+    { "server", "The 'ADDRESS:PORT' for the CMP server", OPT_TXT, {&opt_server} },
+    { "path", "Path location inside the server", OPT_TXT, {&opt_path} },
+    { "cmd", "CMP command to execute: ir/kur/cr/rr/ckuann/...", OPT_TXT, {&opt_cmd_s} },
+    { "user", "Username for doing the IR with a pre-shared key", OPT_TXT, {&opt_user} },
+    { "pass", "Password for doing the IR with a pre-shared key", OPT_TXT, {&opt_pass} },
+
+    { "cert", "Client's current certificate", OPT_TXT, {&opt_cert} },
+    { "key", "Key for the client's current certificate", OPT_TXT, {&opt_key} },
+    { "keypass", "Password for the key", OPT_TXT, {&opt_keypass} },
+
+    { "certout", "Where to save the new certificate", OPT_TXT, {&opt_certout} },
+    { "newkey", "Key file to use for the new certificate", OPT_TXT, {&opt_newkey} },
+    { "newkeypass", "Password for the new keyfile", OPT_TXT, {&opt_newkeypass} },
+
+    { "cacert", "Certificate of the CMP server", OPT_TXT, {&opt_cacert} },
+    /* { "CApath", "A directory of trusted certificates", OPT_TXT, {&} }, */
+    { "trusted", "A file of trusted certificates", OPT_TXT, {&opt_trusted} },
+    { "untrusted", "A file of untrusted certificates", OPT_TXT, {&opt_untrusted} },
+
+    { "keyfmt", "Format to use for key files. Default PEM.", OPT_TXT, {&opt_keyfmt_s} },
+    { "certfmt", "Format to use for certificate files. Default PEM.", OPT_TXT, {&opt_certfmt_s} },
+    { "engine", "OpenSSL engine to use", OPT_TXT, {&opt_engine} },
+
+    /* XXX should this be on by default? */
+    { "validate_path", "Validate the trust path of the CA certificate", OPT_NUM, {.num=&opt_validate_path} },
+    { "extcerts", "List of certificate files to include in outgoing messages", OPT_TXT, {&opt_extcerts} },
+    { "subject", "X509 subject name to be used in the requested certificate template", OPT_TXT, {&opt_subject} },
+    { "recipient", "X509 name of the recipient", OPT_TXT, {&opt_recipient} },
+    
+    { "extracertsout", "File where to save extra certificates received", OPT_TXT, {&opt_extracertsout} },
+    { "cacertsout", "File where to save received CA certificates (from IR)", OPT_TXT, {&opt_cacertsout} },
+};
+
+static void show_help(void)
+    {
+    const int ALIGN_COL=15;
+    opt_t *o=cmp_opts;
+    int i=0,j=0;
+    
+    BIO_puts(bio_err, "\nusage: cmp args\n");
+    for (i=0; i < sizeof(cmp_opts)/sizeof(cmp_opts[0]); i++,o++)
+        {
+        BIO_printf(bio_err, " -%s", o->name);
+        for (j=ALIGN_COL-strlen(o->name); j > 0; j--)
+            BIO_puts(bio_err, " ");
+        BIO_printf(bio_err, " -%s\n", o->help);
+        }
+    BIO_puts(bio_err, "\n");
+    }
+
+static int read_config(CONF *conf)
+    {
+    opt_t *opt=cmp_opts;
+    int i=0;
+    for (i=0; i < sizeof(cmp_opts)/sizeof(cmp_opts[0]); i++,opt++)
+        {
+        switch(opt->type)
+            {
+            case OPT_BOOL:
+            case OPT_NUM:
+                NCONF_get_number_e(conf, CMP_SECTION, opt->name, opt->v.num);
+                break;
+            case OPT_TXT:
+                *opt->v.txt = NCONF_get_string(conf, CMP_SECTION, opt->name);
+                break;
+            default:
+                break;
+            }
+        }
+
+    ERR_clear_error();
+    }
+
+static int check_options(void)
+    {
+    if (opt_server)
+        {
+        char *p=strrchr(opt_server, ':');
+        size_t addrlen=0;
+        if (p == NULL)
+            {
+            BIO_puts(bio_err, "error: missing server port\n");
+            goto err;
+            }
+        addrlen=(size_t)p - (size_t)opt_server;
+        server_address=OPENSSL_malloc(addrlen+1);
+        if (server_address == NULL)
+            {
+            BIO_puts(bio_err, "error: out of memory\n");
+            goto err;
+            }
+        strncpy(server_address, opt_server, addrlen);
+        server_address[addrlen]=0;
+        server_port=atoi(++p);
+    }
+    else
+        {
+        BIO_puts(bio_err, "error: missing server address\n");
+        goto err;
+        }
+
+    if (opt_cmd_s)
+        {
+        if (!strcmp(opt_cmd_s, "ir")) opt_cmd = CMP_IR;
+        else if (!strcmp(opt_cmd_s, "kur")) opt_cmd = CMP_KUR;
+        else if (!strcmp(opt_cmd_s, "cr")) opt_cmd = CMP_CR;
+        else if (!strcmp(opt_cmd_s, "rr")) opt_cmd = CMP_RR;
+        else if (!strcmp(opt_cmd_s, "ckuann")) opt_cmd = CMP_CKUANN;
+        else
+            {
+            BIO_printf(bio_err, "error: unknown cmp command '%s'\n", opt_cmd_s);
+            goto err;
+            }
+    }
+    else
+        {
+        BIO_puts(bio_err, "error: no cmp command to execute\n");
+        goto err;
+        }
+
+    switch (opt_cmd)
+        {
+        case CMP_IR:
+            if (!(opt_user && opt_pass) && !(opt_cert && opt_key))
+                {
+                BIO_puts(bio_err, "error: missing user/pass or existing certificate and key for ir\n");
+                goto err;
+                }
+
+            if (opt_cert && !(opt_cacert || opt_trusted))
+                {
+                BIO_puts(bio_err, "error: using client certificate but no server certificate or trusted store set\n");
+                goto err;
+                }
+            break;
+        case CMP_KUR:
+        case CMP_CR:
+        case CMP_RR:
+            if (!(opt_cert && opt_key))
+                {
+                BIO_puts(bio_err, "error: missing certificate and key\n");
+                goto err;
+                }
+
+            if (!opt_cacert && !opt_trusted)
+                {
+                BIO_puts(bio_err, "error: no server certificate or trusted store set\n");
+                goto err;
+                }
+            break;
+        case CMP_CKUANN:
+            /* TODO */
+            break;
+        }
+
+    if (opt_cmd == CMP_IR || opt_cmd == CMP_KUR)
+        {
+        if (!opt_newkey)
+            {
+            BIO_puts(bio_err, "error: missing new key file\n");
+            goto err;
+            }
+        if (!opt_certout)
+            {
+            BIO_puts(bio_err, "error: certout not given, nowhere save certificate\n");
+            goto err;
+            }
+        }
+
+    if (opt_validate_path && !opt_trusted)
+        {
+        BIO_puts(bio_err, "error: trust path validation enabled but no trust store is set\n");
+        goto err;
+        }
+
+    if (opt_keyfmt_s)
+        opt_keyfmt=str2fmt(opt_keyfmt_s);
+
+    if (opt_certfmt_s)
+        opt_certfmt=str2fmt(opt_certfmt_s);
+
+    return 1;
+
+    err:
+    return 0;
+    }
+
+static X509_STORE *create_cert_store(char *file)
+    {
+    X509_STORE *cert_ctx=NULL;
+    X509_LOOKUP *lookup=NULL;
+
+    cert_ctx=X509_STORE_new();
+    if (cert_ctx == NULL) goto err;
+
+    lookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_hash_dir());
+    if (lookup == NULL) goto err;
+
+    X509_LOOKUP_load_file(lookup, file,
+        opt_certfmt==FORMAT_ASN1 ? X509_FILETYPE_ASN1 : X509_FILETYPE_PEM);
+
+    return cert_ctx;
+
+err:
+    return NULL;
+    }
+
+static int setup_ctx(CMP_CTX *ctx)
+    {
+    EVP_PKEY *pkey=NULL;
+    EVP_PKEY *newPkey=NULL;
+    X509 *clcert=NULL;
+    X509 *cacert=NULL;
+
+    CMP_CTX_set1_serverName(ctx, server_address);
+    CMP_CTX_set1_serverPath(ctx, opt_path);
+    CMP_CTX_set1_serverPort(ctx, server_port);
+    
+    if (opt_user && opt_pass)
+        {
+        CMP_CTX_set1_referenceValue(ctx, (unsigned char*)opt_user, strlen(opt_user));
+        CMP_CTX_set1_secretValue(ctx, (unsigned char*)opt_pass, strlen(opt_pass));
+        }
+    
+    if (opt_key &&
+        !(pkey=load_key(bio_err, opt_key, opt_keyfmt, 0, opt_keypass, NULL, "key")))
+        {
+        BIO_printf(bio_err, "error: unable to load private key '%s'\n", opt_key);
+        goto err;
+        }
+    if (pkey) CMP_CTX_set0_pkey(ctx, pkey);
+
+    if (opt_newkey &&
+        !(newPkey=load_key(bio_err, opt_newkey, opt_keyfmt, 0, opt_newkeypass, NULL, "newkey")))
+        {
+        BIO_printf(bio_err, "error: unable to load private key '%s'\n", opt_newkey);
+        goto err;
+        }
+    if (newPkey) CMP_CTX_set0_newPkey(ctx, newPkey);
+
+    if (opt_cert &&
+        !(clcert=load_cert(bio_err, opt_cert, opt_certfmt, NULL, NULL, "clcert")))
+        {
+        BIO_printf(bio_err, "error: unable to load client certificate '%s'\n", opt_cert);
+        goto err;
+        }
+    if (clcert) CMP_CTX_set1_clCert(ctx, clcert);
+
+    if (opt_cacert &&
+        !(cacert=load_cert(bio_err, opt_cacert, opt_certfmt, NULL, NULL, "cacert")))
+        {
+        BIO_printf(bio_err, "error: unable to load server certificate '%s'\n", opt_cacert);
+        goto err;
+        }
+    if (cacert) CMP_CTX_set1_caCert(ctx, cacert);
+
+    if (opt_trusted && !CMP_CTX_set0_trustedStore(ctx, create_cert_store(opt_trusted)))
+        {
+        BIO_printf(bio_err, "error: unable to load trusted store '%s'\n", opt_trusted);
+        goto err;
+        }
+
+    if (opt_untrusted && !CMP_CTX_set0_untrustedStore(ctx, create_cert_store(opt_untrusted)))
+        {
+        BIO_printf(bio_err, "error: unable to load untrusted store '%s'\n", opt_untrusted);
+        goto err;
+        }
+
+    if (opt_subject)
+        {
+        X509_NAME *n=parse_name(opt_subject, MBSTRING_ASC, 0);
+        if (n == NULL)
+            {
+            BIO_printf(bio_err, "error: unable to parse subject name '%s'\n", opt_subject);
+            goto err;
+            }
+        CMP_CTX_set1_subjectName(ctx, n);
+        }
+
+    if (opt_recipient)
+        {
+        X509_NAME *n=parse_name(opt_recipient, MBSTRING_ASC, 0);
+        if (n == NULL)
+            {
+            BIO_printf(bio_err, "error: unable to parse recipient name '%s'\n", opt_recipient);
+            goto err;
+            }
+        CMP_CTX_set1_recipient(ctx, n);
+        }
+
+    /* TODO add extcerts !! */
+    
+    if (opt_validate_path)
+        CMP_CTX_set_option(ctx, CMP_CTX_OPT_VALIDATEPATH, 1);
+
+    CMP_CTX_set1_timeOut(ctx, 5*60);
+
+    return 1;
+
+    err:
+    return 0;
+    }
+
+static CONF *conf=NULL;
+/* static CONF *extconf=NULL; */
+static BIO *bio_c_out=NULL;
+
+static int write_cert(BIO *bio, X509 *cert)
+    {
+        if ( (opt_certfmt == FORMAT_PEM && PEM_write_bio_X509(bio, cert))
+             || (opt_certfmt == FORMAT_ASN1 && i2d_X509_bio(bio, cert)) )
+            return 1;           /* success */
+        return 0;               /* failed */
+    }
+
+static int save_capubs(CMP_CTX *cmp_ctx,  char *destFile)
+    {
+    X509 *cert = NULL;
+    BIO *bio=NULL;
+    int n = 0;
+
+    if (!destFile || (bio=BIO_new(BIO_s_file())) == NULL ||
+            !BIO_write_filename(bio,(char *)destFile))
+        goto err;
+
+    BIO_printf(bio_c_out, "Received %d CA certificates, saving to %s\n", CMP_CTX_caPubs_num(cmp_ctx), destFile);
+    while ( (cert=CMP_CTX_caPubs_pop(cmp_ctx)) != NULL)
+        {
+        if (!write_cert(bio, cert))
+            BIO_printf(bio_err,"ERROR writing to %s!\n", destFile);
+        }
+    return n;
+
+err:
+    BIO_printf(bio_err, "ERROR: could not open '%s' for writing\n", destFile);
+    return 0;
+    }
+
+static int save_extracerts(CMP_CTX *cmp_ctx,  char *destFile)
+    {
+    X509 *cert = NULL;
+    BIO *bio=NULL;
+    int n = 0;
+
+    if (!destFile || (bio=BIO_new(BIO_s_file())) == NULL ||
+            !BIO_write_filename(bio,(char *)destFile))
+        goto err;
+
+    BIO_printf(bio_c_out, "Received %d extra certificates, saving to %s\n", CMP_CTX_extraCertsIn_num(cmp_ctx), destFile);
+    while ( (cert=CMP_CTX_extraCertsIn_pop(cmp_ctx)) != NULL)
+        {
+        if (!write_cert(bio, cert))
+            BIO_printf(bio_err,"ERROR writing to %s!\n", destFile);
+        }
+    return n;
+
+err:
+    BIO_printf(bio_err, "ERROR: could not open '%s' for writing\n", destFile);
+    return 0;
+    }
+
+
+int MAIN(int argc, char **argv)
+    {
+    char *configfile=NULL;
+    long errorline=-1;
+    char *tofree=NULL;
+    int badops=0;
+    int ret=1;
+    CMP_CTX *cmp_ctx;
+    CMPBIO *cmp_bio;
+    X509 *newcert=NULL;
+
+    if (argc <= 1)
+        {
+        badops=1;
+        goto bad_ops;
+        }
+    
+    apps_startup();
+    ERR_load_crypto_strings();
+    bio_c_out=BIO_new_fp(stdout,BIO_NOCLOSE);
+
+    if (configfile == NULL) configfile = getenv("OPENSSL_CONF");
+    if (configfile == NULL) configfile = getenv("SSLEAY_CONF");
+    if (configfile == NULL)
+        {
+        const char *s=X509_get_default_cert_area();
+        size_t len;
+
+        len = strlen(s)+sizeof(CONFIG_FILE)+1;
+        tofree=OPENSSL_malloc(len);
+        BUF_strlcpy(tofree,s,len);
+        BUF_strlcat(tofree,"/"CONFIG_FILE,len);
+        configfile=tofree;
+        }
+
+    if (configfile)
+        {
+        BIO_printf(bio_err,"Using configuration from %s\n",configfile);
+        conf = NCONF_new(NULL);
+        if (NCONF_load(conf,configfile,&errorline) <= 0)
+            {
+            if (errorline <= 0)
+                BIO_printf(bio_err,"error loading the config file '%s'\n",
+                        configfile);
+            else
+                BIO_printf(bio_err,"error on line %ld of config file '%s'\n",
+                        errorline,configfile);
+            goto err;
+            }
+
+        read_config(conf); /*XXX check result*/
+        }
+
+    if(tofree)
+        {
+        OPENSSL_free(tofree);
+        tofree = NULL;
+        }
+
+    while (--argc > 0 && ++argv)
+        {
+        opt_t *opt=cmp_opts;
+        char *arg=*argv;
+        int found,i;
+
+        if (*arg++ != '-' || *arg == 0)
+            {
+            badops=1;
+            break;
+            }
+
+        found=0;
+        for (i=0; i < sizeof(cmp_opts)/sizeof(cmp_opts[0]); i++,opt++)
+            {
+            if (opt->name && !strcmp(arg, opt->name))
+                {
+                if (argc <= 1 && opt->type != OPT_BOOL)
+                    {
+                    BIO_printf(bio_err, "missing argument for '-%s'\n", opt->name);
+                    badops=1;
+                    goto bad_ops;
+                    }
+                switch(opt->type)
+                    {
+                    case OPT_BOOL:
+                        *opt->v.num = 1;
+                        break;
+                    case OPT_NUM:
+                        *opt->v.num = atoi(*++argv);
+                        argc--;
+                        break;
+                    case OPT_TXT:
+                        *opt->v.txt = *++argv;
+                        argc--;
+                        break;
+                    default:
+                        badops=1;
+                        break;
+                    }
+                found=1;
+                }
+            }
+        
+        if (!found)
+            {
+            BIO_printf(bio_err, "unknown argument: '%s'\n", *argv);
+            badops=1;
+            goto bad_ops;
+            }
+        }
+
+    if (!badops)
+        badops = check_options() == 0;
+
+bad_ops:
+    if (badops)
+        {
+        show_help();
+        goto err;
+        }
+
+    if (!(cmp_ctx = CMP_CTX_create()) || !setup_ctx(cmp_ctx))
+        {
+        BIO_puts(bio_err, "error creating new cmp context\n");
+        goto err;
+        }
+
+    if (!CMP_new_http_bio(&cmp_bio, server_address, server_port))
+        {
+        BIO_puts(bio_err, "error: setting up connection context\n");
+        goto err;
+        }
+
+    curl_easy_setopt(cmp_bio, CURLOPT_PROXY, 0);
+
+    switch (opt_cmd)
+        {
+        case CMP_IR:
+            newcert = CMP_doInitialRequestSeq(cmp_bio, cmp_ctx);
+            if (!newcert)
+                goto err;
+            if (opt_cacertsout && CMP_CTX_caPubs_num(cmp_ctx) > 0)
+                save_capubs(cmp_ctx, opt_cacertsout);
+            break;
+        case CMP_KUR:
+            newcert = CMP_doKeyUpdateRequestSeq(cmp_bio, cmp_ctx);
+            if (!newcert)
+                goto err;
+            break;
+        case CMP_CR:
+            newcert = CMP_doCertificateRequestSeq(cmp_bio, cmp_ctx);
+            if (!newcert)
+                goto err;
+            break;
+        case CMP_RR:
+            CMP_doRevocationRequestSeq(cmp_bio, cmp_ctx);
+            break;
+        default: break;
+        }
+
+    if (opt_extracertsout && CMP_CTX_extraCertsOut_num(cmp_ctx) > 0)
+        save_extracerts(cmp_ctx, opt_extracertsout);
+
+    if (newcert && opt_certout)
+        {
+        BIO *b = NULL;
+        BIO_printf(bio_c_out, "saving certificate to '%s'...\n", opt_certout);
+        b=BIO_new(BIO_s_file());
+        if (b == NULL || !BIO_write_filename(b, opt_certout))
+            {
+            BIO_printf(bio_err, "error: unable to open file '%s' for writing\n", opt_certout);
+            goto err;
+            }
+        if (opt_certfmt == FORMAT_ASN1)
+            ret = i2d_X509_bio(b, newcert) == 0;
+        else
+            ret = PEM_write_bio_X509(b, newcert)==0;
+
+        if (ret) goto err;
+        }
+    
+    ret=0;
+err:
+    ERR_print_errors_fp(stderr);
+    /*
+    if(tofree)
+        OPENSSL_free(tofree);
+    */
+
+    OPENSSL_EXIT(ret);
+    }
+
+#endif
+
Index: openssl-1.0.0i-cmp/apps/Makefile
===================================================================
--- openssl-1.0.0i-cmp/apps/Makefile	(revision 377)
+++ openssl-1.0.0i-cmp/apps/Makefile	(working copy)
@@ -39,7 +39,8 @@
 	ca crl rsa rsautl dsa dsaparam ec ecparam \
 	x509 genrsa gendsa genpkey s_server s_client speed \
 	s_time version pkcs7 cms crl2pkcs7 sess_id ciphers nseq pkcs12 \
-	pkcs8 pkey pkeyparam pkeyutl spkac smime rand engine ocsp prime ts
+	pkcs8 pkey pkeyparam pkeyutl spkac smime rand engine ocsp prime ts \
+	cmp
 
 PROGS= $(PROGRAM).c
 
@@ -56,7 +57,7 @@
 	x509.o genrsa.o gendsa.o genpkey.o s_server.o s_client.o speed.o \
 	s_time.o $(A_OBJ) $(S_OBJ) $(RAND_OBJ) version.o sess_id.o \
 	ciphers.o nseq.o pkcs12.o pkcs8.o pkey.o pkeyparam.o pkeyutl.o \
-	spkac.o smime.o cms.o rand.o engine.o ocsp.o prime.o ts.o
+	spkac.o smime.o cms.o rand.o engine.o ocsp.o prime.o ts.o cmp.o
 
 E_SRC=	verify.c asn1pars.c req.c dgst.c dh.c enc.c passwd.c gendh.c errstr.c ca.c \
 	pkcs7.c crl2p7.c crl.c \
@@ -64,7 +65,7 @@
 	x509.c genrsa.c gendsa.c genpkey.c s_server.c s_client.c speed.c \
 	s_time.c $(A_SRC) $(S_SRC) $(RAND_SRC) version.c sess_id.c \
 	ciphers.c nseq.c pkcs12.c pkcs8.c pkey.c pkeyparam.c pkeyutl.c \
-	spkac.c smime.c cms.c rand.c engine.c ocsp.c prime.c ts.c
+	spkac.c smime.c cms.c rand.c engine.c ocsp.c prime.c ts.c cmp.c
 
 SRC=$(E_SRC)
 
Index: openssl-1.0.0i-cmp/apps/progs.h
===================================================================
--- openssl-1.0.0i-cmp/apps/progs.h	(revision 377)
+++ openssl-1.0.0i-cmp/apps/progs.h	(working copy)
@@ -46,6 +46,7 @@
 extern int ocsp_main(int argc,char *argv[]);
 extern int prime_main(int argc,char *argv[]);
 extern int ts_main(int argc,char *argv[]);
+extern int cmp_main(int argc,char *argv[]);
 
 #define FUNC_TYPE_GENERAL	1
 #define FUNC_TYPE_MD		2
@@ -147,6 +148,7 @@
 #endif
 	{FUNC_TYPE_GENERAL,"prime",prime_main},
 	{FUNC_TYPE_GENERAL,"ts",ts_main},
+	{FUNC_TYPE_GENERAL,"cmp",cmp_main},
 #ifndef OPENSSL_NO_MD2
 	{FUNC_TYPE_MD,"md2",dgst_main},
 #endif
Index: openssl-1.0.0i-cmp/Makefile.org
===================================================================
--- openssl-1.0.0i-cmp/Makefile.org	(revision 377)
+++ openssl-1.0.0i-cmp/Makefile.org	(working copy)
@@ -109,6 +109,10 @@
 ZLIB_INCLUDE=
 LIBZLIB=
 
+# Curl stuff
+CURL_INCLUDE=
+LIBCURL=
+
 DIRS=   crypto ssl engines apps test tools
 ENGDIRS= ccgost
 SHLIBDIRS= crypto ssl
@@ -121,7 +125,7 @@
 	bn ec rsa dsa ecdsa dh ecdh dso engine \
 	buffer bio stack lhash rand err \
 	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
-	cms pqueue ts jpake store
+	cms pqueue ts jpake store cmp crmf
 # keep in mind that the above list is adjusted by ./Configure
 # according to no-xxx arguments...
 
@@ -192,6 +196,7 @@
 		SHARED_LDFLAGS='$(SHARED_LDFLAGS)'		\
 		KRB5_INCLUDES='$(KRB5_INCLUDES)' LIBKRB5='$(LIBKRB5)'	\
 		ZLIB_INCLUDE='$(ZLIB_INCLUDE)' LIBZLIB='$(LIBZLIB)'	\
+		CURL_INCLUDE='$(CURL_INCLUDE)' LIBCURL='$(LIBCURL)'	\
 		EXE_EXT='$(EXE_EXT)' SHARED_LIBS='$(SHARED_LIBS)'	\
 		SHLIB_EXT='$(SHLIB_EXT)' SHLIB_TARGET='$(SHLIB_TARGET)'	\
 		PEX_LIBS='$(PEX_LIBS)' EX_LIBS='$(EX_LIBS)'	\
Index: openssl-1.0.0i-cmp/doc/apps/openssl_cmp.pod
===================================================================
--- openssl-1.0.0i-cmp/doc/apps/openssl_cmp.pod	(revision 0)
+++ openssl-1.0.0i-cmp/doc/apps/openssl_cmp.pod	(revision 469)
@@ -0,0 +1,187 @@
+
+=pod
+
+=head1 NAME
+
+cmp - client for the Certificate Management Protocol (RFC4210)
+
+=head1 SYNOPSIS
+
+B<openssl> B<cmp>
+[B<-server ADDRESS:PORT>]
+[B<-path remote_path>]
+[B<-cmd ir|kur|cr|rr|ckuann>]
+[B<-user username>]
+[B<-pass password>]
+[B<-cert filename>]
+[B<-key filename>]
+[B<-keypass password>]
+[B<-certout filename>]
+[B<-newkey filename>]
+[B<-newkeypass password>]
+[B<-cacert filename>]
+[B<-trusted filename>]
+[B<-untrusted filename>]
+[B<-keyfmt DER|PEM>]
+[B<-certfmt DER|PEM>]
+[B<-engine id>]
+[B<-validate_path>]
+[B<-extcerts filenames>]
+[B<-subject name>]
+[B<-recipient name>]
+[B<-extracertsoutn directory>]
+[B<-cacertsout directory>]
+
+=head1 DESCRIPTION
+
+The B<cmp> command is a client implementation for the Certificate
+Management Protocol as defined in RFC4210. It can be used to request
+certificates from a CA server, update their keys and request the
+certificates to be revoked and perform other CMP requests.
+
+=back
+
+=head1 OPTIONS
+
+=over 4
+
+=item B<-server ADDRESS:PORT>
+
+The IP address or hostname and port of the CMP server to connect to.
+
+=item B<-path remote_path>
+
+HTTP path location to use for the CMP server.
+
+=item B<-cmd ir|kur|cr|rr|ckuann>
+
+CMP command to execute. Currently implemented commands are:
+    ir  - Initial Request
+    kur - Key Update Request
+    cr  - Certificate Request
+    rr  - Revocation Request
+
+=item B<-user username>
+
+Username (reference value) to be used when messages are authenticated
+with pre-shared keys.
+
+=item B<-pass password>
+
+Password (secret value) to be used when messages are authenticated with
+pre-shared keys.
+
+=item B<-cert filename>
+
+The client's currently existing certificate. This will be used for
+signing messages for example in the Key Update Request, or when
+authenticating the IR using an existing certificate (as defined in
+appendix E.7 of the RFC).
+
+=item B<-key filename>
+
+The corresponding private key file for the client's current certificate.
+
+=item B<-keypass password>
+
+Password for the private key.
+
+=item B<-certout filename>
+
+The file where the newly received certificate should be saved.
+
+=item B<-newkey filename>
+
+The private key that we will be requesting the new certificate to be
+issued for, for example in IR or KUR.
+
+=item B<-newkeypass password>
+
+Password of the new key file.
+
+=item B<-cacert filename>
+
+Certificate of the CA server.
+
+=item B<-trusted filename>
+
+A file of trusted certificates. The file should contain multiple
+certificates concatenated together.
+
+=item B<-untrusted filename>
+
+A file of untrusted certificates. The file should contain multiple
+certificates.
+
+=item B<-keyfmt DER|PEM>
+
+Format the key files are stored in. Default value is PEM.
+
+=item B<-certfmt DER|PEM>
+
+Format the certificate files are stored in. Default value is PEM.
+
+=item B<-engine id>
+
+currently unused
+
+=item B<-validate_path>
+
+Enables validation of the CA certificates trust chain.
+
+=item B<-extcerts filenames>
+
+List of certificate files to include in the extraCerts field of outgoing
+requests.
+
+=item B<-subject name>
+
+X509 subject name to be used in the requested certificate template.
+
+=item B<-recipient name>
+
+X509 name of the recipient, i.e. the name of the CA we are sending the
+request to. If no CA certificate is provided, then at least the
+recipient name must be specified in order for the IR to work.
+
+=item B<-extracertsoutn directory>
+
+Directory where to save any extra certificates received in a response
+message.
+
+=item B<-cacertsout directory>
+
+Directory where to save received CA certificates (from an Initial
+Response message).
+
+=back
+
+=head1 EXAMPLES
+
+=over 4
+
+Note: in these examples the '\' means the example should be all on one
+line.
+
+Sending an initial request message to a CMP server running on the local
+host, using a pre-shared secret key for authentication. In this example
+the client does not have the CA certificate yet, so we specify the CA's
+name with -recipient and save any CA certificates that we may receive
+under the ./cacerts directory.
+
+  openssl genrsa -out cl_key.pem
+  openssl cmp -cmd ir -server 127.0.0.1:8080 -path pkix/ -user 1234 -pass password -recipient "/CN=CMPserver" -newkey cl_key.pem -subject "/CN=MyName" -cacertsout capubs.pem -certout cl_cert.pem
+
+Then, when the keys for this certificate need to be updated, the client
+can send a key update request. 
+
+  openssl genrsa -out cl_key_new.pem
+  openssl cmp -cmd kur -server 127.0.0.1:8080 -path pkix/ -cert cl_cert.pem -key cl_key.pem -cacert capubs.peml -newkey cl_key_new.pem -certout cl_cert_new.pem
+
+=back
+
+=head1 SEE ALSO
+
+L<genrsa(1)|genrsa(1)>, L<gendsa(1)|gendsa(1)>, L<x509v3_config(5)|x509(1)> 
+
+=cut
Index: openssl-1.0.0i-cmp/Makefile
===================================================================
--- openssl-1.0.0i-cmp/Makefile	(revision 377)
+++ openssl-1.0.0i-cmp/Makefile	(working copy)
@@ -111,6 +111,10 @@
 ZLIB_INCLUDE=
 LIBZLIB=
 
+# Curl stuff
+CURL_INCLUDE=
+LIBCURL=
+
 DIRS=   crypto ssl engines apps test tools
 ENGDIRS= ccgost
 SHLIBDIRS= crypto ssl
@@ -123,7 +127,7 @@
 	bn ec rsa dsa ecdsa dh ecdh dso engine \
 	buffer bio stack lhash rand err \
 	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
-	cms pqueue ts
+	cms pqueue ts cmp crmf
 # keep in mind that the above list is adjusted by ./Configure
 # according to no-xxx arguments...
 
@@ -194,6 +198,7 @@
 		SHARED_LDFLAGS='$(SHARED_LDFLAGS)'		\
 		KRB5_INCLUDES='$(KRB5_INCLUDES)' LIBKRB5='$(LIBKRB5)'	\
 		ZLIB_INCLUDE='$(ZLIB_INCLUDE)' LIBZLIB='$(LIBZLIB)'	\
+		CURL_INCLUDE='$(CURL_INCLUDE)' LIBCURL='$(LIBCURL)'	\
 		EXE_EXT='$(EXE_EXT)' SHARED_LIBS='$(SHARED_LIBS)'	\
 		SHLIB_EXT='$(SHLIB_EXT)' SHLIB_TARGET='$(SHLIB_TARGET)'	\
 		PEX_LIBS='$(PEX_LIBS)' EX_LIBS='$(EX_LIBS)'	\
Index: openssl-1.0.0i-cmp/crypto/cmp/rfc4210.txt
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/rfc4210.txt	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/rfc4210.txt	(revision 469)
@@ -0,0 +1,5323 @@
+
+
+
+
+
+
+Network Working Group                                           C. Adams
+Request for Comments: 4210                          University of Ottawa
+Obsoletes: 2510                                               S. Farrell
+Category: Standards Track                         Trinity College Dublin
+                                                                T. Kause
+                                                                     SSH
+                                                              T. Mononen
+                                                                 SafeNet
+                                                          September 2005
+
+
+               Internet X.509 Public Key Infrastructure
+                 Certificate Management Protocol (CMP)
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2005).
+
+Abstract
+
+   This document describes the Internet X.509 Public Key Infrastructure
+   (PKI) Certificate Management Protocol (CMP).  Protocol messages are
+   defined for X.509v3 certificate creation and management.  CMP
+   provides on-line interactions between PKI components, including an
+   exchange between a Certification Authority (CA) and a client system.
+
+Table of Contents
+
+   1. Introduction ....................................................5
+   2. Requirements ....................................................5
+   3. PKI Management Overview .........................................5
+      3.1. PKI Management Model .......................................6
+           3.1.1. Definitions of PKI Entities .........................6
+                  3.1.1.1. Subjects and End Entities ..................6
+                  3.1.1.2. Certification Authority ....................7
+                  3.1.1.3. Registration Authority .....................7
+           3.1.2. PKI Management Requirements .........................8
+           3.1.3. PKI Management Operations ..........................10
+   4. Assumptions and Restrictions ...................................14
+      4.1. End Entity Initialization .................................14
+
+
+
+Adams, et al.               Standards Track                     [Page 1]
+
+RFC 4210                          CMP                     September 2005
+
+
+      4.2. Initial Registration/Certification ........................14
+           4.2.1. Criteria Used ......................................15
+                  4.2.1.1. Initiation of Registration/Certification ..15
+                  4.2.1.2. End Entity Message Origin Authentication ..15
+                  4.2.1.3. Location of Key Generation ................15
+                  4.2.1.4. Confirmation of Successful Certification ..16
+           4.2.2. Mandatory Schemes ..................................16
+                  4.2.2.1. Centralized Scheme ........................16
+                  4.2.2.2. Basic Authenticated Scheme ................17
+      4.3. Proof-of-Possession (POP) of Private Key ..................17
+           4.3.1. Signature Keys .....................................18
+           4.3.2. Encryption Keys ....................................18
+           4.3.3. Key Agreement Keys .................................19
+      4.4. Root CA Key Update ........................................19
+           4.4.1. CA Operator Actions ................................20
+           4.4.2. Verifying Certificates .............................21
+                  4.4.2.1. Verification in Cases 1, 4, 5, and 8 ......22
+                  4.4.2.2. Verification in Case 2 ....................22
+                  4.4.2.3. Verification in Case 3 ....................23
+                  4.4.2.4. Failure of Verification in Case 6 .........23
+                  4.4.2.5. Failure of Verification in Case 7 .........23
+           4.4.3. Revocation - Change of CA Key ......................23
+   5. Data Structures ................................................24
+      5.1. Overall PKI Message .......................................24
+           5.1.1. PKI Message Header .................................24
+                  5.1.1.1. ImplicitConfirm ...........................27
+                  5.1.1.2. ConfirmWaitTime ...........................27
+           5.1.2. PKI Message Body ...................................27
+           5.1.3. PKI Message Protection .............................28
+                  5.1.3.1. Shared Secret Information .................29
+                  5.1.3.2. DH Key Pairs ..............................30
+                  5.1.3.3. Signature .................................30
+                  5.1.3.4. Multiple Protection .......................30
+      5.2. Common Data Structures ....................................31
+           5.2.1. Requested Certificate Contents .....................31
+           5.2.2. Encrypted Values ...................................31
+           5.2.3. Status codes and Failure Information for
+                  PKI Messages .......................................32
+           5.2.4. Certificate Identification .........................33
+           5.2.5. Out-of-band root CA Public Key .....................33
+           5.2.6. Archive Options ....................................34
+           5.2.7. Publication Information ............................34
+           5.2.8. Proof-of-Possession Structures .....................34
+                  5.2.8.1. Inclusion of the Private Key ..............35
+                  5.2.8.2. Indirect Method ...........................35
+                  5.2.8.3. Challenge-Response Protocol ...............35
+                  5.2.8.4. Summary of PoP Options ....................37
+
+
+
+
+Adams, et al.               Standards Track                     [Page 2]
+
+RFC 4210                          CMP                     September 2005
+
+
+      5.3. Operation-Specific Data Structures ........................38
+           5.3.1. Initialization Request .............................38
+           5.3.2. Initialization Response ............................39
+           5.3.3. Certification Request ..............................39
+           5.3.4. Certification Response .............................39
+           5.3.5. Key Update Request Content .........................40
+           5.3.6. Key Update Response Content ........................41
+           5.3.7. Key Recovery Request Content .......................41
+           5.3.8. Key Recovery Response Content ......................41
+           5.3.9. Revocation Request Content .........................41
+           5.3.10. Revocation Response Content .......................42
+           5.3.11. Cross Certification Request Content ...............42
+           5.3.12. Cross Certification Response Content ..............42
+           5.3.13. CA Key Update Announcement Content ................42
+           5.3.14. Certificate Announcement ..........................43
+           5.3.15. Revocation Announcement ...........................43
+           5.3.16. CRL Announcement ..................................43
+           5.3.17. PKI Confirmation Content ..........................43
+           5.3.18. Certificate Confirmation Content ..................44
+           5.3.19. PKI General Message Content .......................44
+                  5.3.19.1. CA Protocol Encryption Certificate .......44
+                  5.3.19.2. Signing Key Pair Types ...................45
+                  5.3.19.3. Encryption/Key Agreement Key Pair Types ..45
+                  5.3.19.4. Preferred Symmetric Algorithm ............45
+                  5.3.19.5. Updated CA Key Pair ......................45
+                  5.3.19.6. CRL ......................................46
+                  5.3.19.7. Unsupported Object Identifiers ...........46
+                  5.3.19.8. Key Pair Parameters ......................46
+                  5.3.19.9. Revocation Passphrase ....................46
+                  5.3.19.10. ImplicitConfirm .........................46
+                  5.3.19.11. ConfirmWaitTime .........................47
+                  5.3.19.12. Original PKIMessage .....................47
+                  5.3.19.13. Supported Language Tags .................47
+           5.3.20. PKI General Response Content ......................47
+           5.3.21. Error Message Content .............................47
+           5.3.22. Polling Request and Response ......................48
+   6. Mandatory PKI Management Functions .............................51
+      6.1. Root CA Initialization ....................................51
+      6.2. Root CA Key Update ........................................51
+      6.3. Subordinate CA Initialization .............................51
+      6.4. CRL production ............................................52
+      6.5. PKI Information Request ...................................52
+      6.6. Cross Certification .......................................52
+           6.6.1. One-Way Request-Response Scheme: ...................52
+      6.7. End Entity Initialization .................................54
+           6.7.1. Acquisition of PKI Information .....................54
+           6.7.2. Out-of-Band Verification of Root-CA Key ............55
+      6.8. Certificate Request .......................................55
+
+
+
+Adams, et al.               Standards Track                     [Page 3]
+
+RFC 4210                          CMP                     September 2005
+
+
+      6.9. Key Update ................................................55
+   7. Version Negotiation ............................................56
+      7.1. Supporting RFC 2510 Implementations .......................56
+           7.1.1. Clients Talking to RFC 2510 Servers ................56
+           7.1.2. Servers Receiving Version cmp1999 PKIMessages ......57
+   8. Security Considerations ........................................57
+      8.1. Proof-Of-Possession with a Decryption Key .................57
+      8.2. Proof-Of-Possession by Exposing the Private Key ...........57
+      8.3. Attack Against Diffie-Hellman Key Exchange ................57
+   9. IANA Considerations ............................................58
+   Normative References ..............................................58
+   Informative References ............................................59
+   A. Reasons for the Presence of RAs ................................61
+   B. The Use of Revocation Passphrase ...............................61
+   C. Request Message Behavioral Clarifications ......................63
+   D. PKI Management Message Profiles (REQUIRED) .....................65
+      D.1. General Rules for Interpretation of These Profiles ........65
+      D.2. Algorithm Use Profile .....................................66
+      D.3. Proof-of-Possession Profile ...............................68
+      D.4. Initial Registration/Certification (Basic
+           Authenticated Scheme) .....................................68
+      D.5. Certificate Request .......................................74
+      D.6. Key Update Request ........................................75
+   E. PKI Management Message Profiles (OPTIONAL) .....................75
+      E.1. General Rules for Interpretation of These Profiles ........76
+      E.2. Algorithm Use Profile .....................................76
+      E.3. Self-Signed Certificates ..................................76
+      E.4. Root CA Key Update ........................................77
+      E.5. PKI Information Request/Response ..........................77
+      E.6. Cross Certification Request/Response (1-way) ..............79
+      E.7. In-Band Initialization Using External Identity
+           Certificate  ..............................................82
+   F. Compilable ASN.1 Definitions ...................................83
+   G. Acknowledgements ...............................................93
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                     [Page 4]
+
+RFC 4210                          CMP                     September 2005
+
+
+1.  Introduction
+
+   This document describes the Internet X.509 Public Key Infrastructure
+   (PKI) Certificate Management Protocol (CMP).  Protocol messages are
+   defined for certificate creation and management.  The term
+   "certificate" in this document refers to an X.509v3 Certificate as
+   defined in [X509].
+
+   This specification obsoletes RFC 2510.  This specification differs
+   from RFC 2510 in the following areas:
+
+      The PKI management message profile section is split to two
+      appendices: the required profile and the optional profile.  Some
+      of the formerly mandatory functionality is moved to the optional
+      profile.
+
+      The message confirmation mechanism has changed substantially.
+
+      A new polling mechanism is introduced, deprecating the old polling
+      method at the CMP transport level.
+
+      The CMP transport protocol issues are handled in a separate
+      document [CMPtrans], thus the Transports section is removed.
+
+      A new implicit confirmation method is introduced to reduce the
+      number of protocol messages exchanged in a transaction.
+
+      The new specification contains some less prominent protocol
+      enhancements and improved explanatory text on several issues.
+
+2.  Requirements
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT",
+   "RECOMMENDED", "MAY", and "OPTIONAL" in this document (in uppercase,
+   as shown) are to be interpreted as described in [RFC2119].
+
+3.  PKI Management Overview
+
+   The PKI must be structured to be consistent with the types of
+   individuals who must administer it.  Providing such administrators
+   with unbounded choices not only complicates the software required,
+   but also increases the chances that a subtle mistake by an
+   administrator or software developer will result in broader
+   compromise.  Similarly, restricting administrators with cumbersome
+   mechanisms will cause them not to use the PKI.
+
+
+
+
+
+
+Adams, et al.               Standards Track                     [Page 5]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Management protocols are REQUIRED to support on-line interactions
+   between Public Key Infrastructure (PKI) components.  For example, a
+   management protocol might be used between a Certification Authority
+   (CA) and a client system with which a key pair is associated, or
+   between two CAs that issue cross-certificates for each other.
+
+3.1.  PKI Management Model
+
+   Before specifying particular message formats and procedures, we first
+   define the entities involved in PKI management and their interactions
+   (in terms of the PKI management functions required).  We then group
+   these functions in order to accommodate different identifiable types
+   of end entities.
+
+3.1.1.  Definitions of PKI Entities
+
+   The entities involved in PKI management include the end entity (i.e.,
+   the entity to whom the certificate is issued) and the certification
+   authority (i.e., the entity that issues the certificate).  A
+   registration authority MAY also be involved in PKI management.
+
+3.1.1.1.  Subjects and End Entities
+
+   The term "subject" is used here to refer to the entity to whom the
+   certificate is issued, typically named in the subject or
+   subjectAltName field of a certificate.  When we wish to distinguish
+   the tools and/or software used by the subject (e.g., a local
+   certificate management module), we will use the term "subject
+   equipment".  In general, the term "end entity" (EE), rather than
+   "subject", is preferred in order to avoid confusion with the field
+   name.  It is important to note that the end entities here will
+   include not only human users of applications, but also applications
+   themselves (e.g., for IP security).  This factor influences the
+   protocols that the PKI management operations use; for example,
+   application software is far more likely to know exactly which
+   certificate extensions are required than are human users.  PKI
+   management entities are also end entities in the sense that they are
+   sometimes named in the subject or subjectAltName field of a
+   certificate or cross-certificate.  Where appropriate, the term "end-
+   entity" will be used to refer to end entities who are not PKI
+   management entities.
+
+   All end entities require secure local access to some information --
+   at a minimum, their own name and private key, the name of a CA that
+   is directly trusted by this entity, and that CA's public key (or a
+   fingerprint of the public key where a self-certified version is
+   available elsewhere).  Implementations MAY use secure local storage
+   for more than this minimum (e.g., the end entity's own certificate or
+
+
+
+Adams, et al.               Standards Track                     [Page 6]
+
+RFC 4210                          CMP                     September 2005
+
+
+   application-specific information).  The form of storage will also
+   vary -- from files to tamper-resistant cryptographic tokens.  The
+   information stored in such local, trusted storage is referred to here
+   as the end entity's Personal Security Environment (PSE).
+
+   Though PSE formats are beyond the scope of this document (they are
+   very dependent on equipment, et cetera), a generic interchange format
+   for PSEs is defined here: a certification response message MAY be
+   used.
+
+3.1.1.2.  Certification Authority
+
+   The certification authority (CA) may or may not actually be a real
+   "third party" from the end entity's point of view.  Quite often, the
+   CA will actually belong to the same organization as the end entities
+   it supports.
+
+   Again, we use the term "CA" to refer to the entity named in the
+   issuer field of a certificate.  When it is necessary to distinguish
+   the software or hardware tools used by the CA, we use the term "CA
+   equipment".
+
+   The CA equipment will often include both an "off-line" component and
+   an "on-line" component, with the CA private key only available to the
+   "off-line" component.  This is, however, a matter for implementers
+   (though it is also relevant as a policy issue).
+
+   We use the term "root CA" to indicate a CA that is directly trusted
+   by an end entity; that is, securely acquiring the value of a root CA
+   public key requires some out-of-band step(s).  This term is not meant
+   to imply that a root CA is necessarily at the top of any hierarchy,
+   simply that the CA in question is trusted directly.
+
+   A "subordinate CA" is one that is not a root CA for the end entity in
+   question.  Often, a subordinate CA will not be a root CA for any
+   entity, but this is not mandatory.
+
+3.1.1.3.  Registration Authority
+
+   In addition to end-entities and CAs, many environments call for the
+   existence of a Registration Authority (RA) separate from the
+   Certification Authority.  The functions that the registration
+   authority may carry out will vary from case to case but MAY include
+   personal authentication, token distribution, revocation reporting,
+   name assignment, key generation, archival of key pairs, et cetera.
+
+
+
+
+
+
+Adams, et al.               Standards Track                     [Page 7]
+
+RFC 4210                          CMP                     September 2005
+
+
+   This document views the RA as an OPTIONAL component: when it is not
+   present, the CA is assumed to be able to carry out the RA's functions
+   so that the PKI management protocols are the same from the end-
+   entity's point of view.
+
+   Again, we distinguish, where necessary, between the RA and the tools
+   used (the "RA equipment").
+
+   Note that an RA is itself an end entity.  We further assume that all
+   RAs are in fact certified end entities and that RAs have private keys
+   that are usable for signing.  How a particular CA equipment
+   identifies some end entities as RAs is an implementation issue (i.e.,
+   this document specifies no special RA certification operation).  We
+   do not mandate that the RA is certified by the CA with which it is
+   interacting at the moment (so one RA may work with more than one CA
+   whilst only being certified once).
+
+   In some circumstances, end entities will communicate directly with a
+   CA even where an RA is present.  For example, for initial
+   registration and/or certification, the subject may use its RA, but
+   communicate directly with the CA in order to refresh its certificate.
+
+3.1.2.  PKI Management Requirements
+
+   The protocols given here meet the following requirements on PKI
+   management
+
+   1.   PKI management must conform to the ISO/IEC 9594-8/ITU-T X.509
+        standards.
+
+   2.   It must be possible to regularly update any key pair without
+        affecting any other key pair.
+
+   3.   The use of confidentiality in PKI management protocols must be
+        kept to a minimum in order to ease acceptance in environments
+        where strong confidentiality might cause regulatory problems.
+
+   4.   PKI management protocols must allow the use of different
+        industry-standard cryptographic algorithms (specifically
+        including RSA, DSA, MD5, and SHA-1).  This means that any given
+        CA, RA, or end entity may, in principle, use whichever
+        algorithms suit it for its own key pair(s).
+
+   5.   PKI management protocols must not preclude the generation of key
+        pairs by the end-entity concerned, by an RA, or by a CA.  Key
+        generation may also occur elsewhere, but for the purposes of PKI
+        management we can regard key generation as occurring wherever
+        the key is first present at an end entity, RA, or CA.
+
+
+
+Adams, et al.               Standards Track                     [Page 8]
+
+RFC 4210                          CMP                     September 2005
+
+
+   6.   PKI management protocols must support the publication of
+        certificates by the end-entity concerned, by an RA, or by a CA.
+        Different implementations and different environments may choose
+        any of the above approaches.
+
+   7.   PKI management protocols must support the production of
+        Certificate Revocation Lists (CRLs) by allowing certified end
+        entities to make requests for the revocation of certificates.
+        This must be done in such a way that the denial-of-service
+        attacks, which are possible, are not made simpler.
+
+   8.   PKI management protocols must be usable over a variety of
+        "transport" mechanisms, specifically including mail, http,
+        TCP/IP and ftp.
+
+   9.   Final authority for certification creation rests with the CA.
+        No RA or end-entity equipment can assume that any certificate
+        issued by a CA will contain what was requested; a CA may alter
+        certificate field values or may add, delete, or alter extensions
+        according to its operating policy.  In other words, all PKI
+        entities (end-entities, RAs, and CAs) must be capable of
+        handling responses to requests for certificates in which the
+        actual certificate issued is different from that requested (for
+        example, a CA may shorten the validity period requested).  Note
+        that policy may dictate that the CA must not publish or
+        otherwise distribute the certificate until the requesting entity
+        has reviewed and accepted the newly-created certificate
+        (typically through use of the certConf message).
+
+   10.  A graceful, scheduled change-over from one non-compromised CA
+        key pair to the next (CA key update) must be supported (note
+        that if the CA key is compromised, re-initialization must be
+        performed for all entities in the domain of that CA).  An end
+        entity whose PSE contains the new CA public key (following a CA
+        key update) must also be able to verify certificates verifiable
+        using the old public key.  End entities who directly trust the
+        old CA key pair must also be able to verify certificates signed
+        using the new CA private key (required for situations where the
+        old CA public key is "hardwired" into the end entity's
+        cryptographic equipment).
+
+   11.  The functions of an RA may, in some implementations or
+        environments, be carried out by the CA itself.  The protocols
+        must be designed so that end entities will use the same protocol
+        regardless of whether the communication is with an RA or CA.
+        Naturally, the end entity must use the correct RA of CA public
+        key to protect the communication.
+
+
+
+
+Adams, et al.               Standards Track                     [Page 9]
+
+RFC 4210                          CMP                     September 2005
+
+
+   12.  Where an end entity requests a certificate containing a given
+        public key value, the end entity must be ready to demonstrate
+        possession of the corresponding private key value.  This may be
+        accomplished in various ways, depending on the type of
+        certification request.  See Section 4.3 for details of the in-
+        band methods defined for the PKIX-CMP (i.e., Certificate
+        Management Protocol) messages.
+
+3.1.3.  PKI Management Operations
+
+   The following diagram shows the relationship between the entities
+   defined above in terms of the PKI management operations.  The letters
+   in the diagram indicate "protocols" in the sense that a defined set
+   of PKI management messages can be sent along each of the lettered
+   lines.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 10]
+
+RFC 4210                          CMP                     September 2005
+
+
+     +---+     cert. publish        +------------+      j
+     |   |  <---------------------  | End Entity | <-------
+     | C |             g            +------------+      "out-of-band"
+     | e |                            | ^                loading
+     | r |                            | |      initial
+     | t |                          a | | b     registration/
+     |   |                            | |       certification
+     | / |                            | |      key pair recovery
+     |   |                            | |      key pair update
+     | C |                            | |      certificate update
+     | R |  PKI "USERS"               V |      revocation request
+     | L | -------------------+-+-----+-+------+-+-------------------
+     |   |  PKI MANAGEMENT    | ^              | ^
+     |   |    ENTITIES      a | | b          a | | b
+     | R |                    V |              | |
+     | e |             g   +------+    d       | |
+     | p |   <------------ | RA   | <-----+    | |
+     | o |      cert.      |      | ----+ |    | |
+     | s |       publish   +------+   c | |    | |
+     | i |                              | |    | |
+     | t |                              V |    V |
+     | o |          g                 +------------+   i
+     | r |   <------------------------|     CA     |------->
+     | y |          h                 +------------+  "out-of-band"
+     |   |      cert. publish              | ^         publication
+     |   |      CRL publish                | |
+     +---+                                 | |    cross-certification
+                                         e | | f  cross-certificate
+                                           | |       update
+                                           | |
+                                           V |
+                                         +------+
+                                         | CA-2 |
+                                         +------+
+
+   Figure 1 - PKI Entities
+
+     At a high level, the set of operations for which management
+     messages are defined can be grouped as follows.
+
+   1.  CA establishment: When establishing a new CA, certain steps are
+       required (e.g., production of initial CRLs, export of CA public
+       key).
+
+   2.  End entity initialization: this includes importing a root CA
+       public key and requesting information about the options supported
+       by a PKI management entity.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 11]
+
+RFC 4210                          CMP                     September 2005
+
+
+   3.  Certification: various operations result in the creation of new
+       certificates:
+
+       1.  initial registration/certification: This is the process
+           whereby an end entity first makes itself known to a CA or RA,
+           prior to the CA issuing a certificate or certificates for
+           that end entity.  The end result of this process (when it is
+           successful) is that a CA issues a certificate for an end
+           entity's public key, and returns that certificate to the end
+           entity and/or posts that certificate in a public repository.
+           This process may, and typically will, involve multiple
+           "steps", possibly including an initialization of the end
+           entity's equipment.  For example, the end entity's equipment
+           must be securely initialized with the public key of a CA, to
+           be used in validating certificate paths.  Furthermore, an end
+           entity typically needs to be initialized with its own key
+           pair(s).
+
+       2.  key pair update: Every key pair needs to be updated regularly
+           (i.e., replaced with a new key pair), and a new certificate
+           needs to be issued.
+
+       3.  certificate update: As certificates expire, they may be
+           "refreshed" if nothing relevant in the environment has
+           changed.
+
+       4.  CA key pair update: As with end entities, CA key pairs need
+           to be updated regularly; however, different mechanisms are
+           required.
+
+       5.  cross-certification request: One CA requests issuance of a
+           cross-certificate from another CA.  For the purposes of this
+           standard, the following terms are defined.  A "cross-
+           certificate" is a certificate in which the subject CA and the
+           issuer CA are distinct and SubjectPublicKeyInfo contains a
+           verification key (i.e., the certificate has been issued for
+           the subject CA's signing key pair).  When it is necessary to
+           distinguish more finely, the following terms may be used: a
+           cross-certificate is called an "inter-domain cross-
+           certificate" if the subject and issuer CAs belong to
+           different administrative domains; it is called an "intra-
+           domain cross-certificate" otherwise.
+
+           1.  Note 1.  The above definition of "cross-certificate"
+               aligns with the defined term "CA-certificate" in X.509.
+               Note that this term is not to be confused with the X.500
+               "cACertificate" attribute type, which is unrelated.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 12]
+
+RFC 4210                          CMP                     September 2005
+
+
+           2.  Note 2.  In many environments, the term "cross-
+               certificate", unless further qualified, will be
+               understood to be synonymous with "inter-domain cross-
+               certificate" as defined above.
+
+           3.  Note 3.  Issuance of cross-certificates may be, but is
+               not necessarily, mutual; that is, two CAs may issue
+               cross-certificates for each other.
+
+       6.  cross-certificate update: Similar to a normal certificate
+           update, but involving a cross-certificate.
+
+   4.  Certificate/CRL discovery operations: some PKI management
+       operations result in the publication of certificates or CRLs:
+
+       1.  certificate publication: Having gone to the trouble of
+           producing a certificate, some means for publishing it is
+           needed.  The "means" defined in PKIX MAY involve the messages
+           specified in Sections 5.3.13 to 5.3.16, or MAY involve other
+           methods (LDAP, for example) as described in [RFC2559],
+           [RFC2585] (the "Operational Protocols" documents of the PKIX
+           series of specifications).
+
+       2.  CRL publication: As for certificate publication.
+
+   5.  Recovery operations: some PKI management operations are used when
+       an end entity has "lost" its PSE:
+
+       1.  key pair recovery: As an option, user client key materials
+           (e.g., a user's private key used for decryption purposes) MAY
+           be backed up by a CA, an RA, or a key backup system
+           associated with a CA or RA.  If an entity needs to recover
+           these backed up key materials (e.g., as a result of a
+           forgotten password or a lost key chain file), a protocol
+           exchange may be needed to support such recovery.
+
+   6.  Revocation operations: some PKI operations result in the creation
+       of new CRL entries and/or new CRLs:
+
+       1.  revocation request: An authorized person advises a CA of an
+           abnormal situation requiring certificate revocation.
+
+   7.  PSE operations: whilst the definition of PSE operations (e.g.,
+       moving a PSE, changing a PIN, etc.) are beyond the scope of this
+       specification, we do define a PKIMessage (CertRepMessage) that
+       can form the basis of such operations.
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 13]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Note that on-line protocols are not the only way of implementing the
+   above operations.  For all operations, there are off-line methods of
+   achieving the same result, and this specification does not mandate
+   use of on-line protocols.  For example, when hardware tokens are
+   used, many of the operations MAY be achieved as part of the physical
+   token delivery.
+
+   Later sections define a set of standard messages supporting the above
+   operations.  Transport protocols for conveying these exchanges in
+   different environments (file-based, on-line, E-mail, and WWW) are
+   beyond the scope of this document and are specified separately.
+
+4.  Assumptions and Restrictions
+
+4.1.  End Entity Initialization
+
+   The first step for an end entity in dealing with PKI management
+   entities is to request information about the PKI functions supported
+   and to securely acquire a copy of the relevant root CA public key(s).
+
+4.2.  Initial Registration/Certification
+
+   There are many schemes that can be used to achieve initial
+   registration and certification of end entities.  No one method is
+   suitable for all situations due to the range of policies that a CA
+   may implement and the variation in the types of end entity which can
+   occur.
+
+   However, we can classify the initial registration/certification
+   schemes that are supported by this specification.  Note that the word
+   "initial", above, is crucial: we are dealing with the situation where
+   the end entity in question has had no previous contact with the PKI.
+   Where the end entity already possesses certified keys, then some
+   simplifications/alternatives are possible.
+
+   Having classified the schemes that are supported by this
+   specification we can then specify some as mandatory and some as
+   optional.  The goal is that the mandatory schemes cover a sufficient
+   number of the cases that will arise in real use, whilst the optional
+   schemes are available for special cases that arise less frequently.
+   In this way, we achieve a balance between flexibility and ease of
+   implementation.
+
+   We will now describe the classification of initial
+   registration/certification schemes.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 14]
+
+RFC 4210                          CMP                     September 2005
+
+
+4.2.1.  Criteria Used
+
+4.2.1.1.  Initiation of Registration/Certification
+
+   In terms of the PKI messages that are produced, we can regard the
+   initiation of the initial registration/certification exchanges as
+   occurring wherever the first PKI message relating to the end entity
+   is produced.  Note that the real-world initiation of the
+   registration/certification procedure may occur elsewhere (e.g., a
+   personnel department may telephone an RA operator).
+
+   The possible locations are at the end entity, an RA, or a CA.
+
+4.2.1.2.  End Entity Message Origin Authentication
+
+   The on-line messages produced by the end entity that requires a
+   certificate may be authenticated or not.  The requirement here is to
+   authenticate the origin of any messages from the end entity to the
+   PKI (CA/RA).
+
+   In this specification, such authentication is achieved by the PKI
+   (CA/RA) issuing the end entity with a secret value (initial
+   authentication key) and reference value (used to identify the secret
+   value) via some out-of-band means.  The initial authentication key
+   can then be used to protect relevant PKI messages.
+
+   Thus, we can classify the initial registration/certification scheme
+   according to whether or not the on-line end entity -> PKI messages
+   are authenticated or not.
+
+   Note 1: We do not discuss the authentication of the PKI -> end entity
+   messages here, as this is always REQUIRED.  In any case, it can be
+   achieved simply once the root-CA public key has been installed at the
+   end entity's equipment or it can be based on the initial
+   authentication key.
+
+   Note 2: An initial registration/certification procedure can be secure
+   where the messages from the end entity are authenticated via some
+   out-of-band means (e.g., a subsequent visit).
+
+4.2.1.3.  Location of Key Generation
+
+   In this specification, "key generation" is regarded as occurring
+   wherever either the public or private component of a key pair first
+   occurs in a PKIMessage.  Note that this does not preclude a
+   centralized key generation service; the actual key pair MAY have been
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 15]
+
+RFC 4210                          CMP                     September 2005
+
+
+   generated elsewhere and transported to the end entity, RA, or CA
+   using a (proprietary or standardized) key generation request/response
+   protocol (outside the scope of this specification).
+
+   Thus, there are three possibilities for the location of "key
+   generation":  the end entity, an RA, or a CA.
+
+4.2.1.4.  Confirmation of Successful Certification
+
+   Following the creation of an initial certificate for an end entity,
+   additional assurance can be gained by having the end entity
+   explicitly confirm successful receipt of the message containing (or
+   indicating the creation of) the certificate.  Naturally, this
+   confirmation message must be protected (based on the initial
+   authentication key or other means).
+
+   This gives two further possibilities: confirmed or not.
+
+4.2.2.  Mandatory Schemes
+
+   The criteria above allow for a large number of initial
+   registration/certification schemes.  This specification mandates that
+   conforming CA equipment, RA equipment, and EE equipment MUST support
+   the second scheme listed below (Section 4.2.2.2).  Any entity MAY
+   additionally support other schemes, if desired.
+
+4.2.2.1.  Centralized Scheme
+
+   In terms of the classification above, this scheme is, in some ways,
+   the simplest possible, where:
+
+   o  initiation occurs at the certifying CA;
+
+   o  no on-line message authentication is required;
+
+   o  "key generation" occurs at the certifying CA (see Section
+      4.2.1.3);
+
+   o  no confirmation message is required.
+
+   In terms of message flow, this scheme means that the only message
+   required is sent from the CA to the end entity.  The message must
+   contain the entire PSE for the end entity.  Some out-of-band means
+   must be provided to allow the end entity to authenticate the message
+   received and to decrypt any encrypted values.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 16]
+
+RFC 4210                          CMP                     September 2005
+
+
+4.2.2.2.  Basic Authenticated Scheme
+
+   In terms of the classification above, this scheme is where:
+
+   o  initiation occurs at the end entity;
+
+   o  message authentication is REQUIRED;
+
+   o  "key generation" occurs at the end entity (see Section 4.2.1.3);
+
+   o  a confirmation message is REQUIRED.
+
+   In terms of message flow, the basic authenticated scheme is as
+   follows:
+
+     End entity                                          RA/CA
+     ==========                                      =============
+          out-of-band distribution of Initial Authentication
+          Key (IAK) and reference value (RA/CA -> EE)
+     Key generation
+     Creation of certification request
+     Protect request with IAK
+                   -->>-- certification request -->>--
+                                                    verify request
+                                                    process request
+                                                    create response
+                   --<<-- certification response --<<--
+     handle response
+     create confirmation
+                   -->>-- cert conf message      -->>--
+                                                    verify confirmation
+                                                    create response
+                   --<<-- conf ack (optional)    --<<--
+     handle response
+
+   (Where verification of the cert confirmation message fails, the RA/CA
+   MUST revoke the newly issued certificate if it has been published or
+   otherwise made available.)
+
+4.3.  Proof-of-Possession (POP) of Private Key
+
+   In order to prevent certain attacks and to allow a CA/RA to properly
+   check the validity of the binding between an end entity and a key
+   pair, the PKI management operations specified here make it possible
+   for an end entity to prove that it has possession of (i.e., is able
+   to use) the private key corresponding to the public key for which a
+   certificate is requested.  A given CA/RA is free to choose how to
+   enforce POP (e.g., out-of-band procedural means versus PKIX-CMP
+
+
+
+Adams, et al.               Standards Track                    [Page 17]
+
+RFC 4210                          CMP                     September 2005
+
+
+   in-band messages) in its certification exchanges (i.e., this may be a
+   policy issue).  However, it is REQUIRED that CAs/RAs MUST enforce POP
+   by some means because there are currently many non-PKIX operational
+   protocols in use (various electronic mail protocols are one example)
+   that do not explicitly check the binding between the end entity and
+   the private key.  Until operational protocols that do verify the
+   binding (for signature, encryption, and key agreement key pairs)
+   exist, and are ubiquitous, this binding can only be assumed to have
+   been verified by the CA/RA.  Therefore, if the binding is not
+   verified by the CA/RA, certificates in the Internet Public-Key
+   Infrastructure end up being somewhat less meaningful.
+
+   POP is accomplished in different ways depending upon the type of key
+   for which a certificate is requested.  If a key can be used for
+   multiple purposes (e.g., an RSA key) then any appropriate method MAY
+
+   be used (e.g., a key that may be used for signing, as well as other
+   purposes, SHOULD NOT be sent to the CA/RA in order to prove
+   possession).
+
+   This specification explicitly allows for cases where an end entity
+   supplies the relevant proof to an RA and the RA subsequently attests
+   to the CA that the required proof has been received (and validated!).
+   For example, an end entity wishing to have a signing key certified
+   could send the appropriate signature to the RA, which then simply
+   notifies the relevant CA that the end entity has supplied the
+   required proof.  Of course, such a situation may be disallowed by
+   some policies (e.g., CAs may be the only entities permitted to verify
+   POP during certification).
+
+4.3.1.  Signature Keys
+
+   For signature keys, the end entity can sign a value to prove
+   possession of the private key.
+
+4.3.2.  Encryption Keys
+
+   For encryption keys, the end entity can provide the private key to
+   the CA/RA, or can be required to decrypt a value in order to prove
+   possession of the private key (see Section 5.2.8).  Decrypting a
+   value can be achieved either directly or indirectly.
+
+   The direct method is for the RA/CA to issue a random challenge to
+   which an immediate response by the EE is required.
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 18]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The indirect method is to issue a certificate that is encrypted for
+   the end entity (and have the end entity demonstrate its ability to
+   decrypt this certificate in the confirmation message).  This allows a
+   CA to issue a certificate in a form that can only be used by the
+   intended end entity.
+
+   This specification encourages use of the indirect method because it
+   requires no extra messages to be sent (i.e., the proof can be
+   demonstrated using the {request, response, confirmation} triple of
+   messages).
+
+4.3.3.  Key Agreement Keys
+
+   For key agreement keys, the end entity and the PKI management entity
+   (i.e., CA or RA) must establish a shared secret key in order to prove
+   that the end entity has possession of the private key.
+
+   Note that this need not impose any restrictions on the keys that can
+   be certified by a given CA.  In particular, for Diffie-Hellman keys
+   the end entity may freely choose its algorithm parameters provided
+   that the CA can generate a short-term (or one-time) key pair with the
+   appropriate parameters when necessary.
+
+4.4.  Root CA Key Update
+
+   This discussion only applies to CAs that are directly trusted by some
+   end entities.  Self-signed CAs SHALL be considered as directly
+   trusted CAs.  Recognizing whether a non-self-signed CA is supposed to
+   be directly trusted for some end entities is a matter of CA policy
+   and is thus beyond the scope of this document.
+
+   The basis of the procedure described here is that the CA protects its
+   new public key using its previous private key and vice versa.  Thus,
+   when a CA updates its key pair it must generate two extra
+   cACertificate attribute values if certificates are made available
+   using an X.500 directory (for a total of four: OldWithOld,
+   OldWithNew, NewWithOld, and NewWithNew).
+
+   When a CA changes its key pair, those entities who have acquired the
+   old CA public key via "out-of-band" means are most affected.  It is
+   these end entities who will need access to the new CA public key
+   protected with the old CA private key.  However, they will only
+   require this for a limited period (until they have acquired the new
+   CA public key via the "out-of-band" mechanism).  This will typically
+   be easily achieved when these end entities' certificates expire.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 19]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The data structure used to protect the new and old CA public keys is
+   a standard certificate (which may also contain extensions).  There
+   are no new data structures required.
+
+   Note 1.  This scheme does not make use of any of the X.509 v3
+   extensions as it must be able to work even for version 1
+   certificates.  The presence of the KeyIdentifier extension would make
+   for efficiency improvements.
+
+   Note 2.  While the scheme could be generalized to cover cases where
+   the CA updates its key pair more than once during the validity period
+   of one of its end entities' certificates, this generalization seems
+   of dubious value.  Not having this generalization simply means that
+   the validity periods of certificates issued with the old CA key pair
+   cannot exceed the end of the OldWithNew validity period.
+
+   Note 3.  This scheme ensures that end entities will acquire the new
+   CA public key, at the latest by the expiry of the last certificate
+   they owned that was signed with the old CA private key (via the
+   "out-of-band" means).  Certificate and/or key update operations
+   occurring at other times do not necessarily require this (depending
+   on the end entity's equipment).
+
+4.4.1.  CA Operator Actions
+
+   To change the key of the CA, the CA operator does the following:
+
+   1.  Generate a new key pair;
+
+   2.  Create a certificate containing the old CA public key signed with
+       the new private key (the "old with new" certificate);
+
+   3.  Create a certificate containing the new CA public key signed with
+       the old private key (the "new with old" certificate);
+
+   4.  Create a certificate containing the new CA public key signed with
+       the new private key (the "new with new" certificate);
+
+   5.  Publish these new certificates via the repository and/or other
+       means (perhaps using a CAKeyUpdAnn message);
+
+   6.  Export the new CA public key so that end entities may acquire it
+       using the "out-of-band" mechanism (if required).
+
+   The old CA private key is then no longer required.  However, the old
+   CA public key will remain in use for some time.  The old CA public
+   key is no longer required (other than for non-repudiation) when all
+   end entities of this CA have securely acquired the new CA public key.
+
+
+
+Adams, et al.               Standards Track                    [Page 20]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The "old with new" certificate must have a validity period starting
+   at the generation time of the old key pair and ending at the expiry
+   date of the old public key.
+
+   The "new with old" certificate must have a validity period starting
+   at the generation time of the new key pair and ending at the time by
+   which all end entities of this CA will securely possess the new CA
+   public key (at the latest, the expiry date of the old public key).
+
+   The "new with new" certificate must have a validity period starting
+   at the generation time of the new key pair and ending at or before
+   the time by which the CA will next update its key pair.
+
+4.4.2.  Verifying Certificates
+
+   Normally when verifying a signature, the verifier verifies (among
+   other things) the certificate containing the public key of the
+   signer.  However, once a CA is allowed to update its key there are a
+   range of new possibilities.  These are shown in the table below.
+
+                Repository contains NEW     Repository contains only OLD
+                  and OLD public keys        public key (due to, e.g.,
+                                              delay in publication)
+
+                   PSE      PSE Contains  PSE Contains    PSE Contains
+                Contains     OLD public    NEW public      OLD public
+               NEW public       key            key            key
+                   key
+
+    Signer's   Case 1:      Case 3:       Case 5:        Case 7:
+    certifi-   This is      In this case  Although the   In this case
+    cate is    the          the verifier  CA operator    the CA
+    protected  standard     must access   has not        operator  has
+    using NEW  case where   the           updated the    not updated
+    public     the          repository in repository the the repository
+    key        verifier     order to get  verifier can   and so the
+               can          the value of  verify the     verification
+               directly     the NEW       certificate    will FAIL
+               verify the   public key    directly -
+               certificate                this is thus
+               without                    the same as
+               using the                  case 1.
+               repository
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 21]
+
+RFC 4210                          CMP                     September 2005
+
+
+    Signer's   Case 2:      Case 4:       Case 6:        Case 8:
+    certifi-   In this      In this case  The verifier   Although the
+    cate is    case the     the verifier  thinks this    CA operator
+    protected  verifier     can directly  is the         has not
+    using OLD  must         verify the    situation of   updated the
+    public     access the   certificate   case 2 and     repository the
+    key        repository   without       will access    verifier can
+               in order     using the     the            verify the
+               to get the   repository    repository;    certificate
+               value of                   however, the   directly -
+               the OLD                    verification   this is thus
+               public key                 will FAIL      the same as
+                                                         case 4.
+
+4.4.2.1.  Verification in Cases 1, 4, 5, and 8
+
+   In these cases, the verifier has a local copy of the CA public key
+   that can be used to verify the certificate directly.  This is the
+   same as the situation where no key change has occurred.
+
+   Note that case 8 may arise between the time when the CA operator has
+   generated the new key pair and the time when the CA operator stores
+   the updated attributes in the repository.  Case 5 can only arise if
+
+   the CA operator has issued both the signer's and verifier's
+   certificates during this "gap" (the CA operator SHOULD avoid this as
+   it leads to the failure cases described below)
+
+4.4.2.2.  Verification in Case 2
+
+   In case 2, the verifier must get access to the old public key of the
+   CA.  The verifier does the following:
+
+   1.  Look up the caCertificate attribute in the repository and pick
+       the OldWithNew certificate (determined based on validity periods;
+       note that the subject and issuer fields must match);
+
+   2.  Verify that this is correct using the new CA key (which the
+       verifier has locally);
+
+   3.  If correct, check the signer's certificate using the old CA key.
+
+   Case 2 will arise when the CA operator has issued the signer's
+   certificate, then changed the key, and then issued the verifier's
+   certificate; so it is quite a typical case.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 22]
+
+RFC 4210                          CMP                     September 2005
+
+
+4.4.2.3.  Verification in Case 3
+
+   In case 3, the verifier must get access to the new public key of the
+   CA.  The verifier does the following:
+
+   1.  Look up the CACertificate attribute in the repository and pick
+       the NewWithOld certificate (determined based on validity periods;
+       note that the subject and issuer fields must match);
+
+   2.  Verify that this is correct using the old CA key (which the
+       verifier has stored locally);
+
+   3.  If correct, check the signer's certificate using the new CA key.
+
+   Case 3 will arise when the CA operator has issued the verifier's
+   certificate, then changed the key, and then issued the signer's
+   certificate; so it is also quite a typical case.
+
+4.4.2.4.  Failure of Verification in Case 6
+
+   In this case, the CA has issued the verifier's PSE, which contains
+   the new key, without updating the repository attributes.  This means
+   that the verifier has no means to get a trustworthy version of the
+   CA's old key and so verification fails.
+
+   Note that the failure is the CA operator's fault.
+
+4.4.2.5.  Failure of Verification in Case 7
+
+   In this case, the CA has issued the signer's certificate protected
+   with the new key without updating the repository attributes.  This
+   means that the verifier has no means to get a trustworthy version of
+   the CA's new key and so verification fails.
+
+   Note that the failure is again the CA operator's fault.
+
+4.4.3.  Revocation - Change of CA Key
+
+   As we saw above, the verification of a certificate becomes more
+   complex once the CA is allowed to change its key.  This is also true
+   for revocation checks as the CA may have signed the CRL using a newer
+   private key than the one within the user's PSE.
+
+   The analysis of the alternatives is the same as for certificate
+   verification.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 23]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.  Data Structures
+
+   This section contains descriptions of the data structures required
+   for PKI management messages.  Section 6 describes constraints on
+   their values and the sequence of events for each of the various PKI
+   management operations.
+
+5.1.  Overall PKI Message
+
+   All of the messages used in this specification for the purposes of
+   PKI management use the following structure:
+
+      PKIMessage ::= SEQUENCE {
+         header           PKIHeader,
+         body             PKIBody,
+         protection   [0] PKIProtection OPTIONAL,
+         extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
+                          OPTIONAL
+     }
+     PKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage
+
+   The PKIHeader contains information that is common to many PKI
+   messages.
+
+   The PKIBody contains message-specific information.
+
+   The PKIProtection, when used, contains bits that protect the PKI
+   message.
+
+   The extraCerts field can contain certificates that may be useful to
+   the recipient.  For example, this can be used by a CA or RA to
+   present an end entity with certificates that it needs to verify its
+   own new certificate (if, for example, the CA that issued the end
+   entity's certificate is not a root CA for the end entity).  Note that
+   this field does not necessarily contain a certification path; the
+   recipient may have to sort, select from, or otherwise process the
+   extra certificates in order to use them.
+
+5.1.1.  PKI Message Header
+
+   All PKI messages require some header information for addressing and
+   transaction identification.  Some of this information will also be
+   present in a transport-specific envelope.  However, if the PKI
+   message is protected, then this information is also protected (i.e.,
+   we make no assumption about secure transport).
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 24]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The following data structure is used to contain this information:
+
+     PKIHeader ::= SEQUENCE {
+         pvno                INTEGER     { cmp1999(1), cmp2000(2) },
+         sender              GeneralName,
+         recipient           GeneralName,
+         messageTime     [0] GeneralizedTime         OPTIONAL,
+         protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
+         senderKID       [2] KeyIdentifier           OPTIONAL,
+         recipKID        [3] KeyIdentifier           OPTIONAL,
+         transactionID   [4] OCTET STRING            OPTIONAL,
+         senderNonce     [5] OCTET STRING            OPTIONAL,
+         recipNonce      [6] OCTET STRING            OPTIONAL,
+         freeText        [7] PKIFreeText             OPTIONAL,
+         generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
+                             InfoTypeAndValue     OPTIONAL
+     }
+     PKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
+
+   The pvno field is fixed (at 2) for this version of this
+   specification.
+
+   The sender field contains the name of the sender of the PKIMessage.
+   This name (in conjunction with senderKID, if supplied) should be
+   sufficient to indicate the key to use to verify the protection on the
+   message.  If nothing about the sender is known to the sending entity
+   (e.g., in the init. req. message, where the end entity may not know
+   its own Distinguished Name (DN), e-mail name, IP address, etc.), then
+   the "sender" field MUST contain a "NULL" value; that is, the SEQUENCE
+   OF relative distinguished names is of zero length.  In such a case,
+   the senderKID field MUST hold an identifier (i.e., a reference
+   number) that indicates to the receiver the appropriate shared secret
+   information to use to verify the message.
+
+   The recipient field contains the name of the recipient of the
+   PKIMessage.  This name (in conjunction with recipKID, if supplied)
+   should be usable to verify the protection on the message.
+
+   The protectionAlg field specifies the algorithm used to protect the
+   message.  If no protection bits are supplied (note that PKIProtection
+   is OPTIONAL) then this field MUST be omitted; if protection bits are
+   supplied, then this field MUST be supplied.
+
+   senderKID and recipKID are usable to indicate which keys have been
+   used to protect the message (recipKID will normally only be required
+   where protection of the message uses Diffie-Hellman (DH) keys).
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 25]
+
+RFC 4210                          CMP                     September 2005
+
+
+   These fields MUST be used if required to uniquely identify a key
+   (e.g., if more than one key is associated with a given sender name)
+   and SHOULD be omitted otherwise.
+
+   The transactionID field within the message header is to be used to
+   allow the recipient of a message to correlate this with an ongoing
+   transaction.  This is needed for all transactions that consist of
+   more than just a single request/response pair.  For transactions that
+   consist of a single request/response pair, the rules are as follows.
+   A client MAY populate the transactionID field of the request.  If a
+   server receives such a request that has the transactionID field set,
+   then it MUST set the transactionID field of the response to the same
+   value.  If a server receives such request with a missing
+   transactionID field, then it MAY set transactionID field of the
+   response.
+
+   For transactions that consist of more than just a single
+   request/response pair, the rules are as follows.  Clients SHOULD
+   generate a transactionID for the first request.  If a server receives
+   such a request that has the transactionID field set, then it MUST set
+   the transactionID field of the response to the same value.  If a
+   server receives such request with a missing transactionID field, then
+   it MUST populate the transactionID field of the response with a
+   server-generated ID.  Subsequent requests and responses MUST all set
+   the transactionID field to the thus established value.  In all cases
+   where a transactionID is being used, a given client MUST NOT have
+   more than one transaction with the same transactionID in progress at
+   any time (to a given server).  Servers are free to require uniqueness
+   of the transactionID or not, as long as they are able to correctly
+   associate messages with the corresponding transaction.  Typically,
+   this means that a server will require the {client, transactionID}
+   tuple to be unique, or even the transactionID alone to be unique, if
+   it cannot distinguish clients based on transport-level information.
+   A server receiving the first message of a transaction (which requires
+   more than a single request/response pair) that contains a
+   transactionID that does not allow it to meet the above constraints
+   (typically because the transactionID is already in use) MUST send
+   back an ErrorMsgContent with a PKIFailureInfo of transactionIdInUse.
+   It is RECOMMENDED that the clients fill the transactionID field with
+   128 bits of (pseudo-) random data for the start of a transaction to
+   reduce the probability of having the transactionID in use at the
+   server.
+
+   The senderNonce and recipNonce fields protect the PKIMessage against
+   replay attacks.  The senderNonce will typically be 128 bits of
+   (pseudo-) random data generated by the sender, whereas the recipNonce
+   is copied from the senderNonce of the previous message in the
+   transaction.
+
+
+
+Adams, et al.               Standards Track                    [Page 26]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The messageTime field contains the time at which the sender created
+   the message.  This may be useful to allow end entities to
+   correct/check their local time for consistency with the time on a
+   central system.
+
+   The freeText field may be used to send a human-readable message to
+   the recipient (in any number of languages).  The first language used
+   in this sequence indicates the desired language for replies.
+
+   The generalInfo field may be used to send machine-processable
+   additional data to the recipient.  The following generalInfo
+   extensions are defined and MAY be supported.
+
+5.1.1.1.  ImplicitConfirm
+
+   This is used by the EE to inform the CA that it does not wish to send
+   a certificate confirmation for issued certificates.
+
+         implicitConfirm OBJECT IDENTIFIER ::= {id-it 13}
+         ImplicitConfirmValue ::= NULL
+
+   If the CA grants the request to the EE, it MUST put the same
+   extension in the PKIHeader of the response.  If the EE does not find
+   the extension in the response, it MUST send the certificate
+   confirmation.
+
+5.1.1.2.  ConfirmWaitTime
+
+   This is used by the CA to inform the EE how long it intends to wait
+   for the certificate confirmation before revoking the certificate and
+   deleting the transaction.
+
+         confirmWaitTime OBJECT IDENTIFIER ::= {id-it 14}
+         ConfirmWaitTimeValue ::= GeneralizedTime
+
+5.1.2.  PKI Message Body
+
+        PKIBody ::= CHOICE {
+          ir       [0]  CertReqMessages,       --Initialization Req
+          ip       [1]  CertRepMessage,        --Initialization Resp
+          cr       [2]  CertReqMessages,       --Certification Req
+          cp       [3]  CertRepMessage,        --Certification Resp
+          p10cr    [4]  CertificationRequest,  --PKCS #10 Cert.  Req.
+          popdecc  [5]  POPODecKeyChallContent --pop Challenge
+          popdecr  [6]  POPODecKeyRespContent, --pop Response
+          kur      [7]  CertReqMessages,       --Key Update Request
+          kup      [8]  CertRepMessage,        --Key Update Response
+          krr      [9]  CertReqMessages,       --Key Recovery Req
+
+
+
+Adams, et al.               Standards Track                    [Page 27]
+
+RFC 4210                          CMP                     September 2005
+
+
+          krp      [10] KeyRecRepContent,      --Key Recovery Resp
+          rr       [11] RevReqContent,         --Revocation Request
+          rp       [12] RevRepContent,         --Revocation Response
+          ccr      [13] CertReqMessages,       --Cross-Cert.  Request
+          ccp      [14] CertRepMessage,        --Cross-Cert.  Resp
+          ckuann   [15] CAKeyUpdAnnContent,    --CA Key Update Ann.
+          cann     [16] CertAnnContent,        --Certificate Ann.
+          rann     [17] RevAnnContent,         --Revocation Ann.
+          crlann   [18] CRLAnnContent,         --CRL Announcement
+          pkiconf  [19] PKIConfirmContent,     --Confirmation
+          nested   [20] NestedMessageContent,  --Nested Message
+          genm     [21] GenMsgContent,         --General Message
+          genp     [22] GenRepContent,         --General Response
+          error    [23] ErrorMsgContent,       --Error Message
+          certConf [24] CertConfirmContent,    --Certificate confirm
+          pollReq  [25] PollReqContent,        --Polling request
+          pollRep  [26] PollRepContent         --Polling response
+          }
+
+   The specific types are described in Section 5.3 below.
+
+5.1.3.  PKI Message Protection
+
+   Some PKI messages will be protected for integrity.  (Note that if an
+   asymmetric algorithm is used to protect a message and the relevant
+   public component has been certified already, then the origin of the
+   message can also be authenticated.  On the other hand, if the public
+   component is uncertified, then the message origin cannot be
+   automatically authenticated, but may be authenticated via out-of-band
+   means.)
+
+   When protection is applied, the following structure is used:
+
+        PKIProtection ::= BIT STRING
+
+   The input to the calculation of PKIProtection is the DER encoding of
+   the following data structure:
+
+        ProtectedPart ::= SEQUENCE {
+            header    PKIHeader,
+            body      PKIBody
+        }
+
+   There MAY be cases in which the PKIProtection BIT STRING is
+   deliberately not used to protect a message (i.e., this OPTIONAL field
+   is omitted) because other protection, external to PKIX, will be
+   applied instead.  Such a choice is explicitly allowed in this
+   specification.  Examples of such external protection include PKCS #7
+
+
+
+Adams, et al.               Standards Track                    [Page 28]
+
+RFC 4210                          CMP                     September 2005
+
+
+   [PKCS7] and Security Multiparts [RFC1847] encapsulation of the
+   PKIMessage (or simply the PKIBody (omitting the CHOICE tag), if the
+   relevant PKIHeader information is securely carried in the external
+   mechanism).  It is noted, however, that many such external mechanisms
+   require that the end entity already possesses a public-key
+   certificate, and/or a unique Distinguished Name, and/or other such
+   infrastructure-related information.  Thus, they may not be
+   appropriate for initial registration, key-recovery, or any other
+   process with "boot-strapping" characteristics.  For those cases it
+   may be necessary that the PKIProtection parameter be used.  In the
+   future, if/when external mechanisms are modified to accommodate
+   boot-strapping scenarios, the use of PKIProtection may become rare or
+   non-existent.
+
+   Depending on the circumstances, the PKIProtection bits may contain a
+   Message Authentication Code (MAC) or signature.  Only the following
+   cases can occur:
+
+5.1.3.1.  Shared Secret Information
+
+   In this case, the sender and recipient share secret information
+   (established via out-of-band means or from a previous PKI management
+   operation).  PKIProtection will contain a MAC value and the
+   protectionAlg will be the following (see also Appendix D.2):
+
+     id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}
+     PBMParameter ::= SEQUENCE {
+       salt                OCTET STRING,
+       owf                 AlgorithmIdentifier,
+       iterationCount      INTEGER,
+       mac                 AlgorithmIdentifier
+     }
+
+   In the above protectionAlg, the salt value is appended to the shared
+   secret input.  The OWF is then applied iterationCount times, where
+   the salted secret is the input to the first iteration and, for each
+   successive iteration, the input is set to be the output of the
+   previous iteration.  The output of the final iteration (called
+   "BASEKEY" for ease of reference, with a size of "H") is what is used
+   to form the symmetric key.  If the MAC algorithm requires a K-bit key
+   and K <= H, then the most significant K bits of BASEKEY are used.  If
+   K > H, then all of BASEKEY is used for the most significant H bits of
+   the key, OWF("1" || BASEKEY) is used for the next most significant H
+   bits of the key, OWF("2" || BASEKEY) is used for the next most
+   significant H bits of the key, and so on, until all K bits have been
+   derived.  [Here "N" is the ASCII byte encoding the number N and "||"
+   represents concatenation.]
+
+
+
+
+Adams, et al.               Standards Track                    [Page 29]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Note: it is RECOMMENDED that the fields of PBMParameter remain
+   constant throughout the messages of a single transaction (e.g.,
+   ir/ip/certConf/pkiConf) in order to reduce the overhead associated
+   with PasswordBasedMac computation).
+
+5.1.3.2.  DH Key Pairs
+
+   Where the sender and receiver possess Diffie-Hellman certificates
+   with compatible DH parameters, in order to protect the message the
+   end entity must generate a symmetric key based on its private DH key
+   value and the DH public key of the recipient of the PKI message.
+   PKIProtection will contain a MAC value keyed with this derived
+   symmetric key and the protectionAlg will be the following:
+
+        id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}
+
+        DHBMParameter ::= SEQUENCE {
+            owf                 AlgorithmIdentifier,
+            -- AlgId for a One-Way Function (SHA-1 recommended)
+            mac                 AlgorithmIdentifier
+            -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+        }   -- or HMAC [RFC2104, RFC2202])
+
+   In the above protectionAlg, OWF is applied to the result of the
+   Diffie-Hellman computation.  The OWF output (called "BASEKEY" for
+   ease of reference, with a size of "H") is what is used to form the
+   symmetric key.  If the MAC algorithm requires a K-bit key and K <= H,
+   then the most significant K bits of BASEKEY are used.  If K > H, then
+   all of BASEKEY is used for the most significant H bits of the key,
+   OWF("1" || BASEKEY) is used for the next most significant H bits of
+   the key, OWF("2" || BASEKEY) is used for the next most significant H
+   bits of the key, and so on, until all K bits have been derived.
+   [Here "N" is the ASCII byte encoding the number N and "||" represents
+   concatenation.]
+
+5.1.3.3.  Signature
+
+   In this case, the sender possesses a signature key pair and simply
+   signs the PKI message.  PKIProtection will contain the signature
+   value and the protectionAlg will be an AlgorithmIdentifier for a
+   digital signature (e.g., md5WithRSAEncryption or dsaWithSha-1).
+
+5.1.3.4.  Multiple Protection
+
+   In cases where an end entity sends a protected PKI message to an RA,
+   the RA MAY forward that message to a CA, attaching its own protection
+   (which MAY be a MAC or a signature, depending on the information and
+   certificates shared between the RA and the CA).  This is accomplished
+
+
+
+Adams, et al.               Standards Track                    [Page 30]
+
+RFC 4210                          CMP                     September 2005
+
+
+   by nesting the entire message sent by the end entity within a new PKI
+   message.  The structure used is as follows.
+
+          NestedMessageContent ::= PKIMessages
+
+   (The use of PKIMessages, a SEQUENCE OF PKIMessage, lets the RA batch
+   the requests of several EEs in a single new message.  For simplicity,
+   all messages in the batch MUST be of the same type (e.g., ir).)  If
+   the RA wishes to modify the message(s) in some way (e.g., add
+   particular field values or new extensions), then it MAY create its
+   own desired PKIBody.  The original PKIMessage from the EE MAY be
+   included in the generalInfo field of PKIHeader (to accommodate, for
+   example, cases in which the CA wishes to check POP or other
+   information on the original EE message).  The infoType to be used in
+   this situation is {id-it 15} (see Section 5.3.19 for the value of
+   id-it) and the infoValue is PKIMessages (contents MUST be in the same
+   order as the requests in PKIBody).
+
+5.2.  Common Data Structures
+
+   Before specifying the specific types that may be placed in a PKIBody,
+   we define some data structures that are used in more than one case.
+
+5.2.1.  Requested Certificate Contents
+
+   Various PKI management messages require that the originator of the
+   message indicate some of the fields that are required to be present
+   in a certificate.  The CertTemplate structure allows an end entity or
+   RA to specify as much as it wishes about the certificate it requires.
+   CertTemplate is identical to a Certificate, but with all fields
+   optional.
+
+   Note that even if the originator completely specifies the contents of
+   a certificate it requires, a CA is free to modify fields within the
+   certificate actually issued.  If the modified certificate is
+   unacceptable to the requester, the requester MUST send back a
+   certConf message that either does not include this certificate (via a
+   CertHash), or does include this certificate (via a CertHash) along
+   with a status of "rejected".  See Section 5.3.18 for the definition
+   and use of CertHash and the certConf message.
+
+   See Appendix C and [CRMF] for CertTemplate syntax.
+
+5.2.2.  Encrypted Values
+
+   Where encrypted values (restricted, in this specification, to be
+   either private keys or certificates) are sent in PKI messages, the
+   EncryptedValue data structure is used.
+
+
+
+Adams, et al.               Standards Track                    [Page 31]
+
+RFC 4210                          CMP                     September 2005
+
+
+   See [CRMF] for EncryptedValue syntax.
+
+   Use of this data structure requires that the creator and intended
+   recipient be able to encrypt and decrypt, respectively.  Typically,
+   this will mean that the sender and recipient have, or are able to
+   generate, a shared secret key.
+
+   If the recipient of the PKIMessage already possesses a private key
+   usable for decryption, then the encSymmKey field MAY contain a
+   session key encrypted using the recipient's public key.
+
+5.2.3.  Status codes and Failure Information for PKI Messages
+
+   All response messages will include some status information.  The
+   following values are defined.
+
+        PKIStatus ::= INTEGER {
+            accepted               (0),
+            grantedWithMods        (1),
+            rejection              (2),
+            waiting                (3),
+            revocationWarning      (4),
+            revocationNotification (5),
+            keyUpdateWarning       (6)
+        }
+
+   Responders may use the following syntax to provide more information
+   about failure cases.
+
+        PKIFailureInfo ::= BIT STRING {
+            badAlg              (0),
+            badMessageCheck     (1),
+            badRequest          (2),
+            badTime             (3),
+            badCertId           (4),
+            badDataFormat       (5),
+            wrongAuthority      (6),
+            incorrectData       (7),
+            missingTimeStamp    (8),
+            badPOP              (9),
+            certRevoked         (10),
+            certConfirmed       (11),
+            wrongIntegrity      (12),
+            badRecipientNonce   (13),
+            timeNotAvailable    (14),
+            unacceptedPolicy    (15),
+            unacceptedExtension (16),
+            addInfoNotAvailable (17),
+
+
+
+Adams, et al.               Standards Track                    [Page 32]
+
+RFC 4210                          CMP                     September 2005
+
+
+            badSenderNonce      (18),
+            badCertTemplate     (19),
+            signerNotTrusted    (20),
+            transactionIdInUse  (21),
+            unsupportedVersion  (22),
+            notAuthorized       (23),
+            systemUnavail       (24),
+            systemFailure       (25),
+            duplicateCertReq    (26)
+        }
+
+        PKIStatusInfo ::= SEQUENCE {
+            status        PKIStatus,
+            statusString  PKIFreeText     OPTIONAL,
+            failInfo      PKIFailureInfo  OPTIONAL
+        }
+
+5.2.4.  Certificate Identification
+
+   In order to identify particular certificates, the CertId data
+   structure is used.
+
+   See [CRMF] for CertId syntax.
+
+5.2.5.  Out-of-band root CA Public Key
+
+   Each root CA must be able to publish its current public key via some
+   "out-of-band" means.  While such mechanisms are beyond the scope of
+   this document, we define data structures that can support such
+   mechanisms.
+
+   There are generally two methods available: either the CA directly
+   publishes its self-signed certificate, or this information is
+   available via the Directory (or equivalent) and the CA publishes a
+   hash of this value to allow verification of its integrity before use.
+
+        OOBCert ::= Certificate
+
+   The fields within this certificate are restricted as follows:
+
+   o  The certificate MUST be self-signed (i.e., the signature must be
+      verifiable using the SubjectPublicKeyInfo field);
+
+   o  The subject and issuer fields MUST be identical;
+
+   o  If the subject field is NULL, then both subjectAltNames and
+      issuerAltNames extensions MUST be present and have exactly the
+      same value;
+
+
+
+Adams, et al.               Standards Track                    [Page 33]
+
+RFC 4210                          CMP                     September 2005
+
+
+   o  The values of all other extensions must be suitable for a self-
+      signed certificate (e.g., key identifiers for subject and issuer
+      must be the same).
+
+        OOBCertHash ::= SEQUENCE {
+            hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
+            certId      [1] CertId                  OPTIONAL,
+            hashVal         BIT STRING
+        }
+
+   The intention of the hash value is that anyone who has securely
+   received the hash value (via the out-of-band means) can verify a
+   self-signed certificate for that CA.
+
+5.2.6.  Archive Options
+
+   Requesters may indicate that they wish the PKI to archive a private
+   key value using the PKIArchiveOptions structure.
+
+   See [CRMF] for PKIArchiveOptions syntax.
+
+5.2.7.  Publication Information
+
+   Requesters may indicate that they wish the PKI to publish a
+   certificate using the PKIPublicationInfo structure.
+
+   See [CRMF] for PKIPublicationInfo syntax.
+
+5.2.8.  Proof-of-Possession Structures
+
+   If the certification request is for a signing key pair (i.e., a
+   request for a verification certificate), then the proof-of-possession
+   of the private signing key is demonstrated through use of the
+   POPOSigningKey structure.
+
+   See Appendix C and [CRMF] for POPOSigningKey syntax, but note that
+   POPOSigningKeyInput has the following semantic stipulations in this
+   specification.
+
+        POPOSigningKeyInput ::= SEQUENCE {
+            authInfo            CHOICE {
+                sender              [0] GeneralName,
+                publicKeyMAC            PKMACValue
+            },
+            publicKey           SubjectPublicKeyInfo
+        }
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 34]
+
+RFC 4210                          CMP                     September 2005
+
+
+   On the other hand, if the certification request is for an encryption
+   key pair (i.e., a request for an encryption certificate), then the
+   proof-of-possession of the private decryption key may be demonstrated
+   in one of three ways.
+
+5.2.8.1.  Inclusion of the Private Key
+
+   By the inclusion of the private key (encrypted) in the CertRequest
+   (in the thisMessage field of POPOPrivKey (see Appendix C) or in the
+   PKIArchiveOptions control structure, depending upon whether or not
+   archival of the private key is also desired).
+
+5.2.8.2.  Indirect Method
+
+   By having the CA return not the certificate, but an encrypted
+   certificate (i.e., the certificate encrypted under a randomly-
+   generated symmetric key, and the symmetric key encrypted under the
+   public key for which the certification request is being made) -- this
+   is the "indirect" method mentioned previously in Section 4.3.2. The
+   end entity proves knowledge of the private decryption key to the CA
+   by providing the correct CertHash for this certificate in the
+   certConf message.  This demonstrates POP because the EE can only
+   compute the correct CertHash if it is able to recover the
+   certificate, and it can only recover the certificate if it is able to
+   decrypt the symmetric key using the required private key.  Clearly,
+   for this to work, the CA MUST NOT publish the certificate until the
+   certConf message arrives (when certHash is to be used to demonstrate
+   POP).  See Section 5.3.18 for further details.
+
+5.2.8.3.  Challenge-Response Protocol
+
+   By having the end entity engage in a challenge-response protocol
+   (using the messages POPODecKeyChall and POPODecKeyResp; see below)
+   between CertReqMessages and CertRepMessage -- this is the "direct"
+   method mentioned previously in Section 4.3.2.  (This method would
+   typically be used in an environment in which an RA verifies POP and
+   then makes a certification request to the CA on behalf of the end
+   entity.  In such a scenario, the CA trusts the RA to have done POP
+   correctly before the RA requests a certificate for the end entity.)
+   The complete protocol then looks as follows (note that req' does not
+   necessarily encapsulate req as a nested message):
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 35]
+
+RFC 4210                          CMP                     September 2005
+
+
+                   EE            RA            CA
+                    ---- req ---->
+                    <--- chall ---
+                    ---- resp --->
+                                  ---- req' --->
+                                  <--- rep -----
+                                  ---- conf --->
+                                  <--- ack -----
+                    <--- rep -----
+                    ---- conf --->
+                    <--- ack -----
+
+   This protocol is obviously much longer than the 3-way exchange given
+   in choice (2) above, but allows a local Registration Authority to be
+   involved and has the property that the certificate itself is not
+   actually created until the proof-of-possession is complete.  In some
+   environments, a different order of the above messages may be
+   required, such as the following (this may be determined by policy):
+
+                   EE            RA            CA
+                    ---- req ---->
+                    <--- chall ---
+                    ---- resp --->
+                                  ---- req' --->
+                                  <--- rep -----
+                    <--- rep -----
+                    ---- conf --->
+                                  ---- conf --->
+                                  <--- ack -----
+                    <--- ack -----
+
+   If the cert. request is for a key agreement key (KAK) pair, then the
+   POP can use any of the 3 ways described above for enc. key pairs,
+   with the following changes: (1) the parenthetical text of bullet 2)
+   is replaced with "(i.e., the certificate encrypted under the
+   symmetric key derived from the CA's private KAK and the public key
+   for which the certification request is being made)"; (2) the first
+   parenthetical text of the challenge field of "Challenge" below is
+   replaced with "(using PreferredSymmAlg (see Section 5.3.19.4 and
+   Appendix E.5) and a symmetric key derived from the CA's private KAK
+   and the public key for which the certification request is being
+   made)".  Alternatively, the POP can use the POPOSigningKey structure
+   given in [CRMF] (where the alg field is DHBasedMAC and the signature
+   field is the MAC) as a fourth alternative for demonstrating POP if
+   the CA already has a D-H certificate that is known to the EE.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 36]
+
+RFC 4210                          CMP                     September 2005
+
+
+   The challenge-response messages for proof-of-possession of a private
+   decryption key are specified as follows (see [MvOV97], p.404 for
+   details).  Note that this challenge-response exchange is associated
+   with the preceding cert. request message (and subsequent cert.
+   response and confirmation messages) by the transactionID used in the
+   PKIHeader and by the protection (MACing or signing) applied to the
+   PKIMessage.
+
+        POPODecKeyChallContent ::= SEQUENCE OF Challenge
+        Challenge ::= SEQUENCE {
+            owf                 AlgorithmIdentifier  OPTIONAL,
+            witness             OCTET STRING,
+            challenge           OCTET STRING
+        }
+
+   Note that the size of Rand needs to be appropriate for encryption
+   under the public key of the requester.  Given that "int" will
+   typically not be longer than 64 bits, this leaves well over 100 bytes
+   of room for the "sender" field when the modulus is 1024 bits.  If, in
+   some environment, names are so long that they cannot fit (e.g., very
+   long DNs), then whatever portion will fit should be used (as long as
+   it includes at least the common name, and as long as the receiver is
+   able to deal meaningfully with the abbreviation).
+
+        POPODecKeyRespContent ::= SEQUENCE OF INTEGER
+
+5.2.8.4.  Summary of PoP Options
+
+   The text in this section provides several options with respect to POP
+   techniques.  Using "SK" for "signing key", "EK" for "encryption key",
+   and "KAK" for "key agreement key", the techniques may be summarized
+   as follows:
+
+         RAVerified;
+         SKPOP;
+         EKPOPThisMessage;
+         KAKPOPThisMessage;
+         KAKPOPThisMessageDHMAC;
+         EKPOPEncryptedCert;
+         KAKPOPEncryptedCert;
+         EKPOPChallengeResp; and
+         KAKPOPChallengeResp.
+
+   Given this array of options, it is natural to ask how an end entity
+   can know what is supported by the CA/RA (i.e., which options it may
+   use when requesting certificates).  The following guidelines should
+   clarify this situation for EE implementers.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 37]
+
+RFC 4210                          CMP                     September 2005
+
+
+   RAVerified.  This is not an EE decision; the RA uses this if and only
+   if it has verified POP before forwarding the request on to the CA, so
+   it is not possible for the EE to choose this technique.
+
+   SKPOP.  If the EE has a signing key pair, this is the only POP method
+   specified for use in the request for a corresponding certificate.
+
+   EKPOPThisMessage and KAKPOPThisMessage.  Whether or not to give up
+   its private key to the CA/RA is an EE decision.  If the EE decides to
+   reveal its key, then these are the only POP methods available in this
+   specification to achieve this (and the key pair type will determine
+   which of these two methods to use).
+
+   KAKPOPThisMessageDHMAC.  The EE can only use this method if (1) the
+   CA has a DH certificate available for this purpose, and (2) the EE
+   already has a copy of this certificate.  If both these conditions
+   hold, then this technique is clearly supported and may be used by the
+   EE, if desired.
+
+   EKPOPEncryptedCert, KAKPOPEncryptedCert, EKPOPChallengeResp,
+   KAKPOPChallengeResp.  The EE picks one of these (in the
+   subsequentMessage field) in the request message, depending upon
+   preference and key pair type.  The EE is not doing POP at this point;
+   it is simply indicating which method it wants to use.  Therefore, if
+   the CA/RA replies with a "badPOP" error, the EE can re-request using
+   the other POP method chosen in subsequentMessage.  Note, however,
+   that this specification encourages the use of the EncryptedCert
+   choice and, furthermore, says that the challenge-response would
+   typically be used when an RA is involved and doing POP verification.
+   Thus, the EE should be able to make an intelligent decision regarding
+   which of these POP methods to choose in the request message.
+
+5.3.  Operation-Specific Data Structures
+
+5.3.1.  Initialization Request
+
+   An Initialization request message contains as the PKIBody a
+   CertReqMessages data structure, which specifies the requested
+   certificate(s).  Typically, SubjectPublicKeyInfo, KeyId, and Validity
+   are the template fields which may be supplied for each certificate
+   requested (see Appendix D profiles for further information).  This
+   message is intended to be used for entities when first initializing
+   into the PKI.
+
+   See Appendix C and [CRMF] for CertReqMessages syntax.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 38]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.2.  Initialization Response
+
+   An Initialization response message contains as the PKIBody an
+   CertRepMessage data structure, which has for each certificate
+   requested a PKIStatusInfo field, a subject certificate, and possibly
+   a private key (normally encrypted with a session key, which is itself
+   encrypted with the protocolEncrKey).
+
+   See Section 5.3.4 for CertRepMessage syntax.  Note that if the PKI
+   Message Protection is "shared secret information" (see Section
+   5.1.3), then any certificate transported in the caPubs field may be
+   directly trusted as a root CA certificate by the initiator.
+
+5.3.3.  Certification Request
+
+   A Certification request message contains as the PKIBody a
+   CertReqMessages data structure, which specifies the requested
+   certificates.  This message is intended to be used for existing PKI
+   entities who wish to obtain additional certificates.
+
+   See Appendix C and [CRMF] for CertReqMessages syntax.
+
+   Alternatively, the PKIBody MAY be a CertificationRequest (this
+   structure is fully specified by the ASN.1 structure
+   CertificationRequest given in [PKCS10]).  This structure may be
+   required for certificate requests for signing key pairs when
+   interoperation with legacy systems is desired, but its use is
+   strongly discouraged whenever not absolutely necessary.
+
+5.3.4.  Certification Response
+
+   A Certification response message contains as the PKIBody a
+   CertRepMessage data structure, which has a status value for each
+   certificate requested, and optionally has a CA public key, failure
+   information, a subject certificate, and an encrypted private key.
+
+     CertRepMessage ::= SEQUENCE {
+         caPubs          [1] SEQUENCE SIZE (1..MAX) OF Certificate
+                             OPTIONAL,
+         response            SEQUENCE OF CertResponse
+     }
+
+     CertResponse ::= SEQUENCE {
+         certReqId           INTEGER,
+         status              PKIStatusInfo,
+         certifiedKeyPair    CertifiedKeyPair    OPTIONAL,
+         rspInfo             OCTET STRING        OPTIONAL
+         -- analogous to the id-regInfo-utf8Pairs string defined
+
+
+
+Adams, et al.               Standards Track                    [Page 39]
+
+RFC 4210                          CMP                     September 2005
+
+
+         -- for regInfo in CertReqMsg [CRMF]
+     }
+
+     CertifiedKeyPair ::= SEQUENCE {
+         certOrEncCert       CertOrEncCert,
+         privateKey      [0] EncryptedValue      OPTIONAL,
+         -- see [CRMF] for comment on encoding
+         publicationInfo [1] PKIPublicationInfo  OPTIONAL
+     }
+
+     CertOrEncCert ::= CHOICE {
+         certificate     [0] Certificate,
+         encryptedCert   [1] EncryptedValue
+     }
+
+   Only one of the failInfo (in PKIStatusInfo) and certificate (in
+   CertifiedKeyPair) fields can be present in each CertResponse
+   (depending on the status).  For some status values (e.g., waiting),
+   neither of the optional fields will be present.
+
+   Given an EncryptedCert and the relevant decryption key, the
+   certificate may be obtained.  The purpose of this is to allow a CA to
+   return the value of a certificate, but with the constraint that only
+   the intended recipient can obtain the actual certificate.  The
+   benefit of this approach is that a CA may reply with a certificate
+   even in the absence of a proof that the requester is the end entity
+   that can use the relevant private key (note that the proof is not
+   obtained until the certConf message is received by the CA).  Thus,
+   the CA will not have to revoke that certificate in the event that
+   something goes wrong with the proof-of-possession (but MAY do so
+   anyway, depending upon policy).
+
+5.3.5.  Key Update Request Content
+
+   For key update requests the CertReqMessages syntax is used.
+   Typically, SubjectPublicKeyInfo, KeyId, and Validity are the template
+   fields that may be supplied for each key to be updated.  This message
+   is intended to be used to request updates to existing (non-revoked
+   and non-expired) certificates (therefore, it is sometimes referred to
+   as a "Certificate Update" operation).  An update is a replacement
+   certificate containing either a new subject public key or the current
+   subject public key (although the latter practice may not be
+   appropriate for some environments).
+
+   See Appendix C and [CRMF] for CertReqMessages syntax.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 40]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.6.  Key Update Response Content
+
+   For key update responses, the CertRepMessage syntax is used.  The
+   response is identical to the initialization response.
+
+   See Section 5.3.4 for CertRepMessage syntax.
+
+5.3.7.  Key Recovery Request Content
+
+   For key recovery requests the syntax used is identical to the
+   initialization request CertReqMessages.  Typically,
+   SubjectPublicKeyInfo and KeyId are the template fields that may be
+   used to supply a signature public key for which a certificate is
+   required (see Appendix D profiles for further information).
+
+   See Appendix C and [CRMF] for CertReqMessages syntax.  Note that if a
+   key history is required, the requester must supply a Protocol
+   Encryption Key control in the request message.
+
+5.3.8.  Key Recovery Response Content
+
+   For key recovery responses, the following syntax is used.  For some
+   status values (e.g., waiting) none of the optional fields will be
+   present.
+
+    KeyRecRepContent ::= SEQUENCE {
+        status          PKIStatusInfo,
+        newSigCert  [0] Certificate                   OPTIONAL,
+        caCerts     [1] SEQUENCE SIZE (1..MAX) OF
+                                     Certificate      OPTIONAL,
+        keyPairHist [2] SEQUENCE SIZE (1..MAX) OF
+                                     CertifiedKeyPair OPTIONAL
+    }
+
+5.3.9.  Revocation Request Content
+
+   When requesting revocation of a certificate (or several
+   certificates), the following data structure is used.  The name of the
+   requester is present in the PKIHeader structure.
+
+    RevReqContent ::= SEQUENCE OF RevDetails
+
+    RevDetails ::= SEQUENCE {
+        certDetails         CertTemplate,
+        crlEntryDetails     Extensions       OPTIONAL
+    }
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 41]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.10.  Revocation Response Content
+
+   The revocation response is the response to the above message.  If
+   produced, this is sent to the requester of the revocation.  (A
+   separate revocation announcement message MAY be sent to the subject
+   of the certificate for which revocation was requested.)
+
+     RevRepContent ::= SEQUENCE {
+         status        SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
+         revCerts  [0] SEQUENCE SIZE (1..MAX) OF CertId OPTIONAL,
+         crls      [1] SEQUENCE SIZE (1..MAX) OF CertificateList
+                       OPTIONAL
+     }
+
+5.3.11.  Cross Certification Request Content
+
+   Cross certification requests use the same syntax (CertReqMessages) as
+   normal certification requests, with the restriction that the key pair
+   MUST have been generated by the requesting CA and the private key
+   MUST NOT be sent to the responding CA.  This request MAY also be used
+   by subordinate CAs to get their certificates signed by the parent CA.
+
+   See Appendix C and [CRMF] for CertReqMessages syntax.
+
+5.3.12.  Cross Certification Response Content
+
+   Cross certification responses use the same syntax (CertRepMessage) as
+   normal certification responses, with the restriction that no
+   encrypted private key can be sent.
+
+   See Section 5.3.4 for CertRepMessage syntax.
+
+5.3.13.  CA Key Update Announcement Content
+
+   When a CA updates its own key pair, the following data structure MAY
+   be used to announce this event.
+
+    CAKeyUpdAnnContent ::= SEQUENCE {
+       oldWithNew         Certificate,
+       newWithOld         Certificate,
+       newWithNew         Certificate
+    }
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 42]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.14.  Certificate Announcement
+
+   This structure MAY be used to announce the existence of certificates.
+
+   Note that this message is intended to be used for those cases (if
+   any) where there is no pre-existing method for publication of
+   certificates; it is not intended to be used where, for example, X.500
+   is the method for publication of certificates.
+
+        CertAnnContent ::= Certificate
+
+5.3.15.  Revocation Announcement
+
+   When a CA has revoked, or is about to revoke, a particular
+   certificate, it MAY issue an announcement of this (possibly upcoming)
+   event.
+
+        RevAnnContent ::= SEQUENCE {
+            status              PKIStatus,
+            certId              CertId,
+            willBeRevokedAt     GeneralizedTime,
+            badSinceDate        GeneralizedTime,
+            crlDetails          Extensions  OPTIONAL
+        }
+
+   A CA MAY use such an announcement to warn (or notify) a subject that
+   its certificate is about to be (or has been) revoked.  This would
+   typically be used where the request for revocation did not come from
+   the subject concerned.
+
+   The willBeRevokedAt field contains the time at which a new entry will
+   be added to the relevant CRLs.
+
+5.3.16.  CRL Announcement
+
+   When a CA issues a new CRL (or set of CRLs) the following data
+   structure MAY be used to announce this event.
+
+        CRLAnnContent ::= SEQUENCE OF CertificateList
+
+5.3.17.  PKI Confirmation Content
+
+   This data structure is used in the protocol exchange as the final
+   PKIMessage.  Its content is the same in all cases -- actually there
+   is no content since the PKIHeader carries all the required
+   information.
+
+        PKIConfirmContent ::= NULL
+
+
+
+Adams, et al.               Standards Track                    [Page 43]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Use of this message for certificate confirmation is NOT RECOMMENDED;
+   certConf SHOULD be used instead.  Upon receiving a PKIConfirm for a
+   certificate response, the recipient MAY treat it as a certConf with
+   all certificates being accepted.
+
+5.3.18.  Certificate Confirmation Content
+
+   This data structure is used by the client to send a confirmation to
+   the CA/RA to accept or reject certificates.
+
+         CertConfirmContent ::= SEQUENCE OF CertStatus
+
+         CertStatus ::= SEQUENCE {
+            certHash    OCTET STRING,
+            certReqId   INTEGER,
+            statusInfo  PKIStatusInfo OPTIONAL
+         }
+
+   For any particular CertStatus, omission of the statusInfo field
+   indicates ACCEPTANCE of the specified certificate.  Alternatively,
+   explicit status details (with respect to acceptance or rejection) MAY
+   be provided in the statusInfo field, perhaps for auditing purposes at
+   the CA/RA.
+
+   Within CertConfirmContent, omission of a CertStatus structure
+   corresponding to a certificate supplied in the previous response
+   message indicates REJECTION of the certificate.  Thus, an empty
+   CertConfirmContent (a zero-length SEQUENCE) MAY be used to indicate
+   rejection of all supplied certificates.  See Section 5.2.8, item (2),
+   for a discussion of the certHash field with respect to proof-of-
+   possession.
+
+5.3.19.  PKI General Message Content
+
+     InfoTypeAndValue ::= SEQUENCE {
+         infoType               OBJECT IDENTIFIER,
+         infoValue              ANY DEFINED BY infoType  OPTIONAL
+     }
+     -- where {id-it} = {id-pkix 4} = {1 3 6 1 5 5 7 4}
+     GenMsgContent ::= SEQUENCE OF InfoTypeAndValue
+
+5.3.19.1.  CA Protocol Encryption Certificate
+
+   This MAY be used by the EE to get a certificate from the CA to use to
+   protect sensitive information during the protocol.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 44]
+
+RFC 4210                          CMP                     September 2005
+
+
+      GenMsg:    {id-it 1}, < absent >
+      GenRep:    {id-it 1}, Certificate | < absent >
+
+   EEs MUST ensure that the correct certificate is used for this
+   purpose.
+
+5.3.19.2.  Signing Key Pair Types
+
+   This MAY be used by the EE to get the list of signature algorithms
+   (e.g., RSA, DSA) whose subject public key values the CA is willing to
+   certify.  Note that for the purposes of this exchange, rsaEncryption
+   and rsaWithSHA1, for example, are considered to be equivalent; the
+   question being asked is, "Is the CA willing to certify an RSA public
+   key?"
+
+      GenMsg:    {id-it 2}, < absent >
+      GenRep:    {id-it 2}, SEQUENCE SIZE (1..MAX) OF
+                            AlgorithmIdentifier
+
+5.3.19.3.  Encryption/Key Agreement Key Pair Types
+
+   This MAY be used by the client to get the list of encryption/key
+   agreement algorithms whose subject public key values the CA is
+   willing to certify.
+
+      GenMsg:    {id-it 3}, < absent >
+      GenRep:    {id-it 3}, SEQUENCE SIZE (1..MAX) OF
+                            AlgorithmIdentifier
+
+5.3.19.4.  Preferred Symmetric Algorithm
+
+   This MAY be used by the client to get the CA-preferred symmetric
+   encryption algorithm for any confidential information that needs to
+   be exchanged between the EE and the CA (for example, if the EE wants
+   to send its private decryption key to the CA for archival purposes).
+
+      GenMsg:    {id-it 4}, < absent >
+      GenRep:    {id-it 4}, AlgorithmIdentifier
+
+5.3.19.5.  Updated CA Key Pair
+
+   This MAY be used by the CA to announce a CA key update event.
+
+      GenMsg:    {id-it 5}, CAKeyUpdAnnContent
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 45]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.19.6.  CRL
+
+   This MAY be used by the client to get a copy of the latest CRL.
+
+      GenMsg:    {id-it 6}, < absent >
+      GenRep:    {id-it 6}, CertificateList
+
+5.3.19.7.  Unsupported Object Identifiers
+
+   This is used by the server to return a list of object identifiers
+   that it does not recognize or support from the list submitted by the
+   client.
+
+      GenRep:    {id-it 7}, SEQUENCE SIZE (1..MAX) OF OBJECT IDENTIFIER
+
+5.3.19.8.  Key Pair Parameters
+
+   This MAY be used by the EE to request the domain parameters to use
+   for generating the key pair for certain public-key algorithms.  It
+   can be used, for example, to request the appropriate P, Q, and G to
+   generate the DH/DSA key, or to request a set of well-known elliptic
+   curves.
+
+      GenMsg:    {id-it 10}, OBJECT IDENTIFIER -- (Algorithm object-id)
+      GenRep:    {id-it 11}, AlgorithmIdentifier | < absent >
+
+   An absent infoValue in the GenRep indicates that the algorithm
+   specified in GenMsg is not supported.
+
+   EEs MUST ensure that the parameters are acceptable to it and that the
+   GenRep message is authenticated (to avoid substitution attacks).
+
+5.3.19.9.  Revocation Passphrase
+
+   This MAY be used by the EE to send a passphrase to a CA/RA for the
+   purpose of authenticating a later revocation request (in the case
+   that the appropriate signing private key is no longer available to
+   authenticate the request).  See Appendix B for further details on the
+   use of this mechanism.
+
+      GenMsg:    {id-it 12}, EncryptedValue
+      GenRep:    {id-it 12}, < absent >
+
+5.3.19.10.  ImplicitConfirm
+
+   See Section 5.1.1.1 for the definition and use of {id-it 13}.
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 46]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.19.11.  ConfirmWaitTime
+
+   See Section 5.1.1.2 for the definition and use of {id-it 14}.
+
+5.3.19.12 Original PKIMessage
+
+   See Section 5.1.3 for the definition and use of {id-it 15}.
+
+5.3.19.13.  Supported Language Tags
+
+   This MAY be used to determine the appropriate language tag to use in
+   subsequent messages.  The sender sends its list of supported
+   languages (in order, most preferred to least); the receiver returns
+   the one it wishes to use.  (Note: each UTF8String MUST include a
+   language tag.)  If none of the offered tags are supported, an error
+   MUST be returned.
+
+      GenMsg:    {id-it 16}, SEQUENCE SIZE (1..MAX) OF UTF8String
+      GenRep:    {id-it 16}, SEQUENCE SIZE (1) OF UTF8String
+
+5.3.20.  PKI General Response Content
+
+      GenRepContent ::= SEQUENCE OF InfoTypeAndValue
+
+   Examples of GenReps that MAY be supported include those listed in the
+   subsections of Section 5.3.19.
+
+5.3.21.  Error Message Content
+
+   This data structure MAY be used by EE, CA, or RA to convey error
+   info.
+
+    ErrorMsgContent ::= SEQUENCE {
+        pKIStatusInfo          PKIStatusInfo,
+        errorCode              INTEGER           OPTIONAL,
+        errorDetails           PKIFreeText       OPTIONAL
+    }
+
+   This message MAY be generated at any time during a PKI transaction.
+   If the client sends this request, the server MUST respond with a
+   PKIConfirm response, or another ErrorMsg if any part of the header is
+   not valid.  Both sides MUST treat this message as the end of the
+   transaction (if a transaction is in progress).
+
+   If protection is desired on the message, the client MUST protect it
+   using the same technique (i.e., signature or MAC) as the starting
+   message of the transaction.  The CA MUST always sign it with a
+   signature key.
+
+
+
+Adams, et al.               Standards Track                    [Page 47]
+
+RFC 4210                          CMP                     September 2005
+
+
+5.3.22.  Polling Request and Response
+
+   This pair of messages is intended to handle scenarios in which the
+   client needs to poll the server in order to determine the status of
+   an outstanding ir, cr, or kur transaction (i.e., when the "waiting"
+   PKIStatus has been received).
+
+    PollReqContent ::= SEQUENCE OF SEQUENCE {
+        certReqId    INTEGER }
+
+    PollRepContent ::= SEQUENCE OF SEQUENCE {
+        certReqId    INTEGER,
+        checkAfter   INTEGER,  -- time in seconds
+        reason       PKIFreeText OPTIONAL }
+
+   The following clauses describe when polling messages are used, and
+   how they are used.  It is assumed that multiple certConf messages can
+   be sent during transactions.  There will be one sent in response to
+   each ip, cp, or kup that contains a CertStatus for an issued
+   certificate.
+
+   1.  In response to an ip, cp, or kup message, an EE will send a
+       certConf for all issued certificates and, following the ack, a
+       pollReq for all pending certificates.
+
+   2.  In response to a pollReq, a CA/RA will return an ip, cp, or kup
+       if one or more of the pending certificates is ready; otherwise,
+       it will return a pollRep.
+
+   3.  If the EE receives a pollRep, it will wait for at least as long
+       as the checkAfter value before sending another pollReq.
+
+   4.  If an ip, cp, or kup is received in response to a pollReq, then
+       it will be treated in the same way as the initial response.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 48]
+
+RFC 4210                          CMP                     September 2005
+
+
+                               START
+                                 |
+                                 v
+                              Send ir
+                                 | ip
+                                 v
+                            Check status
+                            of returned <------------------------+
+                               certs                             |
+                                 |                               |
+       +------------------------>|<------------------+           |
+       |                         |                   |           |
+       |        (issued)         v       (waiting)   |           |
+     Add to <----------- Check CertResponse ------> Add to       |
+    conf list           for each certificate      pending list   |
+                                 /                               |
+                                /                                |
+                   (conf list) /     (empty conf list)           |
+                              /                     ip           |
+                             /                 +----------------+
+      (empty pending list)  /                  |    pRep
+        END <---- Send certConf         Send pReq------------>Wait
+                         |                 ^   ^               |
+                         |                 |   |               |
+                         +-----------------+   +---------------+
+                            (pending list)
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 49]
+
+RFC 4210                          CMP                     September 2005
+
+
+   In the following exchange, the end entity is enrolling for two
+   certificates in one request.
+
+    Step  End Entity                       PKI
+    --------------------------------------------------------------------
+    1   Format ir
+    2                    -> ir      ->
+    3                                    Handle ir
+    4                                    Manual intervention is
+                                         required for both certs.
+    5                    <- ip      <-
+    6   Process ip
+    7   Format pReq
+    8                    -> pReq     ->
+    9                                    Check status of cert requests
+    10                                   Certificates not ready
+    11                                   Format pRep
+    12                   <- pRep     <-
+    13  Wait
+    14  Format pReq
+    15                   -> pReq     ->
+    16                                   Check status of cert requests
+    17                                   One certificate is ready
+    18                                   Format ip
+    19                   <- ip       <-
+    20  Handle ip
+    21  Format certConf
+    22                   -> certConf ->
+    23                                   Handle certConf
+    24                                   Format ack
+    25                   <- pkiConf   <-
+    26  Format pReq
+    27                   -> pReq     ->
+    28                                   Check status of certificate
+    29                                   Certificate is ready
+    30                                   Format ip
+    31                   <- ip       <-
+    31  Handle ip
+    32  Format certConf
+    33                   -> certConf ->
+    34                                   Handle certConf
+    35                                   Format ack
+    36                   <- pkiConf  <-
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 50]
+
+RFC 4210                          CMP                     September 2005
+
+
+6.  Mandatory PKI Management Functions
+
+   Some of the PKI management functions outlined in Section 3.1 above
+   are described in this section.
+
+   This section deals with functions that are "mandatory" in the sense
+   that all end entity and CA/RA implementations MUST be able to provide
+   the functionality described.  This part is effectively the profile of
+   the PKI management functionality that MUST be supported.  Note,
+   however, that the management functions described in this section do
+   not need to be accomplished using the PKI messages defined in Section
+   5 if alternate means are suitable for a given environment (see
+   Appendix D for profiles of the PKIMessages that MUST be supported).
+
+6.1.  Root CA Initialization
+
+   [See Section 3.1.1.2 for this document's definition of "root CA".]
+
+   A newly created root CA must produce a "self-certificate", which is a
+   Certificate structure with the profile defined for the "newWithNew"
+   certificate issued following a root CA key update.
+
+   In order to make the CA's self certificate useful to end entities
+   that do not acquire the self certificate via "out-of-band" means, the
+   CA must also produce a fingerprint for its certificate.  End entities
+   that acquire this fingerprint securely via some "out-of-band" means
+   can then verify the CA's self-certificate and, hence, the other
+   attributes contained therein.
+
+   The data structure used to carry the fingerprint is the OOBCertHash.
+
+6.2.  Root CA Key Update
+
+   CA keys (as all other keys) have a finite lifetime and will have to
+   be updated on a periodic basis.  The certificates NewWithNew,
+   NewWithOld, and OldWithNew (see Section 4.4.1) MAY be issued by the
+   CA to aid existing end entities who hold the current self-signed CA
+   certificate (OldWithOld) to transition securely to the new self-
+   signed CA certificate (NewWithNew), and to aid new end entities who
+   will hold NewWithNew to acquire OldWithOld securely for verification
+   of existing data.
+
+6.3.  Subordinate CA Initialization
+
+   [See Section 3.1.1.2 for this document's definition of "subordinate
+   CA".]
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 51]
+
+RFC 4210                          CMP                     September 2005
+
+
+   From the perspective of PKI management protocols, the initialization
+   of a subordinate CA is the same as the initialization of an end
+   entity.  The only difference is that the subordinate CA must also
+   produce an initial revocation list.
+
+6.4.  CRL production
+
+   Before issuing any certificates, a newly established CA (which issues
+   CRLs) must produce "empty" versions of each CRL which are to be
+   periodically produced.
+
+6.5.  PKI Information Request
+
+   When a PKI entity (CA, RA, or EE) wishes to acquire information about
+   the current status of a CA, it MAY send that CA a request for such
+   information.
+
+   The CA MUST respond to the request by providing (at least) all of the
+   information requested by the requester.  If some of the information
+   cannot be provided, then an error must be conveyed to the requester.
+
+   If PKIMessages are used to request and supply this PKI information,
+   then the request MUST be the GenMsg message, the response MUST be the
+   GenRep message, and the error MUST be the Error message.  These
+   messages are protected using a MAC based on shared secret information
+   (i.e., PasswordBasedMAC) or using any other authenticated means (if
+   the end entity has an existing certificate).
+
+6.6.  Cross Certification
+
+   The requester CA is the CA that will become the subject of the
+   cross-certificate; the responder CA will become the issuer of the
+   cross-certificate.
+
+   The requester CA must be "up and running" before initiating the
+   cross-certification operation.
+
+6.6.1.  One-Way Request-Response Scheme:
+
+   The cross-certification scheme is essentially a one way operation;
+   that is, when successful, this operation results in the creation of
+   one new cross-certificate.  If the requirement is that cross-
+   certificates be created in "both directions", then each CA, in turn,
+   must initiate a cross-certification operation (or use another
+   scheme).
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 52]
+
+RFC 4210                          CMP                     September 2005
+
+
+   This scheme is suitable where the two CAs in question can already
+   verify each other's signatures (they have some common points of
+   trust) or where there is an out-of-band verification of the origin of
+   the certification request.
+
+   Detailed Description:
+
+   Cross certification is initiated at one CA known as the responder.
+   The CA administrator for the responder identifies the CA it wants to
+   cross certify and the responder CA equipment generates an
+   authorization code.  The responder CA administrator passes this
+   authorization code by out-of-band means to the requester CA
+   administrator.  The requester CA administrator enters the
+   authorization code at the requester CA in order to initiate the on-
+   line exchange.
+
+   The authorization code is used for authentication and integrity
+   purposes.  This is done by generating a symmetric key based on the
+   authorization code and using the symmetric key for generating Message
+   Authentication Codes (MACs) on all messages exchanged.
+   (Authentication may alternatively be done using signatures instead of
+   MACs, if the CAs are able to retrieve and validate the required
+   public keys by some means, such as an out-of-band hash comparison.)
+
+   The requester CA initiates the exchange by generating a cross-
+   certification request (ccr) with a fresh random number (requester
+   random number).  The requester CA then sends the ccr message to the
+   responder CA.  The fields in this message are protected from
+   modification with a MAC based on the authorization code.
+
+   Upon receipt of the ccr message, the responder CA validates the
+   message and the MAC, saves the requester random number, and generates
+   its own random number (responder random number).  It then generates
+   (and archives, if desired) a new requester certificate that contains
+   the requester CA public key and is signed with the responder CA
+   signature private key.  The responder CA responds with the cross
+   certification response (ccp) message.  The fields in this message are
+   protected from modification with a MAC based on the authorization
+   code.
+
+   Upon receipt of the ccp message, the requester CA validates the
+   message (including the received random numbers) and the MAC.  The
+   requester CA responds with the certConf message.  The fields in this
+   message are protected from modification with a MAC based on the
+   authorization code.  The requester CA MAY write the requester
+   certificate to the Repository as an aid to later certificate path
+   construction.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 53]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Upon receipt of the certConf message, the responder CA validates the
+   message and the MAC, and sends back an acknowledgement using the
+   PKIConfirm message.  It MAY also publish the requester certificate as
+   an aid to later path construction.
+
+   Notes:
+
+   1.  The ccr message must contain a "complete" certification request;
+       that is, all fields except the serial number (including, e.g., a
+       BasicConstraints extension) must be specified by the requester
+       CA.
+
+   2.  The ccp message SHOULD contain the verification certificate of
+       the responder CA; if present, the requester CA must then verify
+       this certificate (for example, via the "out-of-band" mechanism).
+
+   (A simpler, non-interactive model of cross-certification may also be
+   envisioned, in which the issuing CA acquires the subject CA's public
+   key from some repository, verifies it via some out-of-band mechanism,
+   and creates and publishes the cross-certificate without the subject
+   CA's explicit involvement.  This model may be perfectly legitimate
+   for many environments, but since it does not require any protocol
+   message exchanges, its detailed description is outside the scope of
+   this specification.)
+
+6.7.  End Entity Initialization
+
+   As with CAs, end entities must be initialized.  Initialization of end
+   entities requires at least two steps:
+
+   o  acquisition of PKI information
+
+   o  out-of-band verification of one root-CA public key
+
+   (other possible steps include the retrieval of trust condition
+   information and/or out-of-band verification of other CA public keys).
+
+6.7.1.  Acquisition of PKI Information
+
+   The information REQUIRED is:
+
+   o  the current root-CA public key
+
+   o  (if the certifying CA is not a root-CA) the certification path
+      from the root CA to the certifying CA together with appropriate
+      revocation lists
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 54]
+
+RFC 4210                          CMP                     September 2005
+
+
+   o  the algorithms and algorithm parameters that the certifying CA
+      supports for each relevant usage
+
+   Additional information could be required (e.g., supported extensions
+   or CA policy information) in order to produce a certification request
+   that will be successful.  However, for simplicity we do not mandate
+   that the end entity acquires this information via the PKI messages.
+   The end result is simply that some certification requests may fail
+   (e.g., if the end entity wants to generate its own encryption key,
+   but the CA doesn't allow that).
+
+   The required information MAY be acquired as described in Section 6.5.
+
+6.7.2.  Out-of-Band Verification of Root-CA Key
+
+   An end entity must securely possess the public key of its root CA.
+   One method to achieve this is to provide the end entity with the CA's
+   self-certificate fingerprint via some secure "out-of-band" means.
+   The end entity can then securely use the CA's self-certificate.
+
+   See Section 6.1 for further details.
+
+6.8.  Certificate Request
+
+   An initialized end entity MAY request an additional certificate at
+   any time (for any purpose).  This request will be made using the
+   certification request (cr) message.  If the end entity already
+   possesses a signing key pair (with a corresponding verification
+   certificate), then this cr message will typically be protected by the
+   entity's digital signature.  The CA returns the new certificate (if
+   the request is successful) in a CertRepMessage.
+
+6.9.  Key Update
+
+   When a key pair is due to expire, the relevant end entity MAY request
+   a key update; that is, it MAY request that the CA issue a new
+   certificate for a new key pair (or, in certain circumstances, a new
+   certificate for the same key pair).  The request is made using a key
+   update request (kur) message (referred to, in some environments, as a
+   "Certificate Update" operation).  If the end entity already possesses
+   a signing key pair (with a corresponding verification certificate),
+   then this message will typically be protected by the entity's digital
+   signature.  The CA returns the new certificate (if the request is
+   successful) in a key update response (kup) message, which is
+   syntactically identical to a CertRepMessage.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 55]
+
+RFC 4210                          CMP                     September 2005
+
+
+7.  Version Negotiation
+
+   This section defines the version negotiation used to support older
+   protocols between client and servers.
+
+   If a client knows the protocol version(s) supported by the server
+   (e.g., from a previous PKIMessage exchange or via some out-of-band
+   means), then it MUST send a PKIMessage with the highest version
+   supported by both it and the server.  If a client does not know what
+   version(s) the server supports, then it MUST send a PKIMessage using
+   the highest version it supports.
+
+   If a server receives a message with a version that it supports, then
+   the version of the response message MUST be the same as the received
+   version.  If a server receives a message with a version higher or
+   lower than it supports, then it MUST send back an ErrorMsg with the
+   unsupportedVersion bit set (in the failureInfo field of the
+   pKIStatusInfo).  If the received version is higher than the highest
+   supported version, then the version in the error message MUST be the
+   highest version the server supports; if the received version is lower
+   than the lowest supported version then the version in the error
+   message MUST be the lowest version the server supports.
+
+   If a client gets back an ErrorMsgContent with the unsupportedVersion
+   bit set and a version it supports, then it MAY retry the request with
+   that version.
+
+7.1.  Supporting RFC 2510 Implementations
+
+   RFC 2510 did not specify the behaviour of implementations receiving
+   versions they did not understand since there was only one version in
+   existence.  With the introduction of the present revision of the
+   specification, the following versioning behaviour is recommended.
+
+7.1.1.  Clients Talking to RFC 2510 Servers
+
+   If, after sending a cmp2000 message, a client receives an
+   ErrorMsgContent with a version of cmp1999, then it MUST abort the
+   current transaction.  It MAY subsequently retry the transaction using
+   version cmp1999 messages.
+
+   If a client receives a non-error PKIMessage with a version of
+   cmp1999, then it MAY decide to continue the transaction (if the
+   transaction hasn't finished) using RFC 2510 semantics.  If it does
+   not choose to do so and the transaction is not finished, then it MUST
+   abort the transaction and send an ErrorMsgContent with a version of
+   cmp1999.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 56]
+
+RFC 4210                          CMP                     September 2005
+
+
+7.1.2.  Servers Receiving Version cmp1999 PKIMessages
+
+   If a server receives a version cmp1999 message it MAY revert to RFC
+   2510 behaviour and respond with version cmp1999 messages.  If it does
+   not choose to do so, then it MUST send back an ErrorMsgContent as
+   described above in Section 7.
+
+8.  Security Considerations
+
+8.1.  Proof-Of-Possession with a Decryption Key
+
+   Some cryptographic considerations are worth explicitly spelling out.
+   In the protocols specified above, when an end entity is required to
+   prove possession of a decryption key, it is effectively challenged to
+   decrypt something (its own certificate).  This scheme (and many
+   others!) could be vulnerable to an attack if the possessor of the
+   decryption key in question could be fooled into decrypting an
+   arbitrary challenge and returning the cleartext to an attacker.
+   Although in this specification a number of other failures in security
+   are required in order for this attack to succeed, it is conceivable
+   that some future services (e.g., notary, trusted time) could
+   potentially be vulnerable to such attacks.  For this reason, we re-
+   iterate the general rule that implementations should be very careful
+   about decrypting arbitrary "ciphertext" and revealing recovered
+   "plaintext" since such a practice can lead to serious security
+   vulnerabilities.
+
+8.2.  Proof-Of-Possession by Exposing the Private Key
+
+   Note also that exposing a private key to the CA/RA as a proof-of-
+   possession technique can carry some security risks (depending upon
+   whether or not the CA/RA can be trusted to handle such material
+   appropriately).  Implementers are advised to:
+
+      Exercise caution in selecting and using this particular POP
+      mechanism
+
+      When appropriate, have the user of the application explicitly
+      state that they are willing to trust the CA/RA to have a copy of
+      their private key before proceeding to reveal the private key.
+
+8.3.  Attack Against Diffie-Hellman Key Exchange
+
+   A small subgroup attack during a Diffie-Hellman key exchange may be
+   carried out as follows.  A malicious end entity may deliberately
+   choose D-H parameters that enable him/her to derive (a significant
+   number of bits of) the D-H private key of the CA during a key
+   archival or key recovery operation.  Armed with this knowledge, the
+
+
+
+Adams, et al.               Standards Track                    [Page 57]
+
+RFC 4210                          CMP                     September 2005
+
+
+   EE would then be able to retrieve the decryption private key of
+   another unsuspecting end entity, EE2, during EE2's legitimate key
+   archival or key recovery operation with that CA.  In order to avoid
+   the possibility of such an attack, two courses of action are
+   available.  (1) The CA may generate a fresh D-H key pair to be used
+   as a protocol encryption key pair for each EE with which it
+
+   interacts.  (2) The CA may enter into a key validation protocol (not
+   specified in this document) with each requesting end entity to ensure
+   that the EE's protocol encryption key pair will not facilitate this
+   attack.  Option (1) is clearly simpler (requiring no extra protocol
+   exchanges from either party) and is therefore RECOMMENDED.
+
+9.  IANA Considerations
+
+   The PKI General Message types are identified by object identifiers
+   (OIDs).  The OIDs for the PKI General Message types defined in this
+   document were assigned from an arc delegated by the IANA to the PKIX
+   Working Group.
+
+   The cryptographic algorithms referred to in this document are
+   identified by object identifiers (OIDs).  The OIDs for cryptographic
+   algorithms were assigned from several arcs owned by various
+   organizations, including RSA Security, Entrust Technologies, IANA and
+   IETF.
+
+   Should additional encryption algorithms be introduced, the advocates
+   for such algorithms are expected to assign the necessary OIDs from
+   their own arcs.
+
+   No further action by the IANA is necessary for this document or any
+   anticipated updates.
+
+Normative References
+
+   [X509]       International Organization for Standardization and
+                International Telecommunications Union, "Information
+                technology - Open Systems Interconnection - The
+                Directory:  Public-key and attribute certificate
+                frameworks", ISO Standard 9594-8:2001, ITU-T
+                Recommendation X.509, March 2000.
+
+   [MvOV97]     Menezes, A., van Oorschot, P. and S. Vanstone, "Handbook
+                of Applied Cryptography", CRC Press ISBN 0-8493-8523-7,
+                1996.
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 58]
+
+RFC 4210                          CMP                     September 2005
+
+
+   [RFC2104]    Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:
+                Keyed-Hashing for Message Authentication", RFC 2104,
+                February 1997.
+
+   [RFC2119]    Bradner, S., "Key words for use in RFCs to Indicate
+                Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RFC2202]    Cheng, P. and R. Glenn, "Test Cases for HMAC-MD5 and
+                HMAC-SHA-1", RFC 2202, September 1997.
+
+   [RFC3629]    Yergeau, F., "UTF-8, a transformation format of ISO
+                10646", STD 63, RFC 3629, November 2003.
+
+   [RFC2482]    Whistler, K. and G. Adams, "Language Tagging in Unicode
+                Plain Text", RFC 2482, January 1999.
+
+   [CRMF]       Schaad, J., "Internet X.509 Public Key Infrastructure
+                Certificate Request Message Format (CRMF)", RFC 4211,
+                September 2005.
+
+   [RFC3066]    Alvestrand, H., "Tags for the Identification of
+                Languages", BCP 47, RFC 3066, January 2001.
+
+Informative References
+
+   [CMPtrans]   Kapoor, A., Tschalar, R. and T. Kause, "Internet X.509
+                Public Key Infrastructure -- Transport Protocols for
+                CMP", Work in Progress.  2004.
+
+   [PKCS7]      RSA Laboratories, "The Public-Key Cryptography Standards
+                - Cryptographic Message Syntax Standard.  Version 1.5",
+                PKCS 7, November 1993.
+
+   [PKCS10]     Nystrom, M., and B. Kaliski, "The Public-Key
+                Cryptography Standards - Certification Request Syntax
+                Standard, Version 1.7", RFC 2986, May 2000.
+
+   [PKCS11]     RSA Laboratories, "The Public-Key Cryptography Standards
+                - Cryptographic Token Interface Standard.  Version
+                2.10", PKCS 11, December 1999.
+
+   [RFC1847]    Galvin, J., Murphy, S., Crocker, S., and N. Freed,
+                "Security Multiparts for MIME: Multipart/Signed and
+                Multipart/Encrypted", RFC 1847, October 1995.
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 59]
+
+RFC 4210                          CMP                     September 2005
+
+
+   [RFC2559]    Boeyen, S., Howes, T. and P. Richard, "Internet X.509
+                Public Key Infrastructure Operational Protocols -
+                LDAPv2", RFC 2559, April 1999.
+
+   [RFC2585]    Housley, R. and P. Hoffman, "Internet X.509 Public Key
+                Infrastructure Operational Protocols: FTP and HTTP", RFC
+                2585, May 1999.
+
+   [FIPS-180]   National Institute of Standards and Technology, "Secure
+                Hash Standard", FIPS PUB 180-1, May 1994.
+
+   [FIPS-186]   National Institute of Standards and Technology, "Digital
+                Signature Standard", FIPS PUB 186, May 1994.
+
+   [ANSI-X9.42] American National Standards Institute, "Public Key
+                Cryptography for The Financial Services Industry:
+                Agreement of Symmetric Keys Using Discrete Logarithm
+                Cryptography", ANSI X9.42, February 2000.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 60]
+
+RFC 4210                          CMP                     September 2005
+
+
+Appendix A.  Reasons for the Presence of RAs
+
+   The reasons that justify the presence of an RA can be split into
+   those that are due to technical factors and those which are
+   organizational in nature.  Technical reasons include the following.
+
+   o  If hardware tokens are in use, then not all end entities will have
+      the equipment needed to initialize these; the RA equipment can
+      include the necessary functionality (this may also be a matter of
+      policy).
+
+   o  Some end entities may not have the capability to publish
+      certificates; again, the RA may be suitably placed for this.
+
+   o  The RA will be able to issue signed revocation requests on behalf
+      of end entities associated with it, whereas the end entity may not
+      be able to do this (if the key pair is completely lost).
+
+   Some of the organizational reasons that argue for the presence of an
+   RA are the following.
+
+   o  It may be more cost effective to concentrate functionality in the
+      RA equipment than to supply functionality to all end entities
+      (especially if special token initialization equipment is to be
+      used).
+
+   o  Establishing RAs within an organization can reduce the number of
+      CAs required, which is sometimes desirable.
+
+   o  RAs may be better placed to identify people with their
+      "electronic" names, especially if the CA is physically remote from
+      the end entity.
+
+   o  For many applications, there will already be in place some
+      administrative structure so that candidates for the role of RA are
+      easy to find (which may not be true of the CA).
+
+Appendix B.  The Use of Revocation Passphrase
+
+   A revocation request must incorporate suitable security mechanisms,
+   including proper authentication, in order to reduce the probability
+   of successful denial-of-service attacks.  A digital signature on the
+   request -- MANDATORY to support within this specification if
+   revocation requests are supported -- can provide the authentication
+   required, but there are circumstances under which an alternative
+   mechanism may be desirable (e.g., when the private key is no longer
+   accessible and the entity wishes to request a revocation prior to
+   re-certification of another key pair).  In order to accommodate such
+
+
+
+Adams, et al.               Standards Track                    [Page 61]
+
+RFC 4210                          CMP                     September 2005
+
+
+   circumstances, a PasswordBasedMAC on the request is also MANDATORY to
+   support within this specification (subject to local security policy
+   for a given environment) if revocation requests are supported and if
+   shared secret information can be established between the requester
+   and the responder prior to the need for revocation.
+
+   A mechanism that has seen use in some environments is "revocation
+   passphrase", in which a value of sufficient entropy (i.e., a
+   relatively long passphrase rather than a short password) is shared
+   between (only) the entity and the CA/RA at some point prior to
+   revocation; this value is later used to authenticate the revocation
+   request.
+
+   In this specification, the following technique to establish shared
+   secret information (i.e., a revocation passphrase) is OPTIONAL to
+   support.  Its precise use in CMP messages is as follows.
+
+   o  The OID and value specified in Section 5.3.19.9 MAY be sent in a
+      GenMsg message at any time, or MAY be sent in the generalInfo
+      field of the PKIHeader of any PKIMessage at any time.  (In
+      particular, the EncryptedValue may be sent in the header of the
+      certConf message that confirms acceptance of certificates
+      requested in an initialization request or certificate request
+      message.)  This conveys a revocation passphrase chosen by the
+      entity (i.e., the decrypted bytes of the encValue field) to the
+      relevant CA/RA; furthermore, the transfer is accomplished with
+      appropriate confidentiality characteristics (because the
+      passphrase is encrypted under the CA/RA's protocolEncryptionKey).
+
+   o  If a CA/RA receives the revocation passphrase (OID and value
+      specified in Section 5.3.19.9) in a GenMsg, it MUST construct and
+      send a GenRep message that includes the OID (with absent value)
+      specified in Section 5.3.19.9. If the CA/RA receives the
+      revocation passphrase in the generalInfo field of a PKIHeader of
+      any PKIMessage, it MUST include the OID (with absent value) in the
+      generalInfo field of the PKIHeader of the corresponding response
+      PKIMessage.  If the CA/RA is unable to return the appropriate
+      response message for any reason, it MUST send an error message
+      with a status of "rejection" and, optionally, a failInfo reason
+      set.
+
+   o  The valueHint field of EncryptedValue MAY contain a key identifier
+      (chosen by the entity, along with the passphrase itself) to assist
+      in later retrieval of the correct passphrase (e.g., when the
+      revocation request is constructed by the entity and received by
+      the CA/RA).
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 62]
+
+RFC 4210                          CMP                     September 2005
+
+
+   o  The revocation request message is protected by a PasswordBasedMAC,
+      with the revocation passphrase as the key.  If appropriate, the
+      senderKID field in the PKIHeader MAY contain the value previously
+      transmitted in valueHint.
+
+   Using the technique specified above, the revocation passphrase may be
+   initially established and updated at any time without requiring extra
+   messages or out-of-band exchanges.  For example, the revocation
+   request message itself (protected and authenticated through a MAC
+   that uses the revocation passphrase as a key) may contain, in the
+   PKIHeader, a new revocation passphrase to be used for authenticating
+   future revocation requests for any of the entity's other
+   certificates.  In some environments this may be preferable to
+   mechanisms that reveal the passphrase in the revocation request
+   message, since this can allow a denial-of-service attack in which the
+   revealed passphrase is used by an unauthorized third party to
+   authenticate revocation requests on the entity's other certificates.
+   However, because the passphrase is not revealed in the request
+   message, there is no requirement that the passphrase must always be
+   updated when a revocation request is made (that is, the same
+   passphrase MAY be used by an entity to authenticate revocation
+   requests for different certificates at different times).
+
+   Furthermore, the above technique can provide strong cryptographic
+   protection over the entire revocation request message even when a
+   digital signature is not used.  Techniques that do authentication of
+   the revocation request by simply revealing the revocation passphrase
+   typically do not provide cryptographic protection over the fields of
+   the request message (so that a request for revocation of one
+   certificate may be modified by an unauthorized third party to a
+   request for revocation of another certificate for that entity).
+
+Appendix C.  Request Message Behavioral Clarifications
+
+   In the case of updates to [CRMF], which cause interpretation or
+   interoperability issues, [CRMF] SHALL be the normative document.
+
+   The following definitions are from [CRMF].  They are included here in
+   order to codify behavioral clarifications to that request message;
+   otherwise, all syntax and semantics are identical to [CRMF].
+
+   CertRequest ::= SEQUENCE {
+       certReqId     INTEGER,
+       certTemplate  CertTemplate,
+       controls      Controls OPTIONAL }
+
+   -- If certTemplate is an empty SEQUENCE (i.e., all fields
+   -- omitted), then controls MAY contain the
+
+
+
+Adams, et al.               Standards Track                    [Page 63]
+
+RFC 4210                          CMP                     September 2005
+
+
+   -- id-regCtrl-altCertTemplate control, specifying a template
+   -- for a certificate other than an X.509v3 public-key
+   -- certificate.  Conversely, if certTemplate is not empty
+   -- (i.e., at least one field is present), then controls MUST
+   -- NOT contain id-regCtrl- altCertTemplate.  The new control is
+   -- defined as follows:
+
+   id-regCtrl-altCertTemplate OBJECT IDENTIFIER ::= {id-regCtrl 7}
+   AltCertTemplate ::= AttributeTypeAndValue
+
+   POPOSigningKey ::= SEQUENCE {
+       poposkInput           [0] POPOSigningKeyInput OPTIONAL,
+       algorithmIdentifier   AlgorithmIdentifier,
+       signature             BIT STRING }
+
+   -- **********
+   -- * For the purposes of this specification, the ASN.1 comment
+   -- * given in [CRMF] pertains not only to certTemplate, but
+   -- * also to the altCertTemplate control.  That is,
+   -- **********
+   -- * The signature (using "algorithmIdentifier") is on the
+   -- * DER-encoded value of poposkInput (i.e., the "value" OCTETs
+   -- * of the POPOSigningKeyInput DER).  NOTE: If CertReqMsg
+   -- * certReq certTemplate (or the altCertTemplate control)
+   -- * contains the subject and publicKey values, then poposkInput
+   -- * MUST be omitted and the signature MUST be computed on the
+   -- * DER-encoded value of CertReqMsg certReq (or the DER-
+   -- * encoded value of AltCertTemplate).  If
+   -- * certTemplate/altCertTemplate does not contain both the
+   -- * subject and public key values (i.e., if it contains only
+   -- * one of these, or neither), then poposkInput MUST be present
+   -- * and MUST be signed.
+   -- **********
+
+   POPOPrivKey ::= CHOICE {
+       thisMessage       [0] BIT STRING,
+
+   -- **********
+   -- * the type of "thisMessage" is given as BIT STRING in
+   -- * [CRMF]; it should be "EncryptedValue" (in accordance
+   -- * with Section 5.2.2, "Encrypted Values", of this specification).
+   -- * Therefore, this document makes the behavioral clarification
+   -- * of specifying that the contents of "thisMessage" MUST be encoded
+   -- * as an EncryptedValue and then wrapped in a BIT STRING.  This
+   -- * allows the necessary conveyance and protection of the
+   -- * private key while maintaining bits-on-the-wire compatibility
+   -- * with [CRMF].
+   -- **********
+
+
+
+Adams, et al.               Standards Track                    [Page 64]
+
+RFC 4210                          CMP                     September 2005
+
+
+       subsequentMessage [1] SubsequentMessage,
+       dhMAC             [2] BIT STRING }
+
+Appendix D.  PKI Management Message Profiles (REQUIRED).
+
+   This appendix contains detailed profiles for those PKIMessages that
+   MUST be supported by conforming implementations (see Section 6).
+
+   Profiles for the PKIMessages used in the following PKI management
+   operations are provided:
+
+   o  initial registration/certification
+
+   o  basic authenticated scheme
+
+   o  certificate request
+
+   o  key update
+
+D.1.  General Rules for Interpretation of These Profiles.
+
+   1.  Where OPTIONAL or DEFAULT fields are not mentioned in individual
+       profiles, they SHOULD be absent from the relevant message (i.e.,
+       a receiver can validly reject a message containing such fields as
+       being syntactically incorrect).  Mandatory fields are not
+       mentioned if they have an obvious value (e.g., in this version of
+       the specification, pvno is always 2).
+
+   2.  Where structures occur in more than one message, they are
+       separately profiled as appropriate.
+
+   3.  The algorithmIdentifiers from PKIMessage structures are profiled
+       separately.
+
+   4.  A "special" X.500 DN is called the "NULL-DN"; this means a DN
+       containing a zero-length SEQUENCE OF RelativeDistinguishedNames
+       (its DER encoding is then '3000'H).
+
+   5.  Where a GeneralName is required for a field, but no suitable
+       value is available (e.g., an end entity produces a request before
+       knowing its name), then the GeneralName is to be an X.500 NULL-DN
+       (i.e., the Name field of the CHOICE is to contain a NULL-DN).
+       This special value can be called a "NULL-GeneralName".
+
+   6.  Where a profile omits to specify the value for a GeneralName,
+       then the NULL-GeneralName value is to be present in the relevant
+       PKIMessage field.  This occurs with the sender field of the
+       PKIHeader for some messages.
+
+
+
+Adams, et al.               Standards Track                    [Page 65]
+
+RFC 4210                          CMP                     September 2005
+
+
+   7.  Where any ambiguity arises due to naming of fields, the profile
+       names these using a "dot" notation (e.g., "certTemplate.subject"
+       means the subject field within a field called certTemplate).
+
+   8.  Where a "SEQUENCE OF types" is part of a message, a zero-based
+       array notation is used to describe fields within the SEQUENCE OF
+       (e.g., crm[0].certReq.certTemplate.subject refers to a subfield
+       of the first CertReqMsg contained in a request message).
+
+   9.  All PKI message exchanges in Appendix D.4 to D.6 require a
+       certConf message to be sent by the initiating entity and a
+       PKIConfirm to be sent by the responding entity.  The PKIConfirm
+       is not included in some of the profiles given since its body is
+       NULL and its header contents are clear from the context.  Any
+       authenticated means can be used for the protectionAlg (e.g.,
+       password-based MAC, if shared secret information is known, or
+       signature).
+
+D.2.  Algorithm Use Profile
+
+   The following table contains definitions of algorithm uses within PKI
+   management protocols.  The columns in the table are:
+
+   Name: an identifier used for message profiles
+
+   Use: description of where and for what the algorithm is used
+
+   Mandatory: an AlgorithmIdentifier which MUST be supported by
+      conforming implementations
+
+   Others: alternatives to the mandatory AlgorithmIdentifier
+
+    Name         Use                      Mandatory        Others
+
+    MSG_SIG_ALG  Protection of PKI        DSA/SHA-1        RSA/MD5,
+                 messages using signature                  ECDSA, ...
+    MSG_MAC_ALG  protection of PKI        PasswordBasedMac HMAC,
+                 messages using MACing                     X9.9...
+    SYM_PENC_ALG symmetric encryption of  3-DES (3-key-    AES,RC5,
+                 an end entity's private  EDE, CBC mode)   CAST-128...
+                 key where symmetric
+                 key is distributed
+                 out-of-band
+    PROT_ENC_ALG asymmetric algorithm     D-H              RSA,
+                 used for encryption of                    ECDH, ...
+                 (symmetric keys for
+                 encryption of) private
+                 keys transported in
+
+
+
+Adams, et al.               Standards Track                    [Page 66]
+
+RFC 4210                          CMP                     September 2005
+
+
+                 PKIMessages
+    PROT_SYM_ALG symmetric encryption     3-DES (3-key-    AES,RC5,
+                 algorithm used for       EDE, CBC mode)   CAST-128...
+                 encryption of private
+                 key bits (a key of this
+                 type is encrypted using
+                 PROT_ENC_ALG)
+
+   Mandatory AlgorithmIdentifiers and Specifications:
+
+   DSA/SHA-1:
+     AlgId: {1 2 840 10040 4 3};
+
+   Digital Signature Standard [FIPS-186]
+
+     Public Modulus size: 1024 bits.
+
+   PasswordBasedMac:
+
+     AlgId: {1 2 840 113533 7 66 13}, with SHA-1 {1 3 14 3 2 26} as the
+            owf parameter and HMAC-SHA1 {1 3 6 1 5 5 8 1 2} as the mac
+            parameter;
+
+     (this specification), along with
+
+   Secure Hash Standard [FIPS-180] and [RFC2104]
+
+     HMAC key size:  160 bits (i.e., "K" = "H" in Section 5.1.3.1,
+                               "Shared secret information")
+
+   3-DES:
+
+     AlgId: {1 2 840 113549 3 7};
+     (used in RSA's BSAFE and in S/MIME).
+
+   D-H:
+
+     AlgId:  {1 2 840 10046 2 1};
+
+   [ANSI-X9.42]
+
+     Public Modulus Size:  1024 bits.
+     DomainParameters ::= SEQUENCE {
+        p       INTEGER, -- odd prime, p=jq +1
+        g       INTEGER, -- generator, g^q = 1 mod p
+        q       INTEGER, -- prime factor of p-1
+        j       INTEGER OPTIONAL, -- cofactor, j>=2
+        validationParms  ValidationParms OPTIONAL
+
+
+
+Adams, et al.               Standards Track                    [Page 67]
+
+RFC 4210                          CMP                     September 2005
+
+
+     }
+     ValidationParms ::= SEQUENCE {
+        seed          BIT STRING, -- seed for prime generation
+        pGenCounter   INTEGER     -- parameter verification
+     }
+
+D.3.  Proof-of-Possession Profile
+
+   POP fields for use (in signature field of pop field of
+   ProofOfPossession structure) when proving possession of a private
+   signing key that corresponds to a public verification key for which a
+   certificate has been requested.
+
+    Field               Value         Comment
+
+    algorithmIdentifier MSG_SIG_ALG   only signature protection is
+                                      allowed for this proof
+
+    signature           present       bits calculated using MSG_SIG_ALG
+
+   Proof-of-possession of a private decryption key that corresponds to a
+   public encryption key for which a certificate has been requested does
+   not use this profile; the CertHash field of the certConf message is
+   used instead.
+
+   Not every CA/RA will do Proof-of-Possession (of signing key,
+   decryption key, or key agreement key) in the PKIX-CMP in-band
+   certification request protocol (how POP is done MAY ultimately be a
+   policy issue that is made explicit for any given CA in its publicized
+   Policy OID and Certification Practice Statement).  However, this
+   specification MANDATES that CA/RA entities MUST do POP (by some
+   means) as part of the certification process.  All end entities MUST
+   be prepared to provide POP (i.e., these components of the PKIX-CMP
+   protocol MUST be supported).
+
+D.4.  Initial Registration/Certification (Basic Authenticated Scheme)
+
+   An (uninitialized) end entity requests a (first) certificate from a
+   CA.  When the CA responds with a message containing a certificate,
+   the end entity replies with a certificate confirmation.  The CA sends
+   a PKIConfirm back, closing the transaction.  All messages are
+   authenticated.
+
+   This scheme allows the end entity to request certification of a
+   locally-generated public key (typically a signature key).  The end
+   entity MAY also choose to request the centralized generation and
+   certification of another key pair (typically an encryption key pair).
+
+
+
+
+Adams, et al.               Standards Track                    [Page 68]
+
+RFC 4210                          CMP                     September 2005
+
+
+   Certification may only be requested for one locally generated public
+   key (for more, use separate PKIMessages).
+
+   The end entity MUST support proof-of-possession of the private key
+   associated with the locally-generated public key.
+
+   Preconditions:
+
+   1.  The end entity can authenticate the CA's signature based on out-
+       of-band means
+
+   2.  The end entity and the CA share a symmetric MACing key
+
+   Message flow:
+
+    Step# End entity                           PKI
+      1   format ir
+      2                      ->   ir      ->
+      3                                        handle ir
+      4                                        format ip
+      5                      <-   ip      <-
+      6   handle ip
+      7   format certConf
+      8                      ->   certConf ->
+      9                                        handle certConf
+     10                                        format PKIConf
+     11                      <-   PKIConf  <-
+     12   handle PKIConf
+
+   For this profile, we mandate that the end entity MUST include all
+   (i.e., one or two) CertReqMsg in a single PKIMessage, and that the
+   PKI (CA) MUST produce a single response PKIMessage that contains the
+   complete response (i.e., including the OPTIONAL second key pair, if
+   it was requested and if centralized key generation is supported).
+   For simplicity, we also mandate that this message MUST be the final
+   one (i.e., no use of "waiting" status value).
+
+   The end entity has an out-of-band interaction with the CA/RA.  This
+   transaction established the shared secret, the referenceNumber and
+   OPTIONALLY the distinguished name used for both sender and subject
+   name in the certificate template.  It is RECOMMENDED that the shared
+   secret be at least 12 characters long.
+
+   Initialization Request -- ir
+
+   Field                Value
+
+   recipient            CA name
+
+
+
+Adams, et al.               Standards Track                    [Page 69]
+
+RFC 4210                          CMP                     September 2005
+
+
+     -- the name of the CA who is being asked to produce a certificate
+   protectionAlg        MSG_MAC_ALG
+     -- only MAC protection is allowed for this request, based
+     -- on initial authentication key
+   senderKID            referenceNum
+     -- the reference number which the CA has previously issued
+     -- to the end entity (together with the MACing key)
+   transactionID        present
+     -- implementation-specific value, meaningful to end
+     -- entity.
+     -- [If already in use at the CA, then a rejection message MUST
+     -- be produced by the CA]
+
+   senderNonce          present
+     -- 128 (pseudo-)random bits
+   freeText             any valid value
+   body                 ir (CertReqMessages)
+                        only one or two CertReqMsg
+                        are allowed
+     -- if more certificates are required, requests MUST be
+     -- packaged in separate PKIMessages
+
+   CertReqMsg           one or two present
+     -- see below for details, note: crm[0] means the first
+     -- (which MUST be present), crm[1] means the second (which
+     -- is OPTIONAL, and used to ask for a centrally-generated key)
+
+   crm[0].certReq.      fixed value of zero
+      certReqId
+     -- this is the index of the template within the message
+   crm[0].certReq       present
+      certTemplate
+     -- MUST include subject public key value, otherwise unconstrained
+   crm[0].pop...        optionally present if public key
+      POPOSigningKey    from crm[0].certReq.certTemplate is
+                        a signing key
+     -- proof-of-possession MAY be required in this exchange
+     -- (see Appendix D.3 for details)
+   crm[0].certReq.      optionally present
+      controls.archiveOptions
+     -- the end entity MAY request that the locally-generated
+     -- private key be archived
+
+   crm[0].certReq.      optionally present
+      controls.publicationInfo
+     -- the end entity MAY ask for publication of resulting cert.
+
+   crm[1].certReq       fixed value of one
+
+
+
+Adams, et al.               Standards Track                    [Page 70]
+
+RFC 4210                          CMP                     September 2005
+
+
+      certReqId
+     -- the index of the template within the message
+   crm[1].certReq       present
+      certTemplate
+      -- MUST NOT include actual public key bits, otherwise
+      -- unconstrained (e.g., the names need not be the same as in
+      -- crm[0]).  Note that subjectPublicKeyInfo MAY be present
+      -- and contain an AlgorithmIdentifier followed by a
+      -- zero-length BIT STRING for the subjectPublicKey if it is
+      -- desired to inform the CA/RA of algorithm and parameter
+      -- preferences regarding the to-be-generated key pair.
+
+   crm[1].certReq.      present [object identifier MUST be PROT_ENC_ALG]
+
+      controls.protocolEncrKey
+     -- if centralized key generation is supported by this CA,
+     -- this short-term asymmetric encryption key (generated by
+     -- the end entity) will be used by the CA to encrypt (a
+     -- symmetric key used to encrypt) a private key generated by
+     -- the CA on behalf of the end entity
+
+   crm[1].certReq.      optionally present
+      controls.archiveOptions
+   crm[1].certReq.      optionally present
+      controls.publicationInfo
+   protection           present
+     -- bits calculated using MSG_MAC_ALG
+
+   Initialization Response -- ip
+
+   Field                Value
+
+   sender               CA name
+     -- the name of the CA who produced the message
+   messageTime          present
+     -- time at which CA produced message
+   protectionAlg        MS_MAC_ALG
+     -- only MAC protection is allowed for this response
+   senderKID             referenceNum
+     -- the reference number that the CA has previously issued to the
+     -- end entity (together with the MACing key)
+   transactionID        present
+     -- value from corresponding ir message
+   senderNonce          present
+     -- 128 (pseudo-)random bits
+   recipNonce           present
+     -- value from senderNonce in corresponding ir message
+   freeText             any valid value
+
+
+
+Adams, et al.               Standards Track                    [Page 71]
+
+RFC 4210                          CMP                     September 2005
+
+
+   body                 ip (CertRepMessage)
+                        contains exactly one response
+                        for each request
+
+     -- The PKI (CA) responds to either one or two requests as
+     -- appropriate.  crc[0] denotes the first (always present);
+     -- crc[1] denotes the second (only present if the ir message
+     -- contained two requests and if the CA supports centralized
+     -- key generation).
+   crc[0].              fixed value of zero
+      certReqId
+     -- MUST contain the response to the first request in the
+     -- corresponding ir message
+
+   crc[0].status.       present, positive values allowed:
+      status               "accepted", "grantedWithMods"
+                        negative values allowed:
+                           "rejection"
+   crc[0].status.       present if and only if
+      failInfo          crc[0].status.status is "rejection"
+   crc[0].              present if and only if
+      certifiedKeyPair  crc[0].status.status is
+                           "accepted" or "grantedWithMods"
+   certificate          present unless end entity's public
+                        key is an encryption key and POP
+                        is done in this in-band exchange
+   encryptedCert        present if and only if end entity's
+                        public key is an encryption key and
+                        POP done in this in-band exchange
+   publicationInfo      optionally present
+
+     -- indicates where certificate has been published (present
+     -- at discretion of CA)
+
+   crc[1].              fixed value of one
+      certReqId
+     -- MUST contain the response to the second request in the
+     -- corresponding ir message
+   crc[1].status.       present, positive values allowed:
+      status               "accepted", "grantedWithMods"
+                        negative values allowed:
+                           "rejection"
+   crc[1].status.       present if and only if
+      failInfo          crc[0].status.status is "rejection"
+   crc[1].              present if and only if
+      certifiedKeyPair  crc[0].status.status is "accepted"
+                        or "grantedWithMods"
+   certificate          present
+
+
+
+Adams, et al.               Standards Track                    [Page 72]
+
+RFC 4210                          CMP                     September 2005
+
+
+   privateKey           present
+     -- see Appendix C, Request Message Behavioral Clarifications
+   publicationInfo      optionally present
+     -- indicates where certificate has been published (present
+     -- at discretion of CA)
+
+   protection           present
+     -- bits calculated using MSG_MAC_ALG
+   extraCerts           optionally present
+     -- the CA MAY provide additional certificates to the end
+     -- entity
+
+   Certificate confirm; certConf
+
+   Field                Value
+
+   sender               present
+     -- same as in ir
+   recipient            CA name
+     -- the name of the CA who was asked to produce a certificate
+   transactionID        present
+     -- value from corresponding ir and ip messages
+   senderNonce          present
+     -- 128 (pseudo-) random bits
+   recipNonce           present
+     -- value from senderNonce in corresponding ip message
+   protectionAlg        MSG_MAC_ALG
+     -- only MAC protection is allowed for this message.  The
+     -- MAC is based on the initial authentication key shared
+     -- between the EE and the CA.
+
+   senderKID            referenceNum
+     -- the reference number which the CA has previously issued
+     -- to the end entity (together with the MACing key)
+
+   body                 certConf
+     -- see Section 5.3.18, "PKI Confirmation Content", for the
+     -- contents of the certConf fields.
+     -- Note: two CertStatus structures are required if both an
+     -- encryption and a signing certificate were sent.
+
+   protection           present
+     -- bits calculated using MSG_MAC_ALG
+
+   Confirmation; PKIConf
+
+   Field                Value
+
+
+
+
+Adams, et al.               Standards Track                    [Page 73]
+
+RFC 4210                          CMP                     September 2005
+
+
+   sender               present
+     -- same as in ip
+   recipient            present
+     -- sender name from certConf
+   transactionID        present
+     -- value from certConf message
+   senderNonce          present
+     -- 128 (pseudo-) random bits
+   recipNonce           present
+     -- value from senderNonce from certConf message
+   protectionAlg        MSG_MAC_ALG
+     -- only MAC protection is allowed for this message.
+   senderKID            referenceNum
+   body                 PKIConf
+   protection           present
+     -- bits calculated using MSG_MAC_ALG
+
+D.5.  Certificate Request
+
+   An (initialized) end entity requests a certificate from a CA (for any
+   reason).  When the CA responds with a message containing a
+   certificate, the end entity replies with a certificate confirmation.
+   The CA replies with a PKIConfirm, to close the transaction.  All
+   messages are authenticated.
+
+   The profile for this exchange is identical to that given in Appendix
+   D.4, with the following exceptions:
+
+   o  sender name SHOULD be present
+
+   o  protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY
+      also be supported) in request, response, certConfirm, and
+      PKIConfirm messages;
+
+   o  senderKID and recipKID are only present if required for message
+      verification;
+
+   o  body is cr or cp;
+
+   o  body may contain one or two CertReqMsg structures, but either
+      CertReqMsg may be used to request certification of a locally-
+      generated public key or a centrally-generated public key (i.e.,
+      the position-dependence requirement of Appendix D.4 is removed);
+
+   o  protection bits are calculated according to the protectionAlg
+      field.
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 74]
+
+RFC 4210                          CMP                     September 2005
+
+
+D.6.  Key Update Request
+
+   An (initialized) end entity requests a certificate from a CA (to
+   update the key pair and/or corresponding certificate that it already
+   possesses).  When the CA responds with a message containing a
+   certificate, the end entity replies with a certificate confirmation.
+   The CA replies with a PKIConfirm, to close the transaction.  All
+   messages are authenticated.
+
+   The profile for this exchange is identical to that given in Appendix
+   D.4, with the following exceptions:
+
+   1.  sender name SHOULD be present
+
+   2.  protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY
+       also be supported) in request, response, certConfirm, and
+       PKIConfirm messages;
+
+   3.  senderKID and recipKID are only present if required for message
+       verification;
+
+   4.  body is kur or kup;
+
+   5.  body may contain one or two CertReqMsg structures, but either
+       CertReqMsg may be used to request certification of a locally-
+       generated public key or a centrally-generated public key (i.e.,
+       the position-dependence requirement of Appendix D.4 is removed);
+
+   6.  protection bits are calculated according to the protectionAlg
+       field;
+
+   7.  regCtrl OldCertId SHOULD be used (unless it is clear to both
+       sender and receiver -- by means not specified in this document --
+       that it is not needed).
+
+Appendix E.  PKI Management Message Profiles (OPTIONAL).
+
+   This appendix contains detailed profiles for those PKIMessages that
+   MAY be supported by implementations (in addition to the messages
+   which MUST be supported; see Section 6 and Appendix D).
+
+   Profiles for the PKIMessages used in the following PKI management
+   operations are provided:
+
+   o  root CA key update
+
+   o  information request/response
+
+
+
+
+Adams, et al.               Standards Track                    [Page 75]
+
+RFC 4210                          CMP                     September 2005
+
+
+   o  cross-certification request/response (1-way)
+
+   o  in-band initialization using external identity certificate
+
+   Later versions of this document may extend the above to include
+   profiles for the operations listed below (along with other
+   operations, if desired).
+
+   o  revocation request
+
+   o  certificate publication
+
+   o  CRL publication
+
+E.1.  General Rules for Interpretation of These Profiles.
+
+   Identical to Appendix D.1.
+
+E.2.  Algorithm Use Profile
+
+   Identical to Appendix D.2.
+
+E.3.  Self-Signed Certificates
+
+   Profile of how a Certificate structure may be "self-signed".  These
+   structures are used for distribution of CA public keys.  This can
+   occur in one of three ways (see Section 4.4 above for a description
+   of the use of these structures):
+
+   Type          Function
+   -----------------------------------------------------------------
+   newWithNew a true "self-signed" certificate; the contained
+              public key MUST be usable to verify the signature
+              (though this provides only integrity and no
+              authentication whatsoever)
+   oldWithNew previous root CA public key signed with new private key
+   newWithOld new root CA public key signed with previous private key
+
+   Such certificates (including relevant extensions) must contain
+   "sensible" values for all fields.  For example, when present,
+   subjectAltName MUST be identical to issuerAltName, and, when present,
+   keyIdentifiers must contain appropriate values, et cetera.
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 76]
+
+RFC 4210                          CMP                     September 2005
+
+
+E.4.  Root CA Key Update
+
+   A root CA updates its key pair.  It then produces a CA key update
+   announcement message that can be made available (via some transport
+   mechanism) to the relevant end entities.  A confirmation message is
+   NOT REQUIRED from the end entities.
+
+   ckuann message:
+
+    Field        Value                        Comment
+   --------------------------------------------------------------
+    sender       CA name CA name
+    body         ckuann(CAKeyUpdAnnContent)
+    oldWithNew   present                  see Appendix E.3 above
+    newWithOld   present                  see Appendix E.3 above
+    newWithNew   present                  see Appendix E.3 above
+    extraCerts   optionally present       can be used to "publish"
+                                          certificates (e.g.,
+                                          certificates signed using
+                                          the new private key)
+
+E.5.  PKI Information Request/Response
+
+   The end entity sends a general message to the PKI requesting details
+   that will be required for later PKI management operations.  RA/CA
+   responds with a general response.  If an RA generates the response,
+   then it will simply forward the equivalent message that it previously
+   received from the CA, with the possible addition of certificates to
+   the extraCerts fields of the PKIMessage.  A confirmation message is
+   NOT REQUIRED from the end entity.
+
+   Message Flows:
+
+   Step# End entity                        PKI
+
+      1  format genm
+      2                ->   genm   ->
+      3                                    handle genm
+      4                                    produce genp
+      5                <-   genp   <-
+      6  handle genp
+
+   genM:
+
+   Field               Value
+
+   recipient           CA name
+     -- the name of the CA as contained in issuerAltName
+
+
+
+Adams, et al.               Standards Track                    [Page 77]
+
+RFC 4210                          CMP                     September 2005
+
+
+     -- extensions or issuer fields within certificates
+   protectionAlg       MSG_MAC_ALG or MSG_SIG_ALG
+     -- any authenticated protection alg.
+   SenderKID           present if required
+     -- must be present if required for verification of message
+     -- protection
+   freeText            any valid value
+   body                genr (GenReqContent)
+   GenMsgContent       empty SEQUENCE
+     -- all relevant information requested
+   protection          present
+     -- bits calculated using MSG_MAC_ALG or MSG_SIG_ALG
+
+   genP:
+
+   Field                Value
+
+   sender               CA name
+     -- name of the CA which produced the message
+   protectionAlg        MSG_MAC_ALG or MSG_SIG_ALG
+     -- any authenticated protection alg.
+   senderKID            present if required
+     -- must be present if required for verification of message
+     -- protection
+   body                 genp (GenRepContent)
+   CAProtEncCert        present (object identifier one
+                        of PROT_ENC_ALG), with relevant
+                        value
+     -- to be used if end entity needs to encrypt information for
+     -- the CA (e.g., private key for recovery purposes)
+
+   SignKeyPairTypes     present, with relevant value
+     -- the set of signature algorithm identifiers that this CA will
+     -- certify for subject public keys
+   EncKeyPairTypes      present, with relevant value
+     -- the set of encryption/key agreement algorithm identifiers that
+     -- this CA will certify for subject public keys
+   PreferredSymmAlg     present (object identifier one
+                        of PROT_SYM_ALG) , with relevant
+                        value
+     -- the symmetric algorithm that this CA expects to be used
+     -- in later PKI messages (for encryption)
+   CAKeyUpdateInfo      optionally present, with
+                        relevant value
+     -- the CA MAY provide information about a relevant root CA
+     -- key pair using this field (note that this does not imply
+     -- that the responding CA is the root CA in question)
+   CurrentCRL           optionally present, with relevant value
+
+
+
+Adams, et al.               Standards Track                    [Page 78]
+
+RFC 4210                          CMP                     September 2005
+
+
+     -- the CA MAY provide a copy of a complete CRL (i.e.,
+     -- fullest possible one)
+   protection           present
+     -- bits calculated using MSG_MAC_ALG or MSG_SIG_ALG
+   extraCerts           optionally present
+     -- can be used to send some certificates to the end
+     -- entity. An RA MAY add its certificate here.
+
+E.6.  Cross Certification Request/Response (1-way)
+
+   Creation of a single cross-certificate (i.e., not two at once).  The
+   requesting CA MAY choose who is responsible for publication of the
+   cross-certificate created by the responding CA through use of the
+   PKIPublicationInfo control.
+
+   Preconditions:
+
+   1.  Responding CA can verify the origin of the request (possibly
+       requiring out-of-band means) before processing the request.
+
+   2.  Requesting CA can authenticate the authenticity of the origin of
+       the response (possibly requiring out-of-band means) before
+       processing the response
+
+   The use of certificate confirmation and the corresponding server
+   confirmation is determined by the generalInfo field in the PKIHeader
+   (see Section 5.1.1).  The following profile does not mandate support
+   for either confirmation.
+
+   Message Flows:
+
+   Step# Requesting CA                       Responding CA
+     1   format ccr
+     2                   ->    ccr    ->
+     3                                       handle ccr
+     4                                       produce ccp
+     5                   <-    ccp    <-
+     6   handle ccp
+
+   ccr:
+
+   Field                 Value
+
+   sender                Requesting CA name
+     -- the name of the CA who produced the message
+   recipient             Responding CA name
+     -- the name of the CA who is being asked to produce a certificate
+   messageTime           time of production of message
+
+
+
+Adams, et al.               Standards Track                    [Page 79]
+
+RFC 4210                          CMP                     September 2005
+
+
+     -- current time at requesting CA
+   protectionAlg         MSG_SIG_ALG
+     -- only signature protection is allowed for this request
+   senderKID             present if required
+     -- must be present if required for verification of message
+     -- protection
+   recipKID             present if required
+     -- must be present if required for verification of message
+     -- protection
+   transactionID         present
+     -- implementation-specific value, meaningful to requesting CA.
+     -- [If already in use at responding CA then a rejection message
+     -- MUST be produced by responding CA]
+   senderNonce           present
+     -- 128 (pseudo-)random bits
+   freeText              any valid value
+   body                  ccr (CertReqMessages)
+                         only one CertReqMsg
+                         allowed
+     -- if multiple cross certificates are required, they MUST be
+     -- packaged in separate PKIMessages
+   certTemplate          present
+     -- details follow
+   version               v1 or v3
+     -- v3 STRONGLY RECOMMENDED
+   signingAlg            present
+     -- the requesting CA must know in advance with which algorithm it
+     -- wishes the certificate to be signed
+
+   subject               present
+     -- may be NULL-DN only if subjectAltNames extension value proposed
+   validity              present
+     -- MUST be completely specified (i.e., both fields present)
+   issuer                present
+     -- may be NULL-DN only if issuerAltNames extension value proposed
+   publicKey             present
+     -- the key to be certified (which must be for a signing algorithm)
+   extensions            optionally present
+     -- a requesting CA must propose values for all extensions
+     -- that it requires to be in the cross-certificate
+   POPOSigningKey        present
+     -- see Section D3: Proof-of-possession profile
+   protection            present
+     -- bits calculated using MSG_SIG_ALG
+   extraCerts            optionally present
+     -- MAY contain any additional certificates that requester wishes
+     -- to include
+
+
+
+
+Adams, et al.               Standards Track                    [Page 80]
+
+RFC 4210                          CMP                     September 2005
+
+
+   ccp:
+
+   Field                 Value
+
+   sender                Responding CA name
+     -- the name of the CA who produced the message
+   recipient             Requesting CA name
+     -- the name of the CA who asked for production of a certificate
+   messageTime           time of production of message
+     -- current time at responding CA
+   protectionAlg         MSG_SIG_ALG
+     -- only signature protection is allowed for this message
+   senderKID             present if required
+     -- must be present if required for verification of message
+     -- protection
+   recipKID              present if required
+   transactionID         present
+     -- value from corresponding ccr message
+   senderNonce           present
+     -- 128 (pseudo-)random bits
+   recipNonce            present
+   -- senderNonce from corresponding ccr message
+   freeText              any valid value
+   body                  ccp (CertRepMessage)
+                         only one CertResponse allowed
+     -- if multiple cross certificates are required they MUST be
+     -- packaged in separate PKIMessages
+   response              present
+   status                present
+
+   PKIStatusInfo.status  present
+     -- if PKIStatusInfo.status is one of:
+     --   accepted, or
+     --   grantedWithMods,
+     -- then certifiedKeyPair MUST be present and failInfo MUST
+     -- be absent
+
+   failInfo              present depending on
+                         PKIStatusInfo.status
+     -- if PKIStatusInfo.status is:
+     --   rejection
+     -- then certifiedKeyPair MUST be absent and failInfo MUST be
+     -- present and contain appropriate bit settings
+
+   certifiedKeyPair      present depending on
+                         PKIStatusInfo.status
+   certificate           present depending on
+                         certifiedKeyPair
+
+
+
+Adams, et al.               Standards Track                    [Page 81]
+
+RFC 4210                          CMP                     September 2005
+
+
+     -- content of actual certificate must be examined by requesting CA
+     -- before publication
+   protection            present
+     -- bits calculated using MSG_SIG_ALG
+   extraCerts            optionally present
+     -- MAY contain any additional certificates that responder wishes
+     -- to include
+
+E.7.  In-Band Initialization Using External Identity Certificate
+
+   An (uninitialized) end entity wishes to initialize into the PKI with
+   a CA, CA-1.  It uses, for authentication purposes, a pre-existing
+   identity certificate issued by another (external) CA, CA-X.  A trust
+   relationship must already have been established between CA-1 and CA-X
+   so that CA-1 can validate the EE identity certificate signed by CA-X.
+   Furthermore, some mechanism must already have been established within
+   the Personal Security Environment (PSE) of the EE that would allow it
+   to authenticate and verify PKIMessages signed by CA-1 (as one
+   example, the PSE may contain a certificate issued for the public key
+   of CA-1, signed by another CA that the EE trusts on the basis of
+   out-of-band authentication techniques).
+
+   The EE sends an initialization request to start the transaction.
+   When CA-1 responds with a message containing the new certificate, the
+   end entity replies with a certificate confirmation.  CA-1 replies
+   with a PKIConfirm to close the transaction.  All messages are signed
+   (the EE messages are signed using the private key that corresponds to
+   the public key in its external identity certificate; the CA-1
+   messages are signed using the private key that corresponds to the
+   public key in a
+
+   certificate that can be chained to a trust anchor in the EE's PSE).
+
+   The profile for this exchange is identical to that given in Appendix
+   D.4, with the following exceptions:
+
+   o  the EE and CA-1 do not share a symmetric MACing key (i.e., there
+      is no out-of-band shared secret information between these
+      entities);
+
+   o  sender name in ir MUST be present (and identical to the subject
+      name present in the external identity certificate);
+
+   o  protectionAlg of MSG_SIG_ALG MUST be used in all messages;
+
+   o  external identity cert.  MUST be carried in ir extraCerts field
+
+   o  senderKID and recipKID are not used;
+
+
+
+Adams, et al.               Standards Track                    [Page 82]
+
+RFC 4210                          CMP                     September 2005
+
+
+   o  body is ir or ip;
+
+   o  protection bits are calculated according to the protectionAlg
+      field.
+
+Appendix F.  Compilable ASN.1 Definitions
+
+     PKIXCMP {iso(1) identified-organization(3)
+           dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+           id-mod(0) id-mod-cmp2000(16)}
+
+     DEFINITIONS EXPLICIT TAGS ::=
+
+     BEGIN
+
+     -- EXPORTS ALL --
+
+     IMPORTS
+
+         Certificate, CertificateList, Extensions, AlgorithmIdentifier,
+         UTF8String -- if required; otherwise, comment out
+                FROM PKIX1Explicit88 {iso(1) identified-organization(3)
+                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+                id-mod(0) id-pkix1-explicit-88(1)}
+
+         GeneralName, KeyIdentifier
+                FROM PKIX1Implicit88 {iso(1) identified-organization(3)
+                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+                id-mod(0) id-pkix1-implicit-88(2)}
+
+         CertTemplate, PKIPublicationInfo, EncryptedValue, CertId,
+         CertReqMessages
+                FROM PKIXCRMF-2005 {iso(1) identified-organization(3)
+                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+                id-mod(0) id-mod-crmf2005(36)}
+
+         -- see also the behavioral clarifications to CRMF codified in
+         -- Appendix C of this specification
+
+         CertificationRequest
+                FROM PKCS-10 {iso(1) member-body(2)
+                              us(840) rsadsi(113549)
+                              pkcs(1) pkcs-10(10) modules(1) pkcs-10(1)}
+
+         -- (specified in RFC 2986 with 1993 ASN.1 syntax and IMPLICIT
+         -- tags).  Alternatively, implementers may directly include
+         -- the [PKCS10] syntax in this module
+
+
+
+
+Adams, et al.               Standards Track                    [Page 83]
+
+RFC 4210                          CMP                     September 2005
+
+
+         ;
+
+   -- the rest of the module contains locally-defined OIDs and
+   -- constructs
+
+      CMPCertificate ::= CHOICE {
+         x509v3PKCert        Certificate
+      }
+   -- This syntax, while bits-on-the-wire compatible with the
+   -- standard X.509 definition of "Certificate", allows the
+   -- possibility of future certificate types (such as X.509
+   -- attribute certificates, WAP WTLS certificates, or other kinds
+   -- of certificates) within this certificate management protocol,
+   -- should a need ever arise to support such generality.  Those
+   -- implementations that do not foresee a need to ever support
+   -- other certificate types MAY, if they wish, comment out the
+   -- above structure and "un-comment" the following one prior to
+   -- compiling this ASN.1 module.  (Note that interoperability
+   -- with implementations that don't do this will be unaffected by
+   -- this change.)
+
+   -- CMPCertificate ::= Certificate
+
+      PKIMessage ::= SEQUENCE {
+         header           PKIHeader,
+         body             PKIBody,
+         protection   [0] PKIProtection OPTIONAL,
+         extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
+                          OPTIONAL
+     }
+
+     PKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage
+
+     PKIHeader ::= SEQUENCE {
+         pvno                INTEGER     { cmp1999(1), cmp2000(2) },
+         sender              GeneralName,
+         -- identifies the sender
+         recipient           GeneralName,
+         -- identifies the intended recipient
+         messageTime     [0] GeneralizedTime         OPTIONAL,
+         -- time of production of this message (used when sender
+         -- believes that the transport will be "suitable"; i.e.,
+         -- that the time will still be meaningful upon receipt)
+         protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
+         -- algorithm used for calculation of protection bits
+         senderKID       [2] KeyIdentifier           OPTIONAL,
+         recipKID        [3] KeyIdentifier           OPTIONAL,
+         -- to identify specific keys used for protection
+
+
+
+Adams, et al.               Standards Track                    [Page 84]
+
+RFC 4210                          CMP                     September 2005
+
+
+         transactionID   [4] OCTET STRING            OPTIONAL,
+         -- identifies the transaction; i.e., this will be the same in
+         -- corresponding request, response, certConf, and PKIConf
+         -- messages
+         senderNonce     [5] OCTET STRING            OPTIONAL,
+         recipNonce      [6] OCTET STRING            OPTIONAL,
+         -- nonces used to provide replay protection, senderNonce
+         -- is inserted by the creator of this message; recipNonce
+         -- is a nonce previously inserted in a related message by
+         -- the intended recipient of this message
+         freeText        [7] PKIFreeText             OPTIONAL,
+         -- this may be used to indicate context-specific instructions
+         -- (this field is intended for human consumption)
+         generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
+                                InfoTypeAndValue     OPTIONAL
+         -- this may be used to convey context-specific information
+         -- (this field not primarily intended for human consumption)
+     }
+
+     PKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
+         -- text encoded as UTF-8 String [RFC3629] (note: each
+         -- UTF8String MAY include an [RFC3066] language tag
+         -- to indicate the language of the contained text
+         -- see [RFC2482] for details)
+
+     PKIBody ::= CHOICE {       -- message-specific body elements
+         ir       [0]  CertReqMessages,        --Initialization Request
+         ip       [1]  CertRepMessage,         --Initialization Response
+         cr       [2]  CertReqMessages,        --Certification Request
+         cp       [3]  CertRepMessage,         --Certification Response
+         p10cr    [4]  CertificationRequest,   --imported from [PKCS10]
+         popdecc  [5]  POPODecKeyChallContent, --pop Challenge
+         popdecr  [6]  POPODecKeyRespContent,  --pop Response
+         kur      [7]  CertReqMessages,        --Key Update Request
+         kup      [8]  CertRepMessage,         --Key Update Response
+         krr      [9]  CertReqMessages,        --Key Recovery Request
+         krp      [10] KeyRecRepContent,       --Key Recovery Response
+         rr       [11] RevReqContent,          --Revocation Request
+         rp       [12] RevRepContent,          --Revocation Response
+         ccr      [13] CertReqMessages,        --Cross-Cert. Request
+         ccp      [14] CertRepMessage,         --Cross-Cert. Response
+         ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann.
+         cann     [16] CertAnnContent,         --Certificate Ann.
+         rann     [17] RevAnnContent,          --Revocation Ann.
+         crlann   [18] CRLAnnContent,          --CRL Announcement
+         pkiconf  [19] PKIConfirmContent,      --Confirmation
+         nested   [20] NestedMessageContent,   --Nested Message
+         genm     [21] GenMsgContent,          --General Message
+
+
+
+Adams, et al.               Standards Track                    [Page 85]
+
+RFC 4210                          CMP                     September 2005
+
+
+         genp     [22] GenRepContent,          --General Response
+         error    [23] ErrorMsgContent,        --Error Message
+         certConf [24] CertConfirmContent,     --Certificate confirm
+         pollReq  [25] PollReqContent,         --Polling request
+         pollRep  [26] PollRepContent          --Polling response
+     }
+
+     PKIProtection ::= BIT STRING
+
+     ProtectedPart ::= SEQUENCE {
+         header    PKIHeader,
+         body      PKIBody
+     }
+
+     id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}
+     PBMParameter ::= SEQUENCE {
+         salt                OCTET STRING,
+         -- note:  implementations MAY wish to limit acceptable sizes
+         -- of this string to values appropriate for their environment
+         -- in order to reduce the risk of denial-of-service attacks
+         owf                 AlgorithmIdentifier,
+         -- AlgId for a One-Way Function (SHA-1 recommended)
+         iterationCount      INTEGER,
+         -- number of times the OWF is applied
+         -- note:  implementations MAY wish to limit acceptable sizes
+         -- of this integer to values appropriate for their environment
+         -- in order to reduce the risk of denial-of-service attacks
+         mac                 AlgorithmIdentifier
+         -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+     }   -- or HMAC [RFC2104, RFC2202])
+
+     id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}
+     DHBMParameter ::= SEQUENCE {
+         owf                 AlgorithmIdentifier,
+         -- AlgId for a One-Way Function (SHA-1 recommended)
+         mac                 AlgorithmIdentifier
+         -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+     }   -- or HMAC [RFC2104, RFC2202])
+
+
+     NestedMessageContent ::= PKIMessages
+
+     PKIStatus ::= INTEGER {
+         accepted                (0),
+         -- you got exactly what you asked for
+         grantedWithMods        (1),
+         -- you got something like what you asked for; the
+         -- requester is responsible for ascertaining the differences
+
+
+
+Adams, et al.               Standards Track                    [Page 86]
+
+RFC 4210                          CMP                     September 2005
+
+
+         rejection              (2),
+         -- you don't get it, more information elsewhere in the message
+         waiting                (3),
+         -- the request body part has not yet been processed; expect to
+         -- hear more later (note: proper handling of this status
+         -- response MAY use the polling req/rep PKIMessages specified
+         -- in Section 5.3.22; alternatively, polling in the underlying
+         -- transport layer MAY have some utility in this regard)
+         revocationWarning      (4),
+         -- this message contains a warning that a revocation is
+         -- imminent
+         revocationNotification (5),
+         -- notification that a revocation has occurred
+         keyUpdateWarning       (6)
+         -- update already done for the oldCertId specified in
+         -- CertReqMsg
+     }
+
+     PKIFailureInfo ::= BIT STRING {
+     -- since we can fail in more than one way!
+     -- More codes may be added in the future if/when required.
+         badAlg              (0),
+         -- unrecognized or unsupported Algorithm Identifier
+         badMessageCheck     (1),
+         -- integrity check failed (e.g., signature did not verify)
+         badRequest          (2),
+         -- transaction not permitted or supported
+         badTime             (3),
+         -- messageTime was not sufficiently close to the system time,
+         -- as defined by local policy
+         badCertId           (4),
+         -- no certificate could be found matching the provided criteria
+         badDataFormat       (5),
+         -- the data submitted has the wrong format
+         wrongAuthority      (6),
+         -- the authority indicated in the request is different from the
+         -- one creating the response token
+         incorrectData       (7),
+         -- the requester's data is incorrect (for notary services)
+         missingTimeStamp    (8),
+         -- when the timestamp is missing but should be there
+         -- (by policy)
+         badPOP              (9),
+         -- the proof-of-possession failed
+         certRevoked         (10),
+            -- the certificate has already been revoked
+         certConfirmed       (11),
+            -- the certificate has already been confirmed
+
+
+
+Adams, et al.               Standards Track                    [Page 87]
+
+RFC 4210                          CMP                     September 2005
+
+
+         wrongIntegrity      (12),
+            -- invalid integrity, password based instead of signature or
+            -- vice versa
+         badRecipientNonce   (13),
+            -- invalid recipient nonce, either missing or wrong value
+         timeNotAvailable    (14),
+            -- the TSA's time source is not available
+         unacceptedPolicy    (15),
+            -- the requested TSA policy is not supported by the TSA.
+         unacceptedExtension (16),
+            -- the requested extension is not supported by the TSA.
+         addInfoNotAvailable (17),
+            -- the additional information requested could not be
+            -- understood or is not available
+         badSenderNonce      (18),
+            -- invalid sender nonce, either missing or wrong size
+         badCertTemplate     (19),
+            -- invalid cert. template or missing mandatory information
+         signerNotTrusted    (20),
+            -- signer of the message unknown or not trusted
+         transactionIdInUse  (21),
+            -- the transaction identifier is already in use
+         unsupportedVersion  (22),
+            -- the version of the message is not supported
+         notAuthorized       (23),
+            -- the sender was not authorized to make the preceding
+            -- request or perform the preceding action
+         systemUnavail       (24),
+         -- the request cannot be handled due to system unavailability
+         systemFailure       (25),
+         -- the request cannot be handled due to system failure
+         duplicateCertReq    (26)
+         -- certificate cannot be issued because a duplicate
+         -- certificate already exists
+     }
+
+     PKIStatusInfo ::= SEQUENCE {
+         status        PKIStatus,
+         statusString  PKIFreeText     OPTIONAL,
+         failInfo      PKIFailureInfo  OPTIONAL
+     }
+
+     OOBCert ::= CMPCertificate
+
+     OOBCertHash ::= SEQUENCE {
+         hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
+         certId      [1] CertId                  OPTIONAL,
+         hashVal         BIT STRING
+
+
+
+Adams, et al.               Standards Track                    [Page 88]
+
+RFC 4210                          CMP                     September 2005
+
+
+         -- hashVal is calculated over the DER encoding of the
+         -- self-signed certificate with the identifier certID.
+     }
+
+     POPODecKeyChallContent ::= SEQUENCE OF Challenge
+     -- One Challenge per encryption key certification request (in the
+     -- same order as these requests appear in CertReqMessages).
+
+     Challenge ::= SEQUENCE {
+         owf                 AlgorithmIdentifier  OPTIONAL,
+
+         -- MUST be present in the first Challenge; MAY be omitted in
+         -- any subsequent Challenge in POPODecKeyChallContent (if
+         -- omitted, then the owf used in the immediately preceding
+         -- Challenge is to be used).
+
+         witness             OCTET STRING,
+         -- the result of applying the one-way function (owf) to a
+         -- randomly-generated INTEGER, A.  [Note that a different
+         -- INTEGER MUST be used for each Challenge.]
+         challenge           OCTET STRING
+         -- the encryption (under the public key for which the cert.
+         -- request is being made) of Rand, where Rand is specified as
+         --   Rand ::= SEQUENCE {
+         --      int      INTEGER,
+         --       - the randomly-generated INTEGER A (above)
+         --      sender   GeneralName
+         --       - the sender's name (as included in PKIHeader)
+         --   }
+     }
+
+     POPODecKeyRespContent ::= SEQUENCE OF INTEGER
+     -- One INTEGER per encryption key certification request (in the
+     -- same order as these requests appear in CertReqMessages).  The
+     -- retrieved INTEGER A (above) is returned to the sender of the
+     -- corresponding Challenge.
+
+     CertRepMessage ::= SEQUENCE {
+         caPubs       [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
+                          OPTIONAL,
+         response         SEQUENCE OF CertResponse
+     }
+
+     CertResponse ::= SEQUENCE {
+         certReqId           INTEGER,
+         -- to match this response with corresponding request (a value
+         -- of -1 is to be used if certReqId is not specified in the
+         -- corresponding request)
+
+
+
+Adams, et al.               Standards Track                    [Page 89]
+
+RFC 4210                          CMP                     September 2005
+
+
+         status              PKIStatusInfo,
+         certifiedKeyPair    CertifiedKeyPair    OPTIONAL,
+         rspInfo             OCTET STRING        OPTIONAL
+         -- analogous to the id-regInfo-utf8Pairs string defined
+         -- for regInfo in CertReqMsg [CRMF]
+     }
+
+     CertifiedKeyPair ::= SEQUENCE {
+         certOrEncCert       CertOrEncCert,
+         privateKey      [0] EncryptedValue      OPTIONAL,
+         -- see [CRMF] for comment on encoding
+         publicationInfo [1] PKIPublicationInfo  OPTIONAL
+     }
+
+     CertOrEncCert ::= CHOICE {
+         certificate     [0] CMPCertificate,
+         encryptedCert   [1] EncryptedValue
+     }
+
+     KeyRecRepContent ::= SEQUENCE {
+         status                  PKIStatusInfo,
+         newSigCert          [0] CMPCertificate OPTIONAL,
+         caCerts             [1] SEQUENCE SIZE (1..MAX) OF
+                                             CMPCertificate OPTIONAL,
+         keyPairHist         [2] SEQUENCE SIZE (1..MAX) OF
+                                             CertifiedKeyPair OPTIONAL
+     }
+
+     RevReqContent ::= SEQUENCE OF RevDetails
+
+     RevDetails ::= SEQUENCE {
+         certDetails         CertTemplate,
+         -- allows requester to specify as much as they can about
+         -- the cert. for which revocation is requested
+         -- (e.g., for cases in which serialNumber is not available)
+         crlEntryDetails     Extensions       OPTIONAL
+         -- requested crlEntryExtensions
+     }
+
+     RevRepContent ::= SEQUENCE {
+         status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
+         -- in same order as was sent in RevReqContent
+         revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId
+                                             OPTIONAL,
+         -- IDs for which revocation was requested
+         -- (same order as status)
+         crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList
+                                             OPTIONAL
+
+
+
+Adams, et al.               Standards Track                    [Page 90]
+
+RFC 4210                          CMP                     September 2005
+
+
+         -- the resulting CRLs (there may be more than one)
+     }
+
+     CAKeyUpdAnnContent ::= SEQUENCE {
+         oldWithNew   CMPCertificate, -- old pub signed with new priv
+         newWithOld   CMPCertificate, -- new pub signed with old priv
+         newWithNew   CMPCertificate  -- new pub signed with new priv
+     }
+
+     CertAnnContent ::= CMPCertificate
+
+     RevAnnContent ::= SEQUENCE {
+         status              PKIStatus,
+         certId              CertId,
+         willBeRevokedAt     GeneralizedTime,
+         badSinceDate        GeneralizedTime,
+         crlDetails          Extensions  OPTIONAL
+         -- extra CRL details (e.g., crl number, reason, location, etc.)
+     }
+
+     CRLAnnContent ::= SEQUENCE OF CertificateList
+
+     CertConfirmContent ::= SEQUENCE OF CertStatus
+
+     CertStatus ::= SEQUENCE {
+        certHash    OCTET STRING,
+        -- the hash of the certificate, using the same hash algorithm
+        -- as is used to create and verify the certificate signature
+        certReqId   INTEGER,
+        -- to match this confirmation with the corresponding req/rep
+        statusInfo  PKIStatusInfo OPTIONAL
+     }
+
+     PKIConfirmContent ::= NULL
+
+     InfoTypeAndValue ::= SEQUENCE {
+         infoType               OBJECT IDENTIFIER,
+         infoValue              ANY DEFINED BY infoType  OPTIONAL
+     }
+     -- Example InfoTypeAndValue contents include, but are not limited
+     -- to, the following (un-comment in this ASN.1 module and use as
+     -- appropriate for a given environment):
+     --
+     --   id-it-caProtEncCert    OBJECT IDENTIFIER ::= {id-it 1}
+     --      CAProtEncCertValue      ::= CMPCertificate
+     --   id-it-signKeyPairTypes OBJECT IDENTIFIER ::= {id-it 2}
+     --      SignKeyPairTypesValue   ::= SEQUENCE OF AlgorithmIdentifier
+     --   id-it-encKeyPairTypes  OBJECT IDENTIFIER ::= {id-it 3}
+
+
+
+Adams, et al.               Standards Track                    [Page 91]
+
+RFC 4210                          CMP                     September 2005
+
+
+     --      EncKeyPairTypesValue    ::= SEQUENCE OF AlgorithmIdentifier
+     --   id-it-preferredSymmAlg OBJECT IDENTIFIER ::= {id-it 4}
+     --      PreferredSymmAlgValue   ::= AlgorithmIdentifier
+     --   id-it-caKeyUpdateInfo  OBJECT IDENTIFIER ::= {id-it 5}
+     --      CAKeyUpdateInfoValue    ::= CAKeyUpdAnnContent
+     --   id-it-currentCRL       OBJECT IDENTIFIER ::= {id-it 6}
+     --      CurrentCRLValue         ::= CertificateList
+     --   id-it-unsupportedOIDs  OBJECT IDENTIFIER ::= {id-it 7}
+     --      UnsupportedOIDsValue    ::= SEQUENCE OF OBJECT IDENTIFIER
+     --   id-it-keyPairParamReq  OBJECT IDENTIFIER ::= {id-it 10}
+     --      KeyPairParamReqValue    ::= OBJECT IDENTIFIER
+     --   id-it-keyPairParamRep  OBJECT IDENTIFIER ::= {id-it 11}
+     --      KeyPairParamRepValue    ::= AlgorithmIdentifer
+     --   id-it-revPassphrase    OBJECT IDENTIFIER ::= {id-it 12}
+     --      RevPassphraseValue      ::= EncryptedValue
+     --   id-it-implicitConfirm  OBJECT IDENTIFIER ::= {id-it 13}
+     --      ImplicitConfirmValue    ::= NULL
+     --   id-it-confirmWaitTime  OBJECT IDENTIFIER ::= {id-it 14}
+     --      ConfirmWaitTimeValue    ::= GeneralizedTime
+     --   id-it-origPKIMessage   OBJECT IDENTIFIER ::= {id-it 15}
+     --      OrigPKIMessageValue     ::= PKIMessages
+     --   id-it-suppLangTags     OBJECT IDENTIFIER ::= {id-it 16}
+     --      SuppLangTagsValue       ::= SEQUENCE OF UTF8String
+     --
+     -- where
+     --
+     --   id-pkix OBJECT IDENTIFIER ::= {
+     --      iso(1) identified-organization(3)
+     --      dod(6) internet(1) security(5) mechanisms(5) pkix(7)}
+     -- and
+     --   id-it   OBJECT IDENTIFIER ::= {id-pkix 4}
+     --
+     --
+     -- This construct MAY also be used to define new PKIX Certificate
+     -- Management Protocol request and response messages, or general-
+     -- purpose (e.g., announcement) messages for future needs or for
+     -- specific environments.
+
+     GenMsgContent ::= SEQUENCE OF InfoTypeAndValue
+
+     -- May be sent by EE, RA, or CA (depending on message content).
+     -- The OPTIONAL infoValue parameter of InfoTypeAndValue will
+     -- typically be omitted for some of the examples given above.
+     -- The receiver is free to ignore any contained OBJ. IDs that it
+     -- does not recognize. If sent from EE to CA, the empty set
+     -- indicates that the CA may send
+     -- any/all information that it wishes.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 92]
+
+RFC 4210                          CMP                     September 2005
+
+
+     GenRepContent ::= SEQUENCE OF InfoTypeAndValue
+     -- Receiver MAY ignore any contained OIDs that it does not
+     -- recognize.
+
+     ErrorMsgContent ::= SEQUENCE {
+         pKIStatusInfo          PKIStatusInfo,
+         errorCode              INTEGER           OPTIONAL,
+         -- implementation-specific error codes
+         errorDetails           PKIFreeText       OPTIONAL
+         -- implementation-specific error details
+     }
+
+     PollReqContent ::= SEQUENCE OF SEQUENCE {
+         certReqId              INTEGER
+     }
+
+     PollRepContent ::= SEQUENCE OF SEQUENCE {
+         certReqId              INTEGER,
+         checkAfter             INTEGER,  -- time in seconds
+         reason                 PKIFreeText OPTIONAL
+     }
+
+     END -- of CMP module
+
+Appendix G.  Acknowledgements
+
+   The authors gratefully acknowledge the contributions of various
+   members of the IETF PKIX Working Group and the ICSA CA-talk mailing
+   list (a list solely devoted to discussing CMP interoperability
+   efforts).  Many of these contributions significantly clarified and
+   improved the utility of this specification.  Tomi Kause thanks Vesa
+   Suontama and Toni Tammisalo for review and comments.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 93]
+
+RFC 4210                          CMP                     September 2005
+
+
+Authors' Addresses
+
+   Carlisle Adams
+   University of Ottawa
+   800 King Edward Avenue
+   P.O.Box 450, Station A
+   Ottawa, Ontario  K1N 6N5
+   CA
+
+   Phone: (613) 562-5800 ext. 2345
+   Fax:   (613) 562-5664
+   EMail: cadams@site.uottawa.ca
+
+
+   Stephen Farrell
+   Trinity College Dublin
+   Distributed Systems Group
+   Computer Science Department
+   Dublin
+   IE
+
+   Phone: +353-1-608-2945
+   EMail: stephen.farrell@cs.tcd.ie
+
+
+   Tomi Kause
+   SSH Communications Security Corp
+   Valimotie 17
+   Helsinki  00380
+   FI
+
+   Phone: +358 20 500 7415
+   EMail: toka@ssh.com
+
+
+   Tero Mononen
+   SafeNet, Inc.
+   Fredrikinkatu 47
+   Helsinki  00100
+   FI
+
+   Phone: +358 20 500 7814
+   EMail: tmononen@safenet-inc.com
+
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 94]
+
+RFC 4210                          CMP                     September 2005
+
+
+Full Copyright Statement
+
+   Copyright (C) The Internet Society (2005).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
+   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
+   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
+   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at ietf-
+   ipr@ietf.org.
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 95]
+
Index: openssl-1.0.0i-cmp/crypto/cmp/cmp_http.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/cmp_http.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/cmp_http.c	(revision 469)
@@ -0,0 +1,304 @@
+/* crypto/cmp/cmp_http.c
+ * HTTP functions for CMP (RFC 4210) for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ * 6/10/2010 - Martin Peylo - fixed potential harmful sscanf conversion in CMP_PKIMESSAGE_hhtp_bio_recv()
+ * 6/20/2011 - Miikka Viljanen - implemented HTTP transport using libcurl
+ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <string.h>
+#include <openssl/bio.h>
+#include <openssl/err.h>
+#include <openssl/cmp.h>
+
+#include <ctype.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+
+
+#ifdef HAVE_CURL
+
+typedef struct rdata_s {
+	char *memory;
+	size_t size;
+} rdata_t;
+
+static void *myrealloc(void *ptr, size_t size)
+{
+	/* There might be a realloc() out there that doesn't like reallocing
+	 *      NULL pointers, so we take care of it here */ 
+	if(ptr)
+		return realloc(ptr, size);
+	else
+		return calloc(1,size);
+}
+
+static size_t write_data(void *ptr, size_t size, size_t nmemb, void *data)
+{
+	size_t realsize = size * nmemb;
+	struct rdata_s *mem = (struct rdata_s *) data;
+
+	mem->memory = myrealloc(mem->memory, mem->size + realsize + 1);
+	if (mem->memory) {
+		memcpy(&(mem->memory[mem->size]), ptr, realsize);
+		mem->size += realsize;
+		mem->memory[mem->size] = 0;
+	}
+	return realsize;
+}
+
+/* ################################################################ *
+ * In CMP_CTX we have separate variables for server address and path,
+ * but libcurl doesn't have a separate function for just setting the
+ * path. This function simply checks the end of the effective url to
+ * make sure that the correct path is there, and if it's not set yet
+ * it will be added.
+ * ################################################################ */
+static int set_http_path(CURL *curl, const char *path) {
+	char *current_url = NULL, *url = NULL;
+	int pathlen = strlen(path), current_len;
+
+	curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &current_url);
+	if (!current_url)
+		return 0;
+
+	current_len = strlen(current_url);
+	if (!strcmp(&current_url[current_len - pathlen], path))
+		/* path is already set, let's not do it again... */
+		return 1;
+
+	if( !(url = malloc(strlen(current_url) + strlen(path) + 2)))
+		return 0;
+
+	sprintf(url, "%s/%s", current_url, path);
+	curl_easy_setopt(curl, CURLOPT_URL, url);
+	free(url);
+
+	return 1;
+}
+
+/* ################################################################ *
+ * Create a new http connection, with a specified source ip/interface
+ * ################################################################ */
+int CMP_new_http_bio_ex( CMPBIO **bio, const char* serverAddress, const int port, const char *srcip) {
+	struct curl_slist *slist=NULL;
+	CURL *curl;
+	
+	static int curl_initialized = 0;
+	if (curl_initialized == 0) {
+		curl_initialized =  1;
+		curl_global_init(CURL_GLOBAL_ALL);
+	}
+
+	if (!(curl=curl_easy_init())) goto err;
+
+	slist = curl_slist_append(slist, "Content-Type: application/pkixcmp");
+	slist = curl_slist_append(slist, "Cache-control: no-cache");
+	slist = curl_slist_append(slist, "Expect:"); 
+	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, slist);
+	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
+	if (srcip != NULL)
+		curl_easy_setopt(curl, CURLOPT_INTERFACE, srcip);
+
+	curl_easy_setopt(curl, CURLOPT_URL, serverAddress);
+	curl_easy_setopt(curl, CURLOPT_PORT, port);
+
+	curl_easy_setopt(curl, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
+
+	/* curl will automatically try to get proxy from environment if we don't set this.
+	 * if proxy use is enabled, it will be set in CMP_PKIMESSAGE_http_perform. */
+	/* XXX what's the correct thing to do, should we take proxy from env or not? */
+	curl_easy_setopt(curl, CURLOPT_PROXY, "");
+
+	*bio = curl;
+	return 1;
+
+err:
+	CMPerr(CMP_F_CMP_NEW_HTTP_BIO_EX, CMP_R_CURL_ERROR);
+	return 0;
+}
+
+int CMP_new_http_bio( CMPBIO **cbio, const char* serverName, const int port) {
+	return CMP_new_http_bio_ex(cbio, serverName, port, NULL);
+}
+
+int CMP_delete_http_bio( CMPBIO *cbio) {
+	curl_easy_cleanup(cbio);
+	return 1;
+}
+
+/* ################################################################ *
+ * Send the given PKIMessage msg and place the response in *out.
+ * ################################################################ */
+int CMP_PKIMESSAGE_http_perform(CMPBIO *curl, const CMP_CTX *ctx, 
+								const CMP_PKIMESSAGE *msg,
+								CMP_PKIMESSAGE **out)
+{
+	unsigned char *derMsg = NULL, *pder = NULL;
+	char *errormsg = NULL;
+	char *content_type = NULL;
+	int derLen = 0;
+	CURLcode res;
+	rdata_t rdata = {0,0};
+
+	if (!curl || !ctx || !msg || !out) {
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_NULL_ARGUMENT);
+		return 0;
+	}
+
+	if (!ctx->serverName || !ctx->serverPath || ctx->serverPort == 0) {
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_NULL_ARGUMENT);
+		return 0;
+	}
+
+	derLen = i2d_CMP_PKIMESSAGE( (CMP_PKIMESSAGE*) msg, &derMsg);
+
+	if (ctx->proxyName && ctx->proxyPort) {
+		curl_easy_setopt(curl, CURLOPT_PROXY, ctx->proxyName);
+		curl_easy_setopt(curl, CURLOPT_PROXYPORT, ctx->proxyPort);
+	}
+
+	set_http_path(curl, ctx->serverPath);
+
+	/* curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0); */
+
+	/* rdata will contain the data received from the server */
+	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&rdata);
+
+	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, (void*) derMsg);
+	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, derLen);
+	if (ctx->timeOut != 0)
+		curl_easy_setopt(curl, CURLOPT_TIMEOUT, ctx->timeOut);
+
+	res = curl_easy_perform(curl);
+
+	/* free up sent DER message from memory */
+	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, (void*) 0);
+	free(derMsg);
+
+	if (   res == CURLE_COULDNT_CONNECT
+		|| res == CURLE_COULDNT_RESOLVE_PROXY
+		|| res == CURLE_COULDNT_RESOLVE_HOST
+		|| res == CURLE_SEND_ERROR
+		|| res == CURLE_RECV_ERROR
+		|| res == CURLE_OPERATION_TIMEDOUT
+		|| res == CURLE_INTERFACE_FAILED)
+    {
+        CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_SERVER_NOT_REACHABLE);
+        char num[64];
+        snprintf(num, sizeof(num)-1, "%d:", res);
+        ERR_add_error_data(2, num, curl_easy_strerror(res));
+        return 0;
+    }
+	else if (res != CURLE_OK) {
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_CURL_ERROR);
+        char num[64];
+        snprintf(num, sizeof(num)-1, "%d:", res);
+        ERR_add_error_data(2, num, curl_easy_strerror(res));
+		return 0;
+	}
+
+	/* verify that Content-type is application/pkixcmp */
+	curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &content_type);
+	if (content_type == NULL || strcmp(content_type, "application/pkixcmp") != 0) {
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_INVALID_CONTENT_TYPE);
+		free(errormsg);
+		free(rdata.memory);
+		return 0;
+	}
+
+	pder = (unsigned char*) rdata.memory;
+    *out = d2i_CMP_PKIMESSAGE( NULL, (const unsigned char**) &pder, rdata.size);
+    if (*out == 0) {
+		CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM, CMP_R_FAILED_TO_DECODE_PKIMESSAGE);
+		free(rdata.memory);
+		return 0;
+	}
+
+	free(rdata.memory);
+	return 1;
+}
+
+int CMP_PKIMESSAGE_http_bio_send(CMPBIO *cbio, CMP_CTX *ctx,
+								 const CMP_PKIMESSAGE *msg) {
+	CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_BIO_SEND, CMP_R_DEPRECATED_FUNCTION);
+	return 0;
+}
+
+int CMP_PKIMESSAGE_http_bio_recv( CMPBIO *cbio, CMP_CTX *ctx,
+				  CMP_PKIMESSAGE **ip) {
+	CMPerr(CMP_F_CMP_PKIMESSAGE_HTTP_BIO_RECV, CMP_R_DEPRECATED_FUNCTION);
+	return 0;
+}
+
+#endif
+
Index: openssl-1.0.0i-cmp/crypto/cmp/CMP_http.pod
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/CMP_http.pod	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/CMP_http.pod	(revision 469)
@@ -0,0 +1,79 @@
+=pod
+
+=head1 NAME
+
+ CMP_new_http_bio
+
+=head1 SYNOPSIS
+
+ #include <openssl/cmp.h>
+
+ int CMP_new_http_bio(CMBIO **cbio, const char* serverName, const int port);
+ int CMP_new_http_bio_ex(CMBIO **cbio, const char* serverName, const int port, const char *srcip);
+ int CMP_PKIMESSAGE_http_perform(CMPBIO *curl, const CMP_CTX *ctx, const CMP_PKIMESSAGE *msg, CMP_PKIMESSAGE **out);
+
+=head1 DESCRIPTION
+
+This is the API for creating a BIO for CMP (Certificate Management
+Protocol) over HTTP with OpenSSL.
+
+CMP_new_http_bio() opens a OpenSSL BIO to communicate with the server.
+
+CMP_new_http_bio_ex() opens a OpenSSL BIO to communicate with the
+server, with one additional argument to specify the source interface
+address.
+
+CMP_PKIMESSAGE_http_perform() sends the given pkimessage msg through
+given connection, and returns the servers response in out.
+
+=head1 NOTES
+
+CMP is defined in RFC 4210 (and CRMF in RFC 4211).
+
+The implementation of CMP for OpenSSL is still work in progress. The API
+might change every release!
+
+=head1 RETURN VALUES
+
+CMP_new_http_bio() returns 0 on error, 1 on success.
+
+CMP_new_http_bio_ex() returns 0 on error, 1 on success.
+
+=head1 EXAMPLE
+
+The following code does an Initial Request:
+
+	cmp_ctx = CMP_CTX_create();
+	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
+	CMP_CTX_set1_referenceValue( cmp_ctx, idString, idStringLen);
+	CMP_CTX_set1_secretValue( cmp_ctx, password, passwordLen);
+	CMP_CTX_set0_newPkey( cmp_ctx, initialPkey);
+	CMP_CTX_set1_caCert( cmp_ctx, caCert);
+
+	CMP_new_http_bio( &cbio, opt_serverName, opt_serverPort);
+
+	initialClCert = CMP_doInitialRequestSeq( cbio, cmp_ctx);
+	BIO_free(cbio);
+
+
+The following code does an Key Update Request:
+
+	cmp_ctx = CMP_CTX_create();
+	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
+	CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
+	CMP_CTX_set0_newPkey( cmp_ctx, updatedPkey);
+	CMP_CTX_set1_clCert( cmp_ctx, initialClCert);
+	CMP_CTX_set1_caCert( cmp_ctx, caCert);
+
+	CMP_new_http_bio( &cbio, opt_serverName, opt_serverPort);
+
+	updatedClCert = CMP_doKeyUpdateRequestSeq( cbio, cmp_ctx);
+	BIO_free(cbio);
+
+=head1 TODO
+
+Replace the HTTP impelementation with a library such as libcurl.
+
+=head1 SEE ALSO
+
+CMP_CTX, CMP_session
Index: openssl-1.0.0i-cmp/crypto/cmp/cmp_asn.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/cmp_asn.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/cmp_asn.c	(revision 469)
@@ -0,0 +1,418 @@
+/* cmp_asn.c
+ * OpenSSL ASN.1 definitions for CMP (RFC 4210)
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/cmp.h>
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L 
+#include <openssl/ts.h>
+#else
+ASN1_SEQUENCE(ESS_ISSUERSERIAL) = {
+	ASN1_SEQUENCE_OF(ESS_ISSUERSERIAL, issuer, GENERAL_NAME),
+	ASN1_SIMPLE(ESS_ISSUERSERIAL, serialNumber, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(ESS_ISSUERSERIAL)
+IMPLEMENT_ASN1_FUNCTIONS(ESS_ISSUERSERIAL)
+
+ASN1_SEQUENCE(ESS_CERT_ID) = {
+	ASN1_SIMPLE(ESS_CERT_ID, hash, ASN1_OCTET_STRING),
+	ASN1_OPT(ESS_CERT_ID, issuerSerial, ESS_ISSUERSERIAL)
+} ASN1_SEQUENCE_END(ESS_CERT_ID)
+IMPLEMENT_ASN1_FUNCTIONS(ESS_CERT_ID)
+
+ASN1_SEQUENCE(ESS_SIGNING_CERT) = {
+	ASN1_SEQUENCE_OF(ESS_SIGNING_CERT, cert_ids, ESS_CERT_ID),
+	ASN1_SEQUENCE_OF_OPT(ESS_SIGNING_CERT, policies, POLICYINFO)
+} ASN1_SEQUENCE_END(ESS_SIGNING_CERT)
+IMPLEMENT_ASN1_FUNCTIONS(ESS_SIGNING_CERT)
+
+#endif
+
+ASN1_SEQUENCE(CMP_REVANNCONTENT) = {
+	ASN1_SIMPLE(CMP_REVANNCONTENT, status, ASN1_INTEGER),
+	ASN1_SIMPLE(CMP_REVANNCONTENT, certId, CRMF_CERTID),
+	ASN1_SIMPLE(CMP_REVANNCONTENT, willBeRevokedAt, ASN1_GENERALIZEDTIME),
+	ASN1_SIMPLE(CMP_REVANNCONTENT, badSinceDate, ASN1_GENERALIZEDTIME),
+	ASN1_EXP_SEQUENCE_OF_OPT(CMP_REVANNCONTENT, crlDetails, X509_EXTENSION,0)
+} ASN1_SEQUENCE_END(CMP_REVANNCONTENT)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_REVANNCONTENT)
+
+
+ASN1_SEQUENCE(CMP_CHALLENGE) = {
+	/* XXX EXP ...? */
+	ASN1_OPT(CMP_CHALLENGE, owf, X509_ALGOR),
+	ASN1_SIMPLE(CMP_CHALLENGE, whitness, ASN1_OCTET_STRING),
+	ASN1_SIMPLE(CMP_CHALLENGE, challenge, ASN1_OCTET_STRING)
+} ASN1_SEQUENCE_END(CMP_CHALLENGE)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_CHALLENGE)
+
+
+ASN1_SEQUENCE(CMP_CAKEYUPDANNCONTENT) = {
+#if 0
+/* the rfc allows substituting CMPCertificate with "Certificate"... */
+	ASN1_SIMPLE(CMP_CAKEYUPDANNCONTENT, oldWithNew, CMP_CMPCERTIFICATE),
+	ASN1_SIMPLE(CMP_CAKEYUPDANNCONTENT, newWithOld, CMP_CMPCERTIFICATE),
+	ASN1_SIMPLE(CMP_CAKEYUPDANNCONTENT, newWithNew, CMP_CMPCERTIFICATE)
+#endif
+	ASN1_SIMPLE(CMP_CAKEYUPDANNCONTENT, oldWithNew, X509),
+	ASN1_SIMPLE(CMP_CAKEYUPDANNCONTENT, newWithOld, X509),
+	ASN1_SIMPLE(CMP_CAKEYUPDANNCONTENT, newWithNew, X509)
+} ASN1_SEQUENCE_END(CMP_CAKEYUPDANNCONTENT)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_CAKEYUPDANNCONTENT)
+
+
+ASN1_SEQUENCE(CMP_ERRORMSGCONTENT) = {
+	ASN1_SIMPLE(CMP_ERRORMSGCONTENT, pKIStatusInfo, CMP_PKISTATUSINFO),
+	ASN1_OPT(CMP_ERRORMSGCONTENT, errorCode, ASN1_INTEGER),
+#if 0
+	ASN1_OPT(CMP_ERRORMSGCONTENT, errorDetails, CMP_PKIFREETEXT)
+#endif
+	ASN1_SEQUENCE_OF_OPT(CMP_ERRORMSGCONTENT, errorDetails, ASN1_UTF8STRING)
+} ASN1_SEQUENCE_END(CMP_ERRORMSGCONTENT)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_ERRORMSGCONTENT)
+
+#if 0
+/* XXX USING THAT DOES NOT WORK FOR SOME REASON */
+/* the rfc allows substituting that with "Certificate"... */
+ASN1_CHOICE(CMP_CMPCERTIFICATE) = {
+	ASN1_SIMPLE(CMP_CMPCERTIFICATE, value.x509v3PKCert, X509)
+} ASN1_CHOICE_END(CMP_CMPCERTIFICATE)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_CMPCERTIFICATE)
+#endif
+
+#if 0
+ASN1_SEQUENCE(CMP_INFOTYPEANDVALUE) = {
+	ASN1_SIMPLE(CMP_INFOTYPEANDVALUE, infoType, ASN1_OBJECT),
+	ASN1_OPT(CMP_INFOTYPEANDVALUE, infoValue, ASN1_ANY)
+} ASN1_SEQUENCE_END(CMP_INFOTYPEANDVALUE)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_INFOTYPEANDVALUE)
+#endif
+
+ASN1_ADB_TEMPLATE(infotypeandvalue_default) = ASN1_OPT(CMP_INFOTYPEANDVALUE, infoValue.other, ASN1_ANY);
+ASN1_ADB(CMP_INFOTYPEANDVALUE) = {
+	ADB_ENTRY(NID_id_it_caProtEncCert,    ASN1_SIMPLE(CMP_INFOTYPEANDVALUE,      infoValue.caProtEncCert,    X509)),
+	ADB_ENTRY(NID_id_it_signKeyPairTypes, ASN1_SEQUENCE_OF(CMP_INFOTYPEANDVALUE, infoValue.signKeyPairTypes, X509_ALGOR)),
+	ADB_ENTRY(NID_id_it_encKeyPairTypes,  ASN1_SEQUENCE_OF(CMP_INFOTYPEANDVALUE, infoValue.encKeyPairTypes,  X509_ALGOR)),
+	ADB_ENTRY(NID_id_it_preferredSymmAlg, ASN1_SIMPLE(CMP_INFOTYPEANDVALUE,      infoValue.preferredSymmAlg, X509_ALGOR)),
+	// ADB_ENTRY(NID_id_it_caKeyUpdateInfo,  ASN1_SIMPLE(CMP_INFOTYPEANDVALUE,      infoValue.caKeyUpdateInfo,  CMP_CAKEYUPDANNCONTENT)),
+	/* XXX this is made opt in order to make it possible to request a CKUANN with an      empty caKeyUpdateInfo value */
+	ADB_ENTRY(NID_id_it_caKeyUpdateInfo, ASN1_OPT(CMP_INFOTYPEANDVALUE,         infoValue.caKeyUpdateInfo, CMP_CAKEYUPDANNCONTENT)),
+	ADB_ENTRY(NID_id_it_currentCRL,      ASN1_OPT(CMP_INFOTYPEANDVALUE,         infoValue.currentCRL,      X509_CRL)),
+	ADB_ENTRY(NID_id_it_unsupportedOIDs, ASN1_SEQUENCE_OF(CMP_INFOTYPEANDVALUE, infoValue.unsupportedOIDs, ASN1_OBJECT)),
+	ADB_ENTRY(NID_id_it_keyPairParamReq, ASN1_SIMPLE(CMP_INFOTYPEANDVALUE,      infoValue.keyPairParamReq, ASN1_OBJECT)),
+	ADB_ENTRY(NID_id_it_keyPairParamRep, ASN1_SIMPLE(CMP_INFOTYPEANDVALUE,      infoValue.keyPairParamRep, X509_ALGOR)),
+	ADB_ENTRY(NID_id_it_revPassphrase,   ASN1_SIMPLE(CMP_INFOTYPEANDVALUE,      infoValue.revPassphrase,   CRMF_ENCRYPTEDVALUE)),
+	ADB_ENTRY(NID_id_it_implicitConfirm, ASN1_SIMPLE(CMP_INFOTYPEANDVALUE,      infoValue.implicitConfirm, ASN1_NULL)),
+	ADB_ENTRY(NID_id_it_confirmWaitTime, ASN1_SIMPLE(CMP_INFOTYPEANDVALUE,      infoValue.confirmWaitTime, ASN1_GENERALIZEDTIME)),
+	ADB_ENTRY(NID_id_it_origPKIMessage,  ASN1_SIMPLE(CMP_INFOTYPEANDVALUE,      infoValue.origPKIMessage,  CMP_PKIMESSAGE)),
+
+	ADB_ENTRY(NID_id_smime_aa_signingCertificate, ASN1_SET_OF(CMP_INFOTYPEANDVALUE, infoValue.signingCertificate, ESS_SIGNING_CERT))
+	// ADB_ENTRY(NID_id_smime_aa_signingCertificate, ASN1_SIMPLE(CMP_INFOTYPEANDVALUE, infoValue.signingCertificate, ESS_SIGNING_CERT))
+} ASN1_ADB_END(CMP_INFOTYPEANDVALUE, 0, infoType, 0, &infotypeandvalue_default_tt, NULL);
+
+
+ASN1_SEQUENCE(CMP_INFOTYPEANDVALUE) = {
+	ASN1_SIMPLE(CMP_INFOTYPEANDVALUE, infoType, ASN1_OBJECT),
+	ASN1_ADB_OBJECT(CMP_INFOTYPEANDVALUE)
+} ASN1_SEQUENCE_END(CMP_INFOTYPEANDVALUE)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_INFOTYPEANDVALUE)
+
+
+ASN1_CHOICE(CMP_CERTORENCCERT) = {
+#if 0
+	ASN1_EXP(CMP_CERTORENCCERT, value.certificate, CMP_CMPCERTIFICATE, 0),
+#endif
+	ASN1_EXP(CMP_CERTORENCCERT, value.certificate, X509, 0),
+	ASN1_EXP(CMP_CERTORENCCERT, value.encryptedCert, CRMF_ENCRYPTEDVALUE, 1),
+} ASN1_CHOICE_END(CMP_CERTORENCCERT)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_CERTORENCCERT)
+
+
+ASN1_SEQUENCE(CMP_CERTIFIEDKEYPAIR) = {
+	ASN1_SIMPLE(CMP_CERTIFIEDKEYPAIR, certOrEncCert, CMP_CERTORENCCERT),
+	ASN1_EXP_OPT(CMP_CERTIFIEDKEYPAIR, privateKey, CRMF_ENCRYPTEDVALUE,0),
+	ASN1_EXP_OPT(CMP_CERTIFIEDKEYPAIR, failInfo, CRMF_PKIPUBLICATIONINFO,1)
+} ASN1_SEQUENCE_END(CMP_CERTIFIEDKEYPAIR)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_CERTIFIEDKEYPAIR)
+
+
+ASN1_SEQUENCE(CMP_REVDETAILS) = {
+	ASN1_SIMPLE(CMP_REVDETAILS, certDetails, CRMF_CERTTEMPLATE),
+	ASN1_OPT(CMP_REVDETAILS, crlEntryDetails, X509_EXTENSION)
+} ASN1_SEQUENCE_END(CMP_REVDETAILS)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_REVDETAILS)
+
+ASN1_SEQUENCE(CMP_REVREP) = {
+	// ASN1_EXP_SEQUENCE_OF(CMP_REVREP, status, CMP_PKISTATUSINFO,0),
+	ASN1_SEQUENCE_OF(CMP_REVREP, status, CMP_PKISTATUSINFO),
+	ASN1_EXP_SEQUENCE_OF_OPT(CMP_REVREP, certId, CRMF_CERTID, 0),
+	ASN1_EXP_SEQUENCE_OF_OPT(CMP_REVREP, crls,   X509, 1)
+} ASN1_SEQUENCE_END(CMP_REVREP)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_REVREP)
+
+
+ASN1_SEQUENCE(CMP_KEYRECREPCONTENT) = {
+	ASN1_SIMPLE(CMP_KEYRECREPCONTENT, status, CMP_PKISTATUSINFO),
+	/* XXX CMPcertificate ::= Certificate */
+	ASN1_EXP_OPT(CMP_KEYRECREPCONTENT, newSigCert, X509, 0),
+	/* XXX CMPcertificate ::= Certificate */
+	ASN1_EXP_SEQUENCE_OF_OPT(CMP_KEYRECREPCONTENT, caCerts, X509, 1),
+	ASN1_EXP_SEQUENCE_OF_OPT(CMP_KEYRECREPCONTENT, keyPairHist, X509, 2)
+} ASN1_SEQUENCE_END(CMP_KEYRECREPCONTENT)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_KEYRECREPCONTENT)
+
+
+ASN1_ITEM_TEMPLATE(CMP_PKISTATUS) =
+	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_UNIVERSAL, 0, status, ASN1_INTEGER)
+ASN1_ITEM_TEMPLATE_END(CMP_PKISTATUS)
+
+ASN1_SEQUENCE(CMP_PKISTATUSINFO) = {
+	ASN1_SIMPLE(CMP_PKISTATUSINFO, status, CMP_PKISTATUS),
+
+#if 0
+	ASN1_OPT(CMP_PKISTATUSINFO, statusString, CMP_PKIFREETEXT),
+#endif
+	ASN1_SEQUENCE_OF_OPT(CMP_PKISTATUSINFO, statusString, ASN1_UTF8STRING),
+/* XXX this should actually be */
+#if 0
+	ASN1_OPT(CMP_PKISTATUSINFO, failInfo, CMP_PKIFAILUREINFO)
+#endif
+	ASN1_OPT(CMP_PKISTATUSINFO, failInfo, ASN1_BIT_STRING)
+} ASN1_SEQUENCE_END(CMP_PKISTATUSINFO)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_PKISTATUSINFO)
+
+
+ASN1_SEQUENCE(CMP_CERTSTATUS) = {
+	ASN1_SIMPLE(CMP_CERTSTATUS, certHash, ASN1_OCTET_STRING),
+	ASN1_SIMPLE(CMP_CERTSTATUS, certReqId, ASN1_INTEGER),
+	ASN1_OPT(CMP_CERTSTATUS, statusInfo, CMP_PKISTATUSINFO)
+} ASN1_SEQUENCE_END(CMP_CERTSTATUS)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_CERTSTATUS)
+
+/* TODO the PKCS10 structures need to be tested */
+ASN1_SEQUENCE(PKCS10_ATTRIBUTE) = {
+	ASN1_SIMPLE(PKCS10_ATTRIBUTE, id, ASN1_OBJECT),
+	ASN1_SEQUENCE_OF(PKCS10_ATTRIBUTE, values, ASN1_ANY),
+} ASN1_SEQUENCE_END(PKCS10_ATTRIBUTE)
+IMPLEMENT_ASN1_FUNCTIONS(PKCS10_ATTRIBUTE)
+
+ASN1_SEQUENCE(PKCS10_CERTIFICATIONREQUESTINFO) = {
+	ASN1_SIMPLE(PKCS10_CERTIFICATIONREQUESTINFO, version, ASN1_INTEGER),
+	ASN1_SIMPLE(PKCS10_CERTIFICATIONREQUESTINFO, subject, X509_NAME),
+	ASN1_SIMPLE(PKCS10_CERTIFICATIONREQUESTINFO, subjectPKInfo, X509_PUBKEY),
+	ASN1_IMP_SET_OF(PKCS10_CERTIFICATIONREQUESTINFO, attributes, PKCS10_ATTRIBUTE, 0),
+} ASN1_SEQUENCE_END(PKCS10_CERTIFICATIONREQUESTINFO)
+IMPLEMENT_ASN1_FUNCTIONS(PKCS10_CERTIFICATIONREQUESTINFO)
+
+ASN1_SEQUENCE(PKCS10_CERTIFICATIONREQUEST) = {
+	ASN1_SIMPLE(PKCS10_CERTIFICATIONREQUEST, certificationRequestInfo, PKCS10_CERTIFICATIONREQUESTINFO),
+	ASN1_SIMPLE(PKCS10_CERTIFICATIONREQUEST, signatureAlgorithm, X509_ALGOR),
+	ASN1_SIMPLE(PKCS10_CERTIFICATIONREQUEST, signature, ASN1_BIT_STRING),
+} ASN1_SEQUENCE_END(PKCS10_CERTIFICATIONREQUEST)
+IMPLEMENT_ASN1_FUNCTIONS(PKCS10_CERTIFICATIONREQUEST)
+
+#if 0
+/* XXX is this OK? what is "0" for? */
+ASN1_ITEM_TEMPLATE(CMP_CERTCONFIRMCONTENT) =
+/* XXX is EXPTAG ok? */
+	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_EXPTAG, 0, CMP_CERTCONFIRMCONTENT, CMP_CERTSTATUS)
+ASN1_ITEM_TEMPLATE_END(CMP_CERTCONFIRMCONTENT)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_CERTCONFIRMCONTENT)
+#endif
+
+
+ASN1_SEQUENCE(CMP_CERTRESPONSE) = {
+	ASN1_SIMPLE(CMP_CERTRESPONSE, certReqId, ASN1_INTEGER),
+	ASN1_SIMPLE(CMP_CERTRESPONSE, status, CMP_PKISTATUSINFO),
+	ASN1_OPT(CMP_CERTRESPONSE, certifiedKeyPair, CMP_CERTIFIEDKEYPAIR),
+	ASN1_OPT(CMP_CERTRESPONSE, rspInfo, ASN1_OCTET_STRING)
+} ASN1_SEQUENCE_END(CMP_CERTRESPONSE)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_CERTRESPONSE)
+
+ASN1_SEQUENCE(CMP_POLLREQ) = {
+	ASN1_SIMPLE(CMP_POLLREQ, certReqId, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(CMP_POLLREQ)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_POLLREQ)
+
+ASN1_SEQUENCE(CMP_POLLREP) = {
+	ASN1_SIMPLE(CMP_POLLREP, certReqId, ASN1_INTEGER),
+	ASN1_SIMPLE(CMP_POLLREP, checkAfter, ASN1_INTEGER),
+	ASN1_SEQUENCE_OF_OPT(CMP_POLLREP, reason, ASN1_UTF8STRING),
+} ASN1_SEQUENCE_END(CMP_POLLREP)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_POLLREP)
+
+ASN1_SEQUENCE(CMP_CERTREPMESSAGE) = {
+	//ASN1_EXP_SEQUENCE_OF_OPT(CMP_CERTREPMESSAGE, caPubs, CMP_CMPCERTIFICATE,1),
+	ASN1_EXP_SEQUENCE_OF_OPT(CMP_CERTREPMESSAGE, caPubs, X509,1),
+	ASN1_SEQUENCE_OF(CMP_CERTREPMESSAGE, response, CMP_CERTRESPONSE)
+} ASN1_SEQUENCE_END(CMP_CERTREPMESSAGE)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_CERTREPMESSAGE)
+
+
+ASN1_CHOICE(CMP_PKIBODY) = {
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.ir, CRMF_CERTREQMSG, 0),
+	ASN1_EXP(CMP_PKIBODY, value.ip, CMP_CERTREPMESSAGE, 1),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.cr, CRMF_CERTREQMSG, 2),
+	ASN1_EXP(CMP_PKIBODY, value.cp, CMP_CERTREPMESSAGE, 3),
+	ASN1_EXP(CMP_PKIBODY, value.p10cr, PKCS10_CERTIFICATIONREQUEST, 4),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.popdecc, CMP_CHALLENGE, 5),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.popdecr, ASN1_INTEGER, 6),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.kur, CRMF_CERTREQMSG, 7),
+	ASN1_EXP(CMP_PKIBODY, value.kup, CMP_CERTREPMESSAGE, 8),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.krr, CRMF_CERTREQMSG, 9),
+	ASN1_EXP(CMP_PKIBODY, value.krp, CMP_KEYRECREPCONTENT, 10),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.rr, CMP_REVDETAILS, 11),
+	ASN1_EXP(CMP_PKIBODY, value.rp, CMP_REVREP, 12),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.crr, CRMF_CERTREQMSG, 13),
+	ASN1_EXP(CMP_PKIBODY, value.ccp, CMP_CERTREPMESSAGE, 14),
+	ASN1_EXP(CMP_PKIBODY, value.ckuann, CMP_CAKEYUPDANNCONTENT, 15),
+	ASN1_EXP(CMP_PKIBODY, value.cann, X509, 16),
+	ASN1_EXP(CMP_PKIBODY, value.rann, CMP_REVANNCONTENT, 17),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.crlann, X509_CRL, 18),
+#if 0
+	/* CMP_PKICONFIRMCONTENT would be only a typedfef of ASN1_NULL */
+	/* ASN1_EXP(CMP_PKIBODY, value.pkiconf, CMP_PKICONFIRMCONTENT, 19), */
+	/* XXX it should be the following according to the RFC but CL puts it in a struct */
+	ASN1_EXP(CMP_PKIBODY, value.pkiconf, ASN1_NULL, 19),
+#endif
+	ASN1_EXP(CMP_PKIBODY, value.pkiconf, ASN1_ANY, 19),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.nested, CMP_PKIMESSAGE, 20),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.genm, CMP_INFOTYPEANDVALUE, 21),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.genp, CMP_INFOTYPEANDVALUE, 22),
+	ASN1_EXP(CMP_PKIBODY, value.error, CMP_ERRORMSGCONTENT, 23),
+	/* XXX this should actually be: */
+#if 0
+	ASN1_EXP(CMP_PKIBODY, value.certConf, CMP_CERTCONFIRMCONTENT, 24)
+#endif
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.certConf, CMP_CERTSTATUS, 24),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.pollReq, CMP_POLLREQ, 25),
+	ASN1_EXP_SEQUENCE_OF(CMP_PKIBODY, value.pollRep, CMP_POLLREP, 26),
+} ASN1_CHOICE_END(CMP_PKIBODY)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_PKIBODY)
+
+#if 0
+XXX this does not work
+/* XXX this comes from just a typedef */
+IMPLEMENT_ASN1_FUNCTIONS(XXX_KEYIDENTIFIER)
+#endif
+
+#if 0
+ASN1_ITEM_TEMPLATE(CMP_PKIFREETEXT) =
+	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, PKIFreeText, ASN1_UTF8STRING)
+	ASN1_ITEM_TEMPLATE_END(CMP_PKIFREETEXT)
+
+IMPLEMENT_ASN1_FUNCTIONS(CMP_PKIFREETEXT)
+#endif
+
+
+ASN1_SEQUENCE(CMP_PKIHEADER) = {
+	ASN1_SIMPLE(CMP_PKIHEADER, pvno, ASN1_INTEGER),
+	ASN1_SIMPLE(CMP_PKIHEADER, sender, GENERAL_NAME),
+	ASN1_SIMPLE(CMP_PKIHEADER, recipient, GENERAL_NAME),
+	ASN1_EXP_OPT(CMP_PKIHEADER, messageTime, ASN1_GENERALIZEDTIME,0),
+	ASN1_EXP_OPT(CMP_PKIHEADER, protectionAlg, X509_ALGOR,1),
+	ASN1_EXP_OPT(CMP_PKIHEADER, senderKID, ASN1_OCTET_STRING,2),
+	ASN1_EXP_OPT(CMP_PKIHEADER, recipKID, ASN1_OCTET_STRING,3),
+	ASN1_EXP_OPT(CMP_PKIHEADER, transactionID, ASN1_OCTET_STRING,4),
+	ASN1_EXP_OPT(CMP_PKIHEADER, senderNonce, ASN1_OCTET_STRING,5),
+	ASN1_EXP_OPT(CMP_PKIHEADER, recipNonce, ASN1_OCTET_STRING,6),
+#if 0
+	ASN1_EXP_OPT(CMP_PKIHEADER, freeText, CMP_PKIFREETEXT,7),
+#endif
+	ASN1_EXP_SEQUENCE_OF_OPT(CMP_PKIHEADER, freeText, ASN1_UTF8STRING,7),
+	ASN1_EXP_SEQUENCE_OF_OPT(CMP_PKIHEADER, generalInfo, CMP_INFOTYPEANDVALUE,8)
+} ASN1_SEQUENCE_END(CMP_PKIHEADER)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_PKIHEADER)
+
+ASN1_SEQUENCE(CMP_PROTECTEDPART) = {
+	ASN1_SIMPLE(CMP_PKIMESSAGE, header, CMP_PKIHEADER),
+	ASN1_SIMPLE(CMP_PKIMESSAGE, body, CMP_PKIBODY)
+} ASN1_SEQUENCE_END(CMP_PROTECTEDPART)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_PROTECTEDPART);
+
+ASN1_SEQUENCE(CMP_PKIMESSAGE) = {
+	ASN1_SIMPLE(CMP_PKIMESSAGE, header, CMP_PKIHEADER),
+	ASN1_SIMPLE(CMP_PKIMESSAGE, body, CMP_PKIBODY),
+	/* IMP OR EXP? */
+	ASN1_EXP_OPT(CMP_PKIMESSAGE, protection, ASN1_BIT_STRING,0),
+	/*ASN1_EXP_SEQUENCE_OF_OPT(CMP_PKIMESSAGE, extraCerts, CMP_CMPCERTIFICATE,1)*/
+	ASN1_EXP_SEQUENCE_OF_OPT(CMP_PKIMESSAGE, extraCerts, X509,1)
+} ASN1_SEQUENCE_END(CMP_PKIMESSAGE)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_PKIMESSAGE)
+
+
+/* XXX is this OK? what is "0" for? */
+ASN1_ITEM_TEMPLATE(CMP_PKIMESSAGES) =
+/* XXX is EXPTAG ok? */
+ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_EXPTAG, 0, CMP_PKIMESSAGES, CMP_PKIMESSAGE)
+ASN1_ITEM_TEMPLATE_END(CMP_PKIMESSAGES)
+
+
Index: openssl-1.0.0i-cmp/crypto/cmp/CMP_session.pod
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/CMP_session.pod	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/CMP_session.pod	(revision 469)
@@ -0,0 +1,61 @@
+=pod
+
+=head1 NAME
+
+ CMP_doInitialRequestSeq,
+ CMP_doKeyUpdateRequestSeq,
+
+=head1 SYNOPSIS
+
+ #include <openssl/cmp.h>
+
+ X509 *CMP_doInitialRequestSeq( BIO *cbio, CMP_CTX *ctx);
+ X509 *CMP_doKeyUpdateRequestSeq( BIO *cbio, CMP_CTX *ctx);
+ X509 *CMP_doCertificateRequestSeq( BIO *cbio, CMP_CTX *ctx);
+ int CMP_doPKIInfoReqSeq( BIO *cbio, CMP_CTX *ctx);
+
+=head1 DESCRIPTION
+
+This is the API for doing client-server sequences using CMP (Certificate
+Management Protocol) with OpenSSL. The conveying protocol is HTTP for
+now.
+
+CMP_doInitialRequestSeq() does the sequence which obtains an initial
+certificate from the CA. An initialized BIO and a populated CMP_CTX
+structure have to be given as arguments.
+
+CMP_doKeyUpdateRequestSeq() does the sequence which obains a certificate
+for an updatded key from the CA. An initialized BIO and a populated
+CMP_CTX structure have to be given as arguments.
+
+CMP_doCertificateRequestSeq() requests an additional certificate for an
+existing key from the CA. An initialized BIO and a populated CMP_CTX
+structure have to be given as arguments.
+
+CMP_doPKIInfoReqSeq() requests information about the current status of a
+CA.
+
+=head1 NOTES
+
+CMP is defined in RFC 4210 (and CRMF in RFC 4211).
+
+The implementation of CMP for OpenSSL is still work in progress. The API
+might change every release!
+
+=head1 RETURN VALUES
+
+CMP_doInitialRequestSeq() and CMP_doKeyUpdateRequestSeq() return a
+pointer the newly obtained X509 certificate on success, NULL on error.
+
+=head1 EXAMPLE
+
+See CMP_CTX for examples on how to prepare the context for these
+functions.
+
+=head1 TODO
+
+A lot!
+
+=head1 SEE ALSO
+
+CMP_CTX, CMP_http
Index: openssl-1.0.0i-cmp/crypto/cmp/cmp.h
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/cmp.h	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/cmp.h	(revision 469)
@@ -0,0 +1,1694 @@
+/* cmp.h
+ * CMP (RFC 4210) header file for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ * 2008 - Sami Lehtonen - added CMP_cr_new() and CMP_doCertificateRequestSeq()
+ *                        declarations
+ * 2010 - Miikka viljanen - Added error code list
+ */
+
+#ifndef HEADER_CMP_H
+#define HEADER_CMP_H
+
+#include <openssl/ossl_typ.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/safestack.h>
+
+#ifdef HAVE_CURL
+#include <curl/curl.h>
+#endif
+
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L 
+#include <openssl/ts.h>
+#else
+
+typedef struct ess_issuerserial_st
+{
+	GENERAL_NAMES *issuer;
+	ASN1_INTEGER  *serialNumber;
+} ESS_ISSUERSERIAL;
+DECLARE_ASN1_FUNCTIONS(ESS_ISSUERSERIAL)
+
+typedef struct ess_cert_id_st
+{
+	ASN1_OCTET_STRING *hash;
+	ESS_ISSUERSERIAL  *issuerSerial;
+} ESS_CERT_ID;
+DECLARE_ASN1_FUNCTIONS(ESS_CERT_ID)
+DECLARE_STACK_OF(ESS_CERT_ID)
+DECLARE_ASN1_SET_OF(ESS_CERT_ID)
+
+typedef struct ess_signing_cert_st
+{
+	STACK_OF(ESS_CERTID) *cert_ids;
+	STACK_OF(POLICYINFO)    *policies;
+} ESS_SIGNING_CERT;
+DECLARE_ASN1_FUNCTIONS(ESS_SIGNING_CERT)
+
+#ifndef HEADER_CRMF_H
+typedef STACK_OF(X509_EXTENSION) X509_EXTENSIONS;
+#endif
+#endif
+#include <openssl/crmf.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*
+     RevAnnContent ::= SEQUENCE {
+         status              PKIStatus,
+         certId              CertId,
+         willBeRevokedAt     GeneralizedTime,
+         badSinceDate        GeneralizedTime,
+         crlDetails          Extensions  OPTIONAL
+         -- extra CRL details (e.g., crl number, reason, location, etc.)
+     }
+     */
+typedef struct cmp_revanncontent_st
+{
+	ASN1_INTEGER             *status;
+	CRMF_CERTID              *certId;
+	ASN1_GENERALIZEDTIME     *willBeRevokedAt;
+	ASN1_GENERALIZEDTIME     *badSinceDate;
+	STACK_OF(X509_EXTENSION) *crlDetails;
+} CMP_REVANNCONTENT;
+DECLARE_ASN1_FUNCTIONS(CMP_REVANNCONTENT)
+
+
+/*
+     Challenge ::= SEQUENCE {
+         owf                 AlgorithmIdentifier  OPTIONAL,
+
+         -- MUST be present in the first Challenge; MAY be omitted in
+         -- any subsequent Challenge in POPODecKeyChallContent (if
+         -- omitted, then the owf used in the immediately preceding
+         -- Challenge is to be used).
+
+         witness             OCTET STRING,
+         -- the result of applying the one-way function (owf) to a
+         -- randomly-generated INTEGER, A.  [Note that a different
+         -- INTEGER MUST be used for each Challenge.]
+         challenge           OCTET STRING
+         -- the encryption (under the public key for which the cert.
+         -- request is being made) of Rand, where Rand is specified as
+         --   Rand ::= SEQUENCE {
+         --      int      INTEGER,
+         --       - the randomly-generated INTEGER A (above)
+         --      sender   GeneralName
+         --       - the sender's name (as included in PKIHeader)
+         --   }
+     }
+     */
+typedef struct cmp_challenge_st
+{
+	X509_ALGOR        *owf;
+	ASN1_OCTET_STRING *whitness;
+	ASN1_OCTET_STRING *challenge;
+} CMP_CHALLENGE;
+DECLARE_ASN1_FUNCTIONS(CMP_CHALLENGE)
+DECLARE_STACK_OF(CMP_CHALLENGE)
+/* TODO:
+     POPODecKeyChallContent ::= SEQUENCE OF Challenge
+     -- One Challenge per encryption key certification request (in the
+     -- same order as these requests appear in CertReqMessages).
+     */
+
+/* the rfc allows substituting that with "Certificate"... */
+	/*
+      CMPCertificate ::= CHOICE {
+         x509v3PKCert        Certificate
+      }
+      */
+#define CMP_CMPCERTIFICATE_X509V3PKCERT   0
+typedef struct cmp_cmpcertificate_st
+{
+	int type;
+	union{
+		X509 *x509v3PKCert;
+	} value;
+} CMP_CMPCERTIFICATE;
+DECLARE_ASN1_FUNCTIONS(CMP_CMPCERTIFICATE)
+DECLARE_STACK_OF(CMP_CMPCERTIFICATE)
+
+
+	/*
+     CAKeyUpdAnnContent ::= SEQUENCE {
+         oldWithNew   CMPCertificate, -- old pub signed with new priv
+         newWithOld   CMPCertificate, -- new pub signed with old priv
+         newWithNew   CMPCertificate  -- new pub signed with new priv
+     }
+     */
+typedef struct cmp_cakeyupdanncontent_st
+{
+#if 0
+/* the rfc allows substituting CMPCertificate with "Certificate"... */
+	CMP_CMPCERTIFICATE *oldWithNew;
+	CMP_CMPCERTIFICATE *newWithOld;
+	CMP_CMPCERTIFICATE *newWithNew;
+#endif
+	X509 *oldWithNew;
+	X509 *newWithOld;
+	X509 *newWithNew;
+} CMP_CAKEYUPDANNCONTENT;
+DECLARE_ASN1_FUNCTIONS(CMP_CAKEYUPDANNCONTENT)
+
+
+/* ESS_SIGNING_CERT comes from ts.h, but for some reason ESS_SIGNING_CERT_it isn't declared there */
+DECLARE_ASN1_ITEM(ESS_SIGNING_CERT)
+DECLARE_STACK_OF(ESS_SIGNING_CERT)
+
+typedef struct cmp_infotypeandvalue_st
+{
+	ASN1_OBJECT *infoType;
+	union {
+		char *ptr;
+
+		/* NID_id_it_caProtEncCert - CA Protocol Encryption Certificate  */
+		X509 *caProtEncCert;
+		/* NID_id_it_signKeyPairTypes - Signing Key Pair Types  */
+		STACK_OF(X509_ALGOR) *signKeyPairTypes;
+		/* NID_id_it_encKeyPairTypes - Encryption/Key Agreement Key Pair Types  */
+		STACK_OF(X509_ALGOR) *encKeyPairTypes;
+		/* NID_id_it_preferredSymmAlg - Preferred Symmetric Algorithm  */
+		X509_ALGOR *preferredSymmAlg;
+		/* NID_id_it_caKeyUpdateInfo - Updated CA Key Pair  */
+		CMP_CAKEYUPDANNCONTENT *caKeyUpdateInfo;
+		/* NID_id_it_currentCRL - CRL  */
+		X509_CRL *currentCRL;
+		/* NID_id_it_unsupportedOIDs - Unsupported Object Identifiers  */
+		STACK_OF(ASN1_OBJECT) *unsupportedOIDs;
+		/* NID_id_it_keyPairParamReq - Key Pair Parameters Request  */
+		ASN1_OBJECT *keyPairParamReq;
+		/* NID_id_it_keyPairParamRep - Key Pair Parameters Response  */
+		X509_ALGOR *keyPairParamRep;
+		/* NID_id_it_revPassphrase - Revocation Passphrase  */
+		CRMF_ENCRYPTEDVALUE *revPassphrase;
+
+		/* NID_id_it_implicitConfirm - ImplicitConfirm  */
+		ASN1_NULL *implicitConfirm;
+		/* NID_id_it_confirmWaitTime - ConfirmWaitTime  */
+		ASN1_GENERALIZEDTIME *confirmWaitTime;
+		/* NID_id_it_origPKIMessage - origPKIMessage  */
+
+		// CMP_PKIMESSAGE *origPKIMessage;
+		struct cmp_pkiheader_st *origPKIMessage;
+
+		/* NID_id_smime_aa_signingCertificate */
+		STACK_OF(ESS_SIGNING_CERT) *signingCertificate; 
+		// ESS_SIGNING_CERT *signingCertificate; 
+
+		ASN1_TYPE *other;
+	} infoValue;
+} CMP_INFOTYPEANDVALUE;
+DECLARE_ASN1_FUNCTIONS(CMP_INFOTYPEANDVALUE)
+DECLARE_STACK_OF(CMP_INFOTYPEANDVALUE)
+
+	/*
+     PKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
+         -- text encoded as UTF-8 String [RFC3629] (note: each
+         -- UTF8String MAY include an [RFC3066] language tag
+         -- to indicate the language of the contained text
+         -- see [RFC2482] for details)
+	 */
+
+#if 0
+DECLARE_STACK_OF(ASN1_UTF8STRING)
+typedef STACK_OF(ASN1_UTF8STRING) CMP_PKIFREETEXT;
+DECLARE_ASN1_FUNCTIONS(CMP_PKIFREETEXT)
+#endif
+
+
+/*
+     PKIFailureInfo ::= BIT STRING {
+     -- since we can fail in more than one way!
+     -- More codes may be added in the future if/when required.
+         badAlg              (0),
+         -- unrecognized or unsupported Algorithm Identifier
+         badMessageCheck     (1),
+         -- integrity check failed (e.g., signature did not verify)
+         badRequest          (2),
+         -- transaction not permitted or supported
+         badTime             (3),
+         -- messageTime was not sufficiently close to the system time,
+         -- as defined by local policy
+         badCertId           (4),
+         -- no certificate could be found matching the provided criteria
+         badDataFormat       (5),
+         -- the data submitted has the wrong format
+         wrongAuthority      (6),
+         -- the authority indicated in the request is different from the
+         -- one creating the response token
+         incorrectData       (7),
+         -- the requester's data is incorrect (for notary services)
+         missingTimeStamp    (8),
+         -- when the timestamp is missing but should be there
+         -- (by policy)
+         badPOP              (9),
+         -- the proof-of-possession failed
+         certRevoked         (10),
+            -- the certificate has already been revoked
+         certConfirmed       (11),
+            -- the certificate has already been confirmed
+         wrongIntegrity      (12),
+            -- invalid integrity, password based instead of signature or
+            -- vice versa
+         badRecipientNonce   (13),
+            -- invalid recipient nonce, either missing or wrong value
+         timeNotAvailable    (14),
+            -- the TSA's time source is not available
+         unacceptedPolicy    (15),
+            -- the requested TSA policy is not supported by the TSA.
+         unacceptedExtension (16),
+            -- the requested extension is not supported by the TSA.
+         addInfoNotAvailable (17),
+            -- the additional information requested could not be
+            -- understood or is not available
+         badSenderNonce      (18),
+            -- invalid sender nonce, either missing or wrong size
+         badCertTemplate     (19),
+            -- invalid cert. template or missing mandatory information
+         signerNotTrusted    (20),
+            -- signer of the message unknown or not trusted
+         transactionIdInUse  (21),
+            -- the transaction identifier is already in use
+         unsupportedVersion  (22),
+            -- the version of the message is not supported
+         notAuthorized       (23),
+            -- the sender was not authorized to make the preceding
+            -- request or perform the preceding action
+         systemUnavail       (24),
+         -- the request cannot be handled due to system unavailability
+         systemFailure       (25),
+         -- the request cannot be handled due to system failure
+         duplicateCertReq    (26)
+         -- certificate cannot be issued because a duplicate
+         -- certificate already exists
+     }
+     */
+#define CMP_PKIFAILUREINFO_badAlg		 0
+#define CMP_PKIFAILUREINFO_badMessageCheck	 1
+#define CMP_PKIFAILUREINFO_badRequest		 2
+#define CMP_PKIFAILUREINFO_badTime		 3
+#define CMP_PKIFAILUREINFO_badCertId		 4
+#define CMP_PKIFAILUREINFO_badDataFormat	 5
+#define CMP_PKIFAILUREINFO_wrongAuthority	 6
+#define CMP_PKIFAILUREINFO_incorrectData	 7
+#define CMP_PKIFAILUREINFO_missingTimeStamp	 8
+#define CMP_PKIFAILUREINFO_badPOP		 9
+#define CMP_PKIFAILUREINFO_certRevoked		10
+#define CMP_PKIFAILUREINFO_certConfirmed	11
+#define CMP_PKIFAILUREINFO_wrongIntegrity	12
+#define CMP_PKIFAILUREINFO_badRecipientNonce	13
+#define CMP_PKIFAILUREINFO_timeNotAvailable	14
+#define CMP_PKIFAILUREINFO_unacceptedPolicy	15
+#define CMP_PKIFAILUREINFO_unacceptedExtension	16
+#define CMP_PKIFAILUREINFO_addInfoNotAvailable	17
+#define CMP_PKIFAILUREINFO_badSenderNonce	18
+#define CMP_PKIFAILUREINFO_badCertTemplate	19
+#define CMP_PKIFAILUREINFO_signerNotTrusted	20
+#define CMP_PKIFAILUREINFO_transactionIdInUse	21
+#define CMP_PKIFAILUREINFO_unsupportedVersion	22
+#define CMP_PKIFAILUREINFO_notAuthorized	23
+#define CMP_PKIFAILUREINFO_systemUnavail	24
+#define CMP_PKIFAILUREINFO_systemFailure	25
+#define CMP_PKIFAILUREINFO_duplicateCertReq	26
+#define CMP_PKIFAILUREINFO_MAX                  26
+typedef ASN1_BIT_STRING CMP_PKIFAILUREINFO;
+
+#define CMP_CTX_FAILINFO_badAlg              (1 << 0)
+#define CMP_CTX_FAILINFO_badMessageCheck     (1 << 1)
+#define CMP_CTX_FAILINFO_badRequest          (1 << 2)
+#define CMP_CTX_FAILINFO_badTime             (1 << 3)
+#define CMP_CTX_FAILINFO_badCertId           (1 << 4)
+#define CMP_CTX_FAILINFO_badDataFormat       (1 << 5)
+#define CMP_CTX_FAILINFO_wrongAuthority      (1 << 6)
+#define CMP_CTX_FAILINFO_incorrectData       (1 << 7)
+#define CMP_CTX_FAILINFO_missingTimeStamp    (1 << 8)
+#define CMP_CTX_FAILINFO_badPOP              (1 << 9)
+#define CMP_CTX_FAILINFO_certRevoked         (1 << 10)
+#define CMP_CTX_FAILINFO_certConfirmed       (1 << 11)
+#define CMP_CTX_FAILINFO_wrongIntegrity      (1 << 12)
+#define CMP_CTX_FAILINFO_badRecipientNonce   (1 << 13)
+#define CMP_CTX_FAILINFO_timeNotAvailable    (1 << 14)
+#define CMP_CTX_FAILINFO_unacceptedPolicy    (1 << 15)
+#define CMP_CTX_FAILINFO_unacceptedExtension (1 << 16)
+#define CMP_CTX_FAILINFO_addInfoNotAvailable (1 << 17)
+#define CMP_CTX_FAILINFO_badSenderNonce      (1 << 18)
+#define CMP_CTX_FAILINFO_badCertTemplate     (1 << 19)
+#define CMP_CTX_FAILINFO_signerNotTrusted    (1 << 20)
+#define CMP_CTX_FAILINFO_transactionIdInUse  (1 << 21)
+#define CMP_CTX_FAILINFO_unsupportedVersion  (1 << 22)
+#define CMP_CTX_FAILINFO_notAuthorized       (1 << 23)
+#define CMP_CTX_FAILINFO_systemUnavail       (1 << 24)
+#define CMP_CTX_FAILINFO_systemFailure       (1 << 25)
+#define CMP_CTX_FAILINFO_duplicateCertReq    (1 << 26)
+
+/*
+     PKIStatus ::= INTEGER {
+         accepted                (0),
+         -- you got exactly what you asked for
+         grantedWithMods        (1),
+         -- you got something like what you asked for; the
+         -- requester is responsible for ascertaining the differences
+         rejection              (2),
+         -- you don't get it, more information elsewhere in the message
+         waiting                (3),
+         -- the request body part has not yet been processed; expect to
+         -- hear more later (note: proper handling of this status
+         -- response MAY use the polling req/rep PKIMessages specified
+         -- in Section 5.3.22; alternatively, polling in the underlying
+         -- transport layer MAY have some utility in this regard)
+         revocationWarning      (4),
+         -- this message contains a warning that a revocation is
+         -- imminent
+         revocationNotification (5),
+         -- notification that a revocation has occurred
+         keyUpdateWarning       (6)
+         -- update already done for the oldCertId specified in
+         -- CertReqMsg
+     }
+     */
+#define CMP_PKISTATUS_accepted			0
+#define CMP_PKISTATUS_grantedWithMods		1
+#define CMP_PKISTATUS_rejection			2
+#define CMP_PKISTATUS_waiting			3
+#define CMP_PKISTATUS_revocationWarning		4
+#define CMP_PKISTATUS_revocationNotification	5
+#define CMP_PKISTATUS_keyUpdateWarning		6
+
+typedef ASN1_INTEGER CMP_PKISTATUS;
+DECLARE_ASN1_FUNCTIONS(CMP_PKISTATUS)
+
+
+
+/*
+     CertOrEncCert ::= CHOICE {
+         certificate     [0] CMPCertificate,
+         encryptedCert   [1] EncryptedValue
+     }
+     */
+#define CMP_CERTORENCCERT_CERTIFICATE   0
+#define CMP_CERTORENCCERT_ENCRYPTEDCERT 1
+typedef struct cmp_certorenccert_st
+{
+	int type;
+	union{
+		//CMP_CMPCERTIFICATE  *certificate;
+		X509  *certificate;
+		CRMF_ENCRYPTEDVALUE *encryptedCert;
+	} value;
+} CMP_CERTORENCCERT;
+DECLARE_ASN1_FUNCTIONS(CMP_CERTORENCCERT)
+/*
+     CertifiedKeyPair ::= SEQUENCE {
+         certOrEncCert       CertOrEncCert,
+         privateKey      [0] EncryptedValue      OPTIONAL,
+         -- see [CRMF] for comment on encoding
+         publicationInfo [1] PKIPublicationInfo  OPTIONAL
+     }
+     */
+typedef struct cmp_certifiedkeypair_st
+{
+	CMP_CERTORENCCERT       *certOrEncCert;
+	CRMF_ENCRYPTEDVALUE     *privateKey;
+	CRMF_PKIPUBLICATIONINFO *failInfo;
+} CMP_CERTIFIEDKEYPAIR;
+DECLARE_ASN1_FUNCTIONS(CMP_CERTIFIEDKEYPAIR)
+
+
+
+
+/*
+     PKIStatusInfo ::= SEQUENCE {
+         status        PKIStatus,
+         statusString  PKIFreeText     OPTIONAL,
+         failInfo      PKIFailureInfo  OPTIONAL
+     }
+     */
+
+typedef struct cmp_pkistatusinfo_st
+{
+	CMP_PKISTATUS      *status;
+#if 0
+	CMP_PKIFREETEXT    *statusString;
+#endif
+	STACK_OF(ASN1_UTF8STRING)    *statusString;
+	CMP_PKIFAILUREINFO *failInfo;
+} CMP_PKISTATUSINFO;
+DECLARE_ASN1_FUNCTIONS(CMP_PKISTATUSINFO)
+DECLARE_STACK_OF(CMP_PKISTATUSINFO)
+
+/*
+     RevReqContent ::= SEQUENCE OF RevDetails
+
+     RevDetails ::= SEQUENCE {
+         certDetails         CertTemplate,
+         -- allows requester to specify as much as they can about
+         -- the cert. for which revocation is requested
+         -- (e.g., for cases in which serialNumber is not available)
+         crlEntryDetails     Extensions       OPTIONAL
+         -- requested crlEntryExtensions
+     }
+*/
+
+typedef struct cmp_revdetails_st
+{
+	CRMF_CERTTEMPLATE        *certDetails;
+	STACK_OF(X509_EXTENSION) *crlEntryDetails;
+} CMP_REVDETAILS;
+DECLARE_ASN1_FUNCTIONS(CMP_REVDETAILS)
+DECLARE_STACK_OF(CMP_REVDETAILS)
+
+
+/*
+     RevRepContent ::= SEQUENCE {
+         status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
+         -- in same order as was sent in RevReqContent
+         revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId
+                                             OPTIONAL,
+         -- IDs for which revocation was requested
+         -- (same order as status)
+         crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList
+                                             OPTIONAL
+         -- the resulting CRLs (there may be more than one)
+     }
+     */
+
+typedef struct cmp_revrep_st
+{
+	STACK_OF(CMP_PKISTATUSINFO) *status;
+	STACK_OF(CRMF_CERTID)       *certId;
+	STACK_OF(X509)              *crls;
+} CMP_REVREP;
+DECLARE_ASN1_FUNCTIONS(CMP_REVREP)
+
+
+/*
+     KeyRecRepContent ::= SEQUENCE {
+         status                  PKIStatusInfo,
+         newSigCert          [0] CMPCertificate OPTIONAL,
+         caCerts             [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate OPTIONAL,
+         keyPairHist         [2] SEQUENCE SIZE (1..MAX) OF CertifiedKeyPair OPTIONAL
+     }
+*/
+typedef struct cmp_keyrecrepcontent_st
+{
+	CMP_PKISTATUSINFO       *status;
+	/* XXX CMPcertificate ::= Certificate */
+	X509                    *newSigCert;
+	/* XXX CMPcertificate ::= Certificate */
+	STACK_OF(X509)          *caCerts;
+	STACK_OF(CMP_CERTIFIEDKEYPAIR) *keyPairHist;
+} CMP_KEYRECREPCONTENT;
+DECLARE_ASN1_FUNCTIONS(CMP_KEYRECREPCONTENT)
+
+
+/*
+     ErrorMsgContent ::= SEQUENCE {
+         pKIStatusInfo          PKIStatusInfo,
+         errorCode              INTEGER           OPTIONAL,
+         -- implementation-specific error codes
+         errorDetails           PKIFreeText       OPTIONAL
+         -- implementation-specific error details
+     }
+     */
+typedef struct cmp_errormsgcontent_st
+{
+	CMP_PKISTATUSINFO *pKIStatusInfo;
+	ASN1_INTEGER	  *errorCode;
+	STACK_OF(ASN1_UTF8STRING)   *errorDetails;
+#if 0
+	CMP_PKIFREETEXT   *errorDetails;
+#endif
+} CMP_ERRORMSGCONTENT;
+DECLARE_ASN1_FUNCTIONS(CMP_ERRORMSGCONTENT)
+
+
+/*
+     CertConfirmContent ::= SEQUENCE OF CertStatus
+
+     CertStatus ::= SEQUENCE {
+        certHash    OCTET STRING,
+        -- the hash of the certificate, using the same hash algorithm
+        -- as is used to create and verify the certificate signature
+        certReqId   INTEGER,
+        -- to match this confirmation with the corresponding req/rep
+        statusInfo  PKIStatusInfo OPTIONAL
+     }
+     */
+typedef struct cmp_certstatus_st
+{
+	ASN1_OCTET_STRING	*certHash;
+	ASN1_INTEGER		*certReqId;
+	CMP_PKISTATUSINFO	*statusInfo;
+} CMP_CERTSTATUS;
+DECLARE_STACK_OF(CMP_CERTSTATUS)
+DECLARE_ASN1_SET_OF(CMP_CERTSTATUS)
+DECLARE_ASN1_FUNCTIONS(CMP_CERTSTATUS)
+
+/* this is not used */
+/* typedef STACK_OF(CMP_CERTSTATUS) CMP_CERTCONFIRMCONTENT; */
+/* DECLARE_ASN1_FUNCTIONS(CMP_CERTCONFIRMCONTENT) */
+
+
+/*
+     CertResponse ::= SEQUENCE {
+         certReqId           INTEGER,
+         -- to match this response with corresponding request (a value
+         -- of -1 is to be used if certReqId is not specified in the
+         -- corresponding request)
+         status              PKIStatusInfo,
+         certifiedKeyPair    CertifiedKeyPair    OPTIONAL,
+         rspInfo             OCTET STRING        OPTIONAL
+         -- analogous to the id-regInfo-utf8Pairs string defined
+         -- for regInfo in CertReqMsg [CRMF]
+     }
+*/
+typedef struct cmp_certresponse_st
+{
+	ASN1_INTEGER         *certReqId;
+	CMP_PKISTATUSINFO    *status;
+	CMP_CERTIFIEDKEYPAIR *certifiedKeyPair;
+	ASN1_OCTET_STRING    *rspInfo;
+} CMP_CERTRESPONSE;
+DECLARE_ASN1_FUNCTIONS(CMP_CERTRESPONSE)
+DECLARE_STACK_OF(CMP_CERTRESPONSE)
+
+/*
+     CertRepMessage ::= SEQUENCE {
+         caPubs       [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
+                          OPTIONAL,
+         response         SEQUENCE OF CertResponse
+     }
+*/
+typedef struct cmp_certrepmessage_st
+{
+	// STACK_OF(CMP_CMPCERTIFICATE) *caPubs;
+	STACK_OF(X509) *caPubs;
+	STACK_OF(CMP_CERTRESPONSE)   *response;
+} CMP_CERTREPMESSAGE;
+DECLARE_ASN1_FUNCTIONS(CMP_CERTREPMESSAGE)
+
+/*
+Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
+    type   	ATTRIBUTE.&id({IOSet}),
+    values 	SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
+}
+
+CertificationRequestInfo ::= SEQUENCE {
+    version       INTEGER { v1(0) } (v1,...),
+    subject       Name,
+    subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
+    attributes    [0] Attributes{{ CRIAttributes }}
+}
+
+CertificationRequest ::= SEQUENCE {
+    certificationRequestInfo CertificationRequestInfo,
+    signatureAlgorithm	     AlgorithmIdentifier{{ SignatureAlgorithms }},
+	signature                BIT STRING
+}
+*/
+
+/* TODO the PKCS10 structures need to be tested */
+typedef struct pkcs10_attribute_st
+{
+	ASN1_OBJECT         *id;
+	STACK_OF(ASN1_TYPE) *values;
+} PKCS10_ATTRIBUTE;
+DECLARE_ASN1_FUNCTIONS(PKCS10_ATTRIBUTE)
+DECLARE_STACK_OF(PKCS10_ATTRIBUTE)
+
+typedef struct pkcs10_certificationrequestinfo_st
+{
+	ASN1_INTEGER               *version;
+	X509_NAME                  *subject;
+	X509_PUBKEY                *subjectPKInfo;
+	STACK_OF(PKCS10_ATTRIBUTE) attributes;
+} PKCS10_CERTIFICATIONREQUESTINFO;
+DECLARE_ASN1_FUNCTIONS(PKCS10_CERTIFICATIONREQUESTINFO)
+
+typedef struct pkcs10_certificationrequest_st
+{
+	PKCS10_CERTIFICATIONREQUESTINFO *certificationRequestInfo;
+	X509_ALGOR                      *signatureAlgorithm;
+	ASN1_BIT_STRING                 *signature;
+} PKCS10_CERTIFICATIONREQUEST;
+DECLARE_ASN1_FUNCTIONS(PKCS10_CERTIFICATIONREQUEST)
+
+/*
+TODO: A LOT
+     PKIBody ::= CHOICE {       -- message-specific body elements
+         ir       [0]  CertReqMessages,        --Initialization Request
+         ip       [1]  CertRepMessage,         --Initialization Response
+         cr       [2]  CertReqMessages,        --Certification Request
+         cp       [3]  CertRepMessage,         --Certification Response
+         p10cr    [4]  CertificationRequest,   --imported from [PKCS10]
+         popdecc  [5]  POPODecKeyChallContent, --pop Challenge
+         popdecr  [6]  POPODecKeyRespContent,  --pop Response
+         kur      [7]  CertReqMessages,        --Key Update Request
+         kup      [8]  CertRepMessage,         --Key Update Response
+         krr      [9]  CertReqMessages,        --Key Recovery Request
+         krp      [10] KeyRecRepContent,       --Key Recovery Response
+         rr       [11] RevReqContent,          --Revocation Request
+         rp       [12] RevRepContent,          --Revocation Response
+         ccr      [13] CertReqMessages,        --Cross-Cert. Request
+         ccp      [14] CertRepMessage,         --Cross-Cert. Response
+         ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann.
+         cann     [16] CertAnnContent,         --Certificate Ann.
+         rann     [17] RevAnnContent,          --Revocation Ann.
+         crlann   [18] CRLAnnContent,          --CRL Announcement
+         pkiconf  [19] PKIConfirmContent,      --Confirmation
+         nested   [20] NestedMessageContent,   --Nested Message
+         genm     [21] GenMsgContent,          --General Message
+         genp     [22] GenRepContent,          --General Response
+         error    [23] ErrorMsgContent,        --Error Message
+         certConf [24] CertConfirmContent,     --Certificate confirm
+         pollReq  [25] PollReqContent,         --Polling request
+         pollRep  [26] PollRepContent          --Polling response
+*/
+
+/*
+
+     PKIProtection ::= BIT STRING
+
+     PKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage
+
+      PKIMessage ::= SEQUENCE {
+         header           PKIHeader,
+         body             PKIBody,
+         protection   [0] PKIProtection OPTIONAL,
+         extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
+                          OPTIONAL
+     }
+
+*/
+
+/*
+     PKIHeader ::= SEQUENCE {
+         pvno                INTEGER     { cmp1999(1), cmp2000(2) },
+         sender              GeneralName,
+         -- identifies the sender
+         recipient           GeneralName,
+         -- identifies the intended recipient
+         messageTime     [0] GeneralizedTime         OPTIONAL,
+         -- time of production of this message (used when sender
+         -- believes that the transport will be "suitable"; i.e.,
+         -- that the time will still be meaningful upon receipt)
+         protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
+         -- algorithm used for calculation of protection bits
+         senderKID       [2] KeyIdentifier           OPTIONAL,
+         recipKID        [3] KeyIdentifier           OPTIONAL,
+         -- to identify specific keys used for protection
+         transactionID   [4] OCTET STRING            OPTIONAL,
+         -- identifies the transaction; i.e., this will be the same in
+         -- corresponding request, response, certConf, and PKIConf
+         -- messages
+         senderNonce     [5] OCTET STRING            OPTIONAL,
+         recipNonce      [6] OCTET STRING            OPTIONAL,
+         -- nonces used to provide replay protection, senderNonce
+         -- is inserted by the creator of this message; recipNonce
+         -- is a nonce previously inserted in a related message by
+         -- the intended recipient of this message
+         freeText        [7] PKIFreeText             OPTIONAL,
+         -- this may be used to indicate context-specific instructions
+         -- (this field is intended for human consumption)
+         generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
+                                InfoTypeAndValue     OPTIONAL
+         -- this may be used to convey context-specific information
+         -- (this field not primarily intended for human consumption)
+     }
+*/
+
+typedef struct cmp_pollreq_st {
+	ASN1_INTEGER *certReqId;
+} CMP_POLLREQ;
+DECLARE_ASN1_FUNCTIONS(CMP_POLLREQ)
+DECLARE_STACK_OF(CMP_POLLREQ)
+
+typedef struct cmp_pollrep_st {
+	ASN1_INTEGER *certReqId;
+	ASN1_INTEGER *checkAfter;
+	STACK_OF(ASN1_UTF8STRING) *reason;
+} CMP_POLLREP;
+DECLARE_ASN1_FUNCTIONS(CMP_POLLREP)
+DECLARE_STACK_OF(CMP_POLLREP)
+
+typedef struct cmp_pkiheader_st
+{
+	ASN1_INTEGER                  *pvno;
+	GENERAL_NAME                  *sender;
+	GENERAL_NAME                  *recipient;
+	ASN1_GENERALIZEDTIME          *messageTime;    /* 0 */
+	X509_ALGOR                    *protectionAlg;  /* 1 */
+	ASN1_OCTET_STRING             *senderKID;      /* 2 */
+	ASN1_OCTET_STRING             *recipKID;       /* 3 */
+	ASN1_OCTET_STRING             *transactionID;  /* 4 */
+	ASN1_OCTET_STRING             *senderNonce;    /* 5 */
+	ASN1_OCTET_STRING             *recipNonce;     /* 6 */
+	STACK_OF(ASN1_UTF8STRING)     *freeText;       /* 7 */
+	STACK_OF(CMP_INFOTYPEANDVALUE) *generalInfo;    /* 8 */
+} CMP_PKIHEADER;
+DECLARE_ASN1_FUNCTIONS(CMP_PKIHEADER)
+
+	/*
+     InfoTypeAndValue ::= SEQUENCE {
+         infoType               OBJECT IDENTIFIER,
+         infoValue              ANY DEFINED BY infoType  OPTIONAL
+     }
+     */
+
+#define V_CMP_PKIBODY_IR	0
+#define V_CMP_PKIBODY_IP	1
+#define V_CMP_PKIBODY_CR	2
+#define V_CMP_PKIBODY_CP	3
+#define V_CMP_PKIBODY_P10CR	4
+#define V_CMP_PKIBODY_POPDECC	5
+#define V_CMP_PKIBODY_POPDECR	6
+#define V_CMP_PKIBODY_KUR	7
+#define V_CMP_PKIBODY_KUP	8
+#define V_CMP_PKIBODY_KRR	9
+#define V_CMP_PKIBODY_KRP	10
+#define V_CMP_PKIBODY_RR	11
+#define V_CMP_PKIBODY_RP	12
+#define V_CMP_PKIBODY_CCR	13
+#define V_CMP_PKIBODY_CCP	14
+#define V_CMP_PKIBODY_CKUANN	15
+#define V_CMP_PKIBODY_CANN	16
+#define V_CMP_PKIBODY_RANN	17
+#define V_CMP_PKIBODY_CRLANN	18
+#define V_CMP_PKIBODY_PKICONF	19
+#define V_CMP_PKIBODY_NESTED	20
+#define V_CMP_PKIBODY_GENM	21
+#define V_CMP_PKIBODY_GENP	22
+#define V_CMP_PKIBODY_ERROR	23
+#define V_CMP_PKIBODY_CERTCONF	24
+#define V_CMP_PKIBODY_POLLREQ	25
+#define V_CMP_PKIBODY_POLLREP	26
+
+typedef struct cmp_pkibody_st
+{
+	int type;
+	union{
+		STACK_OF(CRMF_CERTREQMSG)   *ir;   /* 0 */
+		CMP_CERTREPMESSAGE          *ip;   /* 1 */
+		STACK_OF(CRMF_CERTREQMSG)   *cr;   /* 2 */
+		CMP_CERTREPMESSAGE          *cp;   /* 3 */
+        /* p10cr    [4]  CertificationRequest,   --imported from [PKCS10] */
+		PKCS10_CERTIFICATIONREQUEST *p10cr;   /* 4 */
+        /* popdecc  [5]  POPODecKeyChallContent, --pop Challenge */
+	/* POPODecKeyChallContent ::= SEQUENCE OF Challenge */
+		STACK_OF(CMP_CHALLENGE) *popdecc; /* 5 */
+	/* popdecr  [6]  POPODecKeyRespContent,  --pop Response */
+	/* POPODecKeyRespContent ::= SEQUENCE OF INTEGER */
+		STACK_OF(ASN1_INTEGER)    *popdecr; /* 6 */
+		STACK_OF(CRMF_CERTREQMSG)   *kur;   /* 7 */
+		CMP_CERTREPMESSAGE          *kup;   /* 8 */
+		STACK_OF(CRMF_CERTREQMSG)   *krr;   /* 9 */
+
+	/* krp      [10] KeyRecRepContent,       --Key Recovery Response */
+		CMP_KEYRECREPCONTENT        *krp;   /* 10 */
+        /* rr       [11] RevReqContent,          --Revocation Request */
+		STACK_OF(CMP_REVDETAILS)    *rr; /* 11 */
+        /* rp       [12] RevRepContent,          --Revocation Response */
+		CMP_REVREP   *rp; /* 12 */
+        /* ccr      [13] CertReqMessages,        --Cross-Cert. Request */
+		STACK_OF(CRMF_CERTREQMSG)   *crr; /* 13 */
+        /* ccp      [14] CertRepMessage,         --Cross-Cert. Response */
+		CMP_CERTREPMESSAGE          *ccp; /* 14 */
+        /* ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann. */
+		CMP_CAKEYUPDANNCONTENT   *ckuann; /* 15 */
+	/* cann     [16] CertAnnContent,         --Certificate Ann. */
+	/* XXX CMPcertificate ::= Certificate */
+		X509                       *cann; /* 16 */
+        /* rann     [17] RevAnnContent,          --Revocation Ann. */
+		CMP_REVANNCONTENT          *rann; /* 17 */
+        /* crlann   [18] CRLAnnContent,          --CRL Announcement */
+        /* CRLAnnContent ::= SEQUENCE OF CertificateList */
+        STACK_OF(X509_CRL)         *crlann;
+        /* pkiconf  [19] PKIConfirmContent,      --Confirmation */
+	/* CMP_PKICONFIRMCONTENT would be only a typedfef of ASN1_NULL */
+	/* CMP_CONFIRMCONTENT *pkiconf; */
+		/* this should ASN1_NULL according to the RFC but there might be a struct in it */
+		ASN1_TYPE                       *pkiconf; /* 19 */
+        /* nested   [20] NestedMessageContent,   --Nested Message */
+        /* NestedMessageContent ::= PKIMessages */
+		STACK_OF(CMP_PKIMESSAGE)        *nested; /* 20 */
+        /* genm     [21] GenMsgContent,          --General Message */
+        /* GenMsgContent ::= SEQUENCE OF InfoTypeAndValue */
+		STACK_OF(CMP_INFOTYPEANDVALUE) *genm; /* 21 */
+        /* genp     [22] GenRepContent,          --General Response */
+	/* GenRepContent ::= SEQUENCE OF InfoTypeAndValue */
+		STACK_OF(CMP_INFOTYPEANDVALUE) *genp; /* 22 */
+        /* error    [23] ErrorMsgContent,        --Error Message */
+		CMP_ERRORMSGCONTENT            *error;    /* 23 */
+        /* certConf [24] CertConfirmContent,     --Certificate confirm */
+	 	/* CMP_CERTCONFIRMCONTENT      *certConf; / * 24 */
+	 	STACK_OF(CMP_CERTSTATUS)       *certConf; /* 24 */
+		/* pollReq  [25] PollReqContent,         --Polling request */
+	 	STACK_OF(CMP_POLLREQ)          *pollReq;
+        /* pollRep  [26] PollRepContent          --Polling response */
+	 	STACK_OF(CMP_POLLREP)          *pollRep;
+	} value;
+} CMP_PKIBODY;
+DECLARE_ASN1_FUNCTIONS(CMP_PKIBODY)
+
+typedef struct cmp_pkimessage_st
+{
+	CMP_PKIHEADER                *header;
+	CMP_PKIBODY                  *body;
+	ASN1_BIT_STRING              *protection; /* 0 */
+	//STACK_OF(CMP_CMPCERTIFICATE) *extraCerts; /* 1 */
+	STACK_OF(X509) *extraCerts; /* 1 */
+} CMP_PKIMESSAGE;
+DECLARE_ASN1_FUNCTIONS(CMP_PKIMESSAGE)
+DECLARE_STACK_OF(CMP_PKIMESSAGE) /* PKIMessages */
+
+/* XXX is there more to do for that? */
+typedef STACK_OF(CMP_PKIMESSAGE) CMP_PKIMESSAGES;
+
+
+/*
+     ProtectedPart ::= SEQUENCE {
+         header    PKIHeader,
+         body      PKIBody
+     }
+     */
+typedef struct cmp_protectedpart_st
+{
+	CMP_PKIHEADER                *header;
+	CMP_PKIBODY                  *body;
+} CMP_PROTECTEDPART;
+DECLARE_ASN1_FUNCTIONS(CMP_PROTECTEDPART)
+
+
+/*
+Appendix F.  Compilable ASN.1 Definitions
+
+     PKIXCMP {iso(1) identified-organization(3)
+           dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+           id-mod(0) id-mod-cmp2000(16)}
+
+     DEFINITIONS EXPLICIT TAGS ::=
+
+     BEGIN
+
+     -- EXPORTS ALL --
+
+     IMPORTS
+
+         Certificate, CertificateList, Extensions, AlgorithmIdentifier,
+         UTF8String -- if required; otherwise, comment out
+                FROM PKIX1Explicit88 {iso(1) identified-organization(3)
+                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+                id-mod(0) id-pkix1-explicit-88(1)}
+
+         GeneralName, KeyIdentifier
+                FROM PKIX1Implicit88 {iso(1) identified-organization(3)
+                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+                id-mod(0) id-pkix1-implicit-88(2)}
+
+         CertTemplate, PKIPublicationInfo, EncryptedValue, CertId,
+         CertReqMessages
+                FROM PKIXCRMF-2005 {iso(1) identified-organization(3)
+                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
+                id-mod(0) id-mod-crmf2005(36)}
+
+         -- see also the behavioral clarifications to CRMF codified in
+         -- Appendix C of this specification
+
+         CertificationRequest
+                FROM PKCS-10 {iso(1) member-body(2)
+                              us(840) rsadsi(113549)
+                              pkcs(1) pkcs-10(10) modules(1) pkcs-10(1)}
+
+         -- (specified in RFC 2986 with 1993 ASN.1 syntax and IMPLICIT
+         -- tags).  Alternatively, implementers may directly include
+         -- the [PKCS10] syntax in this module
+
+
+
+
+Adams, et al.               Standards Track                    [Page 83]
+
+RFC 4210                          CMP                     September 2005
+
+
+         ;
+
+   -- the rest of the module contains locally-defined OIDs and
+   -- constructs
+
+   -- This syntax, while bits-on-the-wire compatible with the
+   -- standard X.509 definition of "Certificate", allows the
+   -- possibility of future certificate types (such as X.509
+   -- attribute certificates, WAP WTLS certificates, or other kinds
+   -- of certificates) within this certificate management protocol,
+   -- should a need ever arise to support such generality.  Those
+   -- implementations that do not foresee a need to ever support
+   -- other certificate types MAY, if they wish, comment out the
+   -- above structure and "un-comment" the following one prior to
+   -- compiling this ASN.1 module.  (Note that interoperability
+   -- with implementations that dont do this will be unaffected by
+   -- this change.)
+
+   -- CMPCertificate ::= Certificate
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 84]
+
+RFC 4210                          CMP                     September 2005
+
+
+
+
+
+
+Adams, et al.               Standards Track                    [Page 85]
+
+RFC 4210                          CMP                     September 2005
+
+
+         genp     [22] GenRepContent,          --General Response
+         error    [23] ErrorMsgContent,        --Error Message
+         certConf [24] CertConfirmContent,     --Certificate confirm
+         pollReq  [25] PollReqContent,         --Polling request
+         pollRep  [26] PollRepContent          --Polling response
+     }
+
+
+     id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}
+     PBMParameter ::= SEQUENCE {
+         salt                OCTET STRING,
+         -- note:  implementations MAY wish to limit acceptable sizes
+         -- of this string to values appropriate for their environment
+         -- in order to reduce the risk of denial-of-service attacks
+         owf                 AlgorithmIdentifier,
+         -- AlgId for a One-Way Function (SHA-1 recommended)
+         iterationCount      INTEGER,
+         -- number of times the OWF is applied
+         -- note:  implementations MAY wish to limit acceptable sizes
+         -- of this integer to values appropriate for their environment
+         -- in order to reduce the risk of denial-of-service attacks
+         mac                 AlgorithmIdentifier
+         -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+     }   -- or HMAC [RFC2104, RFC2202])
+
+     id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}
+     DHBMParameter ::= SEQUENCE {
+         owf                 AlgorithmIdentifier,
+         -- AlgId for a One-Way Function (SHA-1 recommended)
+         mac                 AlgorithmIdentifier
+         -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+     }   -- or HMAC [RFC2104, RFC2202])
+
+
+
+
+
+
+     OOBCert ::= CMPCertificate
+
+     OOBCertHash ::= SEQUENCE {
+         hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
+         certId      [1] CertId                  OPTIONAL,
+         hashVal         BIT STRING
+
+
+
+Adams, et al.               Standards Track                    [Page 88]
+
+RFC 4210                          CMP                     September 2005
+
+
+         -- hashVal is calculated over the DER encoding of the
+         -- self-signed certificate with the identifier certID.
+     }
+
+
+
+
+
+
+     RevRepContent ::= SEQUENCE {
+         status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
+         -- in same order as was sent in RevReqContent
+         revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId
+                                             OPTIONAL,
+         -- IDs for which revocation was requested
+         -- (same order as status)
+         crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList
+                                             OPTIONAL
+
+
+
+Adams, et al.               Standards Track                    [Page 90]
+
+RFC 4210                          CMP                     September 2005
+
+
+         -- the resulting CRLs (there may be more than one)
+     }
+
+
+
+
+
+
+     PKIConfirmContent ::= NULL
+
+     -- Example InfoTypeAndValue contents include, but are not limited
+     -- to, the following (un-comment in this ASN.1 module and use as
+     -- appropriate for a given environment):
+     --
+     --   id-it-caProtEncCert    OBJECT IDENTIFIER ::= {id-it 1}
+     --      CAProtEncCertValue      ::= CMPCertificate
+     --   id-it-signKeyPairTypes OBJECT IDENTIFIER ::= {id-it 2}
+     --      SignKeyPairTypesValue   ::= SEQUENCE OF AlgorithmIdentifier
+     --   id-it-encKeyPairTypes  OBJECT IDENTIFIER ::= {id-it 3}
+
+
+
+Adams, et al.               Standards Track                    [Page 91]
+
+RFC 4210                          CMP                     September 2005
+
+
+     --      EncKeyPairTypesValue    ::= SEQUENCE OF AlgorithmIdentifier
+     --   id-it-preferredSymmAlg OBJECT IDENTIFIER ::= {id-it 4}
+     --      PreferredSymmAlgValue   ::= AlgorithmIdentifier
+     --   id-it-caKeyUpdateInfo  OBJECT IDENTIFIER ::= {id-it 5}
+     --      CAKeyUpdateInfoValue    ::= CAKeyUpdAnnContent
+     --   id-it-currentCRL       OBJECT IDENTIFIER ::= {id-it 6}
+     --      CurrentCRLValue         ::= CertificateList
+     --   id-it-unsupportedOIDs  OBJECT IDENTIFIER ::= {id-it 7}
+     --      UnsupportedOIDsValue    ::= SEQUENCE OF OBJECT IDENTIFIER
+     --   id-it-keyPairParamReq  OBJECT IDENTIFIER ::= {id-it 10}
+     --      KeyPairParamReqValue    ::= OBJECT IDENTIFIER
+     --   id-it-keyPairParamRep  OBJECT IDENTIFIER ::= {id-it 11}
+     --      KeyPairParamRepValue    ::= AlgorithmIdentifer
+     --   id-it-revPassphrase    OBJECT IDENTIFIER ::= {id-it 12}
+     --      RevPassphraseValue      ::= EncryptedValue
+     --   id-it-implicitConfirm  OBJECT IDENTIFIER ::= {id-it 13}
+     --      ImplicitConfirmValue    ::= NULL
+     --   id-it-confirmWaitTime  OBJECT IDENTIFIER ::= {id-it 14}
+     --      ConfirmWaitTimeValue    ::= GeneralizedTime
+     --   id-it-origPKIMessage   OBJECT IDENTIFIER ::= {id-it 15}
+     --      OrigPKIMessageValue     ::= PKIMessages
+     --   id-it-suppLangTags     OBJECT IDENTIFIER ::= {id-it 16}
+     --      SuppLangTagsValue       ::= SEQUENCE OF UTF8String
+     --
+     -- where
+     --
+     --   id-pkix OBJECT IDENTIFIER ::= {
+     --      iso(1) identified-organization(3)
+     --      dod(6) internet(1) security(5) mechanisms(5) pkix(7)}
+     -- and
+     --   id-it   OBJECT IDENTIFIER ::= {id-pkix 4}
+     --
+     --
+     -- This construct MAY also be used to define new PKIX Certificate
+     -- Management Protocol request and response messages, or general-
+     -- purpose (e.g., announcement) messages for future needs or for
+     -- specific environments.
+
+
+     -- May be sent by EE, RA, or CA (depending on message content).
+     -- The OPTIONAL infoValue parameter of InfoTypeAndValue will
+     -- typically be omitted for some of the examples given above.
+     -- The receiver is free to ignore any contained OBJ. IDs that it
+     -- does not recognize. If sent from EE to CA, the empty set
+     -- indicates that the CA may send
+     -- any/all information that it wishes.
+
+
+
+
+Adams, et al.               Standards Track                    [Page 92]
+
+RFC 4210                          CMP                     September 2005
+
+
+
+     PollReqContent ::= SEQUENCE OF SEQUENCE {
+         certReqId              INTEGER
+     }
+
+     PollRepContent ::= SEQUENCE OF SEQUENCE {
+         certReqId              INTEGER,
+         checkAfter             INTEGER,  -- time in seconds
+         reason                 PKIFreeText OPTIONAL
+     }
+
+
+     END -- of CMP module
+*/
+
+typedef void (*cmp_logfn_t)(const char *msg);
+typedef int (*cmp_certConfFn_t)(int status, const X509 *cert);
+
+
+/* CMP_CTX definitions */
+/* this structure is used to store the context for CMP sessions */
+/* partly in ASN.1 syntax in order to ease storing it in the future */
+typedef struct cmp_ctx_st
+{
+	/* "reference and secret" as described in
+	 * 4.2.1.2.  End Entity Message Origin Authentication
+	 * this is used for IR Sequence
+	 */
+	ASN1_OCTET_STRING    *referenceValue;
+	ASN1_OCTET_STRING    *secretValue;
+	ASN1_UTF8STRING      *regToken;
+	/* CA certificate used to identify the CA */
+	X509                 *caCert;
+	/* current client certificate used to identify and sign */
+	X509                 *clCert;
+	/* subject name to be used in the cert template. note: if clcert is set,
+	 * subject name is read from there and this is ignored */
+	X509_NAME            *subjectName;
+	/* X509_NAME to set in PKIHEADER->recipient */ 
+	X509_NAME            *recipient;
+	/* This will contain the sender name copied from the last received PKIMessage */
+	X509_NAME            *sender;
+	/* names to be added to the cert template as the subjectAltName extension */
+	STACK_OF(GENERAL_NAME) *subjectAltNames;
+	/* Stack of CA certificates sent by the CA in a IP message */ 
+	STACK_OF(X509)       *caPubs;
+	/* stack of extraCerts to be included when sending a PKI message */
+	STACK_OF(X509)       *extraCertsOut;
+	/* stack of extraCerts received from remote */ 
+	STACK_OF(X509)       *extraCertsIn;
+	/* EVP_PKEY holding the *current* keys */
+	/* XXX this is not an ASN.1 type */
+	EVP_PKEY             *pkey;
+	/* *new* CLIENT certificate received from the CA */
+	/* XXX this should be a stack since there could be more than one */
+	X509                 *newClCert;
+	/* EVP_PKEY holding the *new* keys */
+	/* XXX this is not an ASN.1 type */
+	EVP_PKEY             *newPkey;
+	/* the current transaction ID */
+	ASN1_OCTET_STRING    *transactionID;
+	/* last nonce received */
+	ASN1_OCTET_STRING    *recipNonce;
+	/* Algorithm used for protection */
+	X509_ALGOR           *protectionAlgor;
+	/* compatibility mode */
+#define CMP_COMPAT_RFC		1
+#define CMP_COMPAT_CRYPTLIB	2
+	int	   compatibility;
+	char	  *serverName;
+	int	   serverPort;
+	char	  *serverPath;
+	char	  *proxyName;
+	int	   proxyPort;
+#define CMP_TRANSPORT_HTTP	1
+#define CMP_TRANSPORT_TCP	2
+	int	   transport;
+#if 0
+	/* this is actually CMP_PKIFREETEXT which is STACK_OF(ANS1_UTF8STRING) */
+	STACK_OF(ASN1_UTF8STRING)      *freeText;
+#endif
+	int	implicitConfirm;
+	/* XXX not setting transactionID test for PKI INFO */
+	int	setTransactionID;
+	/* XXX not setting senderNonce test for PKI INFO */
+	int	setSenderNonce;
+	/* if this is enabled, we will try to verify the entire CA certificate until
+	 * the trust anchor, and if this fails we reject the message */
+	int validatePath;
+
+#define CMP_POPO_NONE      0
+#define CMP_POPO_SIGNATURE 1
+#define CMP_POPO_ENCRCERT  2
+	/* Proof-of-posession mechanism used. Defaults to signature (POPOsignkingKey) */ 
+	int	popoMethod;
+	/* maximum time in secods to wait for an http transfer to complete
+	 * XXX note: only usable with libcurl! */
+	int	timeOut;
+
+	/* maximum number of times we attempt to poll the server for a response 
+	 * if a 'waiting' PKIStatus is received*/
+	int maxPollCount;
+
+	int lastStatus;
+
+	unsigned long failInfoCode;
+
+	/* log callback functions for error and debug messages */
+	cmp_logfn_t error_cb, debug_cb;
+
+	/* callback for letting the user check the received certificate and 
+	 * reject if necessary */
+	cmp_certConfFn_t certConf_cb;
+
+	/* */
+	X509_STORE *trusted_store;
+	X509_STORE *untrusted_store;
+} CMP_CTX;
+
+DECLARE_ASN1_FUNCTIONS(CMP_CTX)
+
+
+
+/* DECLARATIONS */
+
+/* cmp_msg.c */
+CMP_PKIMESSAGE *CMP_ir_new( CMP_CTX *ctx);
+CMP_PKIMESSAGE *CMP_cr_new( CMP_CTX *ctx);
+CMP_PKIMESSAGE *CMP_rr_new( CMP_CTX *ctx);
+CMP_PKIMESSAGE *CMP_certConf_new( CMP_CTX *ctx);
+CMP_PKIMESSAGE *CMP_kur_new( CMP_CTX *ctx);
+CMP_PKIMESSAGE *CMP_genm_new( CMP_CTX *ctx, int nid, char *value);
+#if 0
+CMP_PKIMESSAGE *CMP_ckuann_new( CMP_CTX *ctx);
+#endif
+CMP_PKIMESSAGE *CMP_ckuann_new( const X509 *oldCaCert, const EVP_PKEY *oldPkey, const X509 *newCaCert, const EVP_PKEY *newPkey);
+CMP_PKIMESSAGE *CMP_pollReq_new( CMP_CTX *ctx, int reqId);
+STACK_OF(X509) *CMP_build_cert_chain(X509_STORE *store, X509 *cert, int includeRoot);
+
+/* cmp_lib.c */
+
+long CMP_REVREP_PKIStatus_get( CMP_REVREP *revRep, long reqId);
+int CMP_PKIHEADER_set_version(CMP_PKIHEADER *hdr, int version);
+int CMP_PKIHEADER_set0_recipient(CMP_PKIHEADER *hdr, const X509_NAME *nm);
+int CMP_PKIHEADER_set1_recipient(CMP_PKIHEADER *hdr, const X509_NAME *nm);
+int CMP_PKIHEADER_set0_sender(CMP_PKIHEADER *hdr, const X509_NAME *nm);
+int CMP_PKIHEADER_set1_sender(CMP_PKIHEADER *hdr, const X509_NAME *nm);
+int CMP_PKIHEADER_set1_transactionID(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *transactionID);
+int CMP_PKIHEADER_set1_recipNonce(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *recipNonce);
+int CMP_PKIHEADER_set1_senderKID(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *senderKID);
+int CMP_PKIHEADER_set1_protectionAlgor(CMP_PKIHEADER *hdr, const X509_ALGOR *alg);
+X509_ALGOR *CMP_get_protectionAlgor_by_nid(int nid);
+X509_ALGOR *CMP_get_protectionAlgor_pbmac(void);
+int CMP_PKIHEADER_set_messageTime(CMP_PKIHEADER *hdr);
+int CMP_PKIMESSAGE_set_implicitConfirm(CMP_PKIMESSAGE *msg);
+int CMP_PKIMESSAGE_check_implicitConfirm(CMP_PKIMESSAGE *msg);
+
+int CMP_PKIHEADER_push0_freeText( CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text);
+int CMP_PKIHEADER_push1_freeText( CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text);
+int CMP_PKIHEADER_set0_freeText( CMP_PKIHEADER *hdr, STACK_OF(ASN1_UTF8STRING) *text);
+int CMP_PKIHEADER_set1_freeText( CMP_PKIHEADER *hdr, STACK_OF(ASN1_UTF8STRING) *text);
+
+int CMP_PKIHEADER_set1(CMP_PKIHEADER *hdr, CMP_CTX *ctx);
+
+ASN1_BIT_STRING *CMP_protection_new(CMP_PKIMESSAGE *pkimessage,
+				    X509_ALGOR *_algor,
+				    const EVP_PKEY *pkey,
+				    const ASN1_OCTET_STRING *secret);
+
+int CMP_CERTSTATUS_set_certHash( CMP_CERTSTATUS *certStatus, const X509 *cert);
+
+int CMP_PKIHEADER_generalInfo_item_push0(CMP_PKIHEADER *hdr, const CMP_INFOTYPEANDVALUE *itav);
+int CMP_PKIMESSAGE_genm_item_push0(CMP_PKIMESSAGE *msg, const CMP_INFOTYPEANDVALUE *itav);
+int CMP_ITAV_stack_item_push0(STACK_OF(CMP_INFOTYPEANDVALUE) **itav_sk_p, const CMP_INFOTYPEANDVALUE *itav);
+
+long CMP_PKISTATUSINFO_PKIstatus_get( CMP_PKISTATUSINFO *statusInfo);
+long CMP_ERRORMSGCONTENT_PKIStatus_get( CMP_ERRORMSGCONTENT *error);
+char *CMP_PKISTATUSINFO_PKIStatus_get_string( CMP_PKISTATUSINFO *statusInfo);
+char *CMP_ERRORMSGCONTENT_PKIStatus_get_string( CMP_ERRORMSGCONTENT *error);
+
+char *CMP_PKISTATUSINFO_PKIFailureInfo_get_string( CMP_PKISTATUSINFO *statusInfo);
+char *CMP_ERRORMSGCONTENT_PKIFailureInfo_get_string( CMP_ERRORMSGCONTENT *error);
+
+long CMP_CERTRESPONSE_PKIStatus_get( CMP_CERTRESPONSE *resp);
+long CMP_CERTREPMESSAGE_PKIStatus_get( CMP_CERTREPMESSAGE *certRep, long certReqId);
+
+char *CMP_CERTREPMESSAGE_PKIFailureInfoString_get0(CMP_CERTREPMESSAGE *certRep, long certReqId);
+STACK_OF(ASN1_UTF8STRING)* CMP_CERTRESPONSE_PKIStatusString_get0( CMP_CERTRESPONSE *resp);
+STACK_OF(ASN1_UTF8STRING)* CMP_CERTREPMESSAGE_PKIStatusString_get0( CMP_CERTREPMESSAGE *certRep, long certReqId);
+CMP_PKIFAILUREINFO *CMP_CERTREPMESSAGE_PKIFailureInfo_get0(CMP_CERTREPMESSAGE *certRep, long certReqId);
+
+int CMP_PKIFAILUREINFO_check( ASN1_BIT_STRING *failInfo, int codeBit);
+
+CMP_CERTRESPONSE *CMP_CERTREPMESSAGE_certResponse_get0( CMP_CERTREPMESSAGE *certRep, long certReqId);
+X509 *CMP_CERTREPMESSAGE_cert_get0( CMP_CERTREPMESSAGE *certRep, long certReqId);
+X509 *CMP_CERTREPMESSAGE_cert_get1( CMP_CERTREPMESSAGE *certRep, long certReqId);
+
+X509 *CMP_CERTREPMESSAGE_encCert_get1( CMP_CERTREPMESSAGE *certRep, long certReqId, EVP_PKEY *pkey);
+int CMP_CERTREPMESSAGE_certType_get( CMP_CERTREPMESSAGE *certRep, long certReqId);
+
+int CMP_PKIMESSAGE_set_bodytype( CMP_PKIMESSAGE *msg, int type);
+int CMP_PKIMESSAGE_get_bodytype( CMP_PKIMESSAGE *msg);
+
+char *CMP_PKIMESSAGE_parse_error_msg( CMP_PKIMESSAGE *msg, char *errormsg, int bufsize);
+
+/* cmp_vfy.c */
+int CMP_protection_verify(CMP_PKIMESSAGE *msg,
+			    X509_ALGOR *algor,
+			    EVP_PKEY *pkey,
+			    const ASN1_OCTET_STRING *secret);
+int CMP_cert_callback(int ok, X509_STORE_CTX *ctx);
+int CMP_validate_cert_path(CMP_CTX *cmp_ctx, STACK_OF(X509) *tchain, STACK_OF(X509) *uchain, X509 *cert);
+
+/* cmp_itav.c */
+/* CA Protocol Encryption Certificate */
+#define CMP_ITAV_CA_PROT_ENC_CERT	1
+/* Signing Key Pair Types */
+#define CMP_ITAV_SIGN_KEY_PAIR_TYPES	2
+/* Encryption/Key Agreement Key Pair Types */
+#define CMP_ITAV_ENC_KEY_PAIR_TYPES	3
+/* Preferred Symmetric Algorithm */
+#define CMP_ITAV_PREFERRED_SYMM_ALG	4
+/* Updated CA Key Pair */
+#define CMP_ITAV_CA_KEY_UPDATE_INFO	5
+/* CRL */
+#define CMP_ITAV_CURRENT_CRL		6
+/* Unsupported Object Identifiers */
+#define CMP_ITAV_UNSUPPORTED_OIDS	7
+/* Key Pair Parameters */
+#define CMP_ITAV_KEY_PAIR_PARAM_REQ	10
+#define CMP_ITAV_KEY_PAIR_PARAM_REP	11
+/* Revocation Passphrase */
+#define CMP_ITAV_REV_PASSPHRASE		12
+/* ImplicitConfirm */
+#define CMP_ITAV_IMPLICIT_CONFIRM	13
+/* ConfirmWaitTime */
+#define CMP_ITAV_CONFIRM_WAIT_TIME	14
+/* OrigPKIMessage */
+#define CMP_ITAV_ORIG_PKI_MESSAGE	15
+/* Supported Language Tags */
+#define CMP_ITAV_SUPP_LANG_TAGS		16
+/* Defines used by Cryptlib */
+/* 1.3.6.1.4.1.3029.3.1.1 */
+#define CMP_ITAV_CRYPTLIB		101
+/* 1.3.6.1.4.1.3029.3.1.2 */
+#define CMP_ITAV_CRYPTLIB_PKIBOOT	102
+CMP_INFOTYPEANDVALUE *CMP_INFOTYPEANDVALUE_new_by_def_noVal(int def);
+
+#if 0
+int CMP_INFOTYPEANDVALUE_set0(CMP_INFOTYPEANDVALUE *itav, ASN1_OBJECT *aobj, int ptype, void *pval);
+void CMP_INFOTYPEANDVALUE_get0(ASN1_OBJECT **paobj, int *pptype, void **ppval, CMP_INFOTYPEANDVALUE *itav);
+#endif
+
+#ifdef HAVE_CURL
+typedef CURL CMPBIO;
+#else
+typedef BIO CMPBIO;
+#endif
+
+/* from cmp_http.c */
+int CMP_PKIMESSAGE_http_perform(CMPBIO *cbio, const CMP_CTX *ctx, 
+								const CMP_PKIMESSAGE *msg,
+								CMP_PKIMESSAGE **out);
+int CMP_new_http_bio_ex(CMPBIO **cbio, const char* serverName, const int port, const char *srcip);
+int CMP_new_http_bio(CMPBIO **cbio, const char* serverName, const int port);
+int CMP_delete_http_bio( CMPBIO *cbio);
+
+/* from cmp_ses.c */
+X509 *CMP_doInitialRequestSeq( CMPBIO *cbio, CMP_CTX *ctx);
+X509 *CMP_doCertificateRequestSeq( CMPBIO *cbio, CMP_CTX *ctx);
+int CMP_doRevocationRequestSeq( CMPBIO *cbio, CMP_CTX *ctx);
+X509 *CMP_doKeyUpdateRequestSeq( CMPBIO *cbio, CMP_CTX *ctx);
+int CMP_doPKIInfoReqSeq( CMPBIO *cbio, CMP_CTX *ctx);
+char *CMP_doGeneralMessageSeq( CMPBIO *cbio, CMP_CTX *ctx, int nid, char *value);
+CMP_CAKEYUPDANNCONTENT *CMP_doCAKeyUpdateReq( CMPBIO *cbio, CMP_CTX *ctx);
+X509_CRL *CMP_doCurrentCRLReq( CMPBIO *cbio, CMP_CTX *ctx);
+
+/* from cmp_ctx.c */
+int CMP_CTX_init( CMP_CTX *ctx);
+int CMP_CTX_set0_trustedStore( CMP_CTX *ctx, X509_STORE *store);
+int CMP_CTX_set0_untrustedStore( CMP_CTX *ctx, X509_STORE *store);
+void CMP_CTX_delete(CMP_CTX *ctx);
+CMP_CTX *CMP_CTX_create(void);
+int CMP_CTX_set_error_callback( CMP_CTX *ctx, cmp_logfn_t cb);
+int CMP_CTX_set_debug_callback( CMP_CTX *ctx, cmp_logfn_t cb);
+int CMP_CTX_set_certConf_callback( CMP_CTX *ctx, cmp_certConfFn_t cb);
+int CMP_CTX_set1_referenceValue( CMP_CTX *ctx, const unsigned char *ref, size_t len);
+int CMP_CTX_set1_secretValue( CMP_CTX *ctx, const unsigned char *sec, const size_t len);
+int CMP_CTX_set1_regToken( CMP_CTX *ctx, const char *regtoken, const size_t len);
+int CMP_CTX_set1_caCert( CMP_CTX *ctx, const X509 *cert);
+int CMP_CTX_set1_clCert( CMP_CTX *ctx, const X509 *cert);
+int CMP_CTX_set1_subjectName( CMP_CTX *ctx, const X509_NAME *name);
+int CMP_CTX_set1_recipient( CMP_CTX *ctx, const X509_NAME *name);
+int CMP_CTX_subjectAltName_push1( CMP_CTX *ctx, const GENERAL_NAME *name);
+int CMP_CTX_set1_sender( CMP_CTX *ctx, const X509_NAME *name);
+X509_NAME* CMP_CTX_sender_get( CMP_CTX *ctx);
+STACK_OF(X509)* CMP_CTX_caPubs_get1( CMP_CTX *ctx);
+X509 *CMP_CTX_caPubs_pop( CMP_CTX *ctx);
+int CMP_CTX_caPubs_num( CMP_CTX *ctx);
+int CMP_CTX_set1_caPubs( CMP_CTX *ctx, const STACK_OF(X509) *caPubs);
+
+int CMP_CTX_set1_extraCertsOut( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsOut);
+int CMP_CTX_extraCertsOut_push1( CMP_CTX *ctx, const X509 *val);
+int CMP_CTX_extraCertsOut_num( CMP_CTX *ctx);
+STACK_OF(X509)* CMP_CTX_extraCertsIn_get1( CMP_CTX *ctx);
+int CMP_CTX_set1_extraCertsIn( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsIn);
+X509 *CMP_CTX_extraCertsIn_pop( CMP_CTX *ctx);
+int CMP_CTX_extraCertsIn_num( CMP_CTX *ctx);
+
+int CMP_CTX_set1_newClCert( CMP_CTX *ctx, const X509 *cert);
+int CMP_CTX_set0_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+int CMP_CTX_set1_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+int CMP_CTX_set0_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+int CMP_CTX_set1_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+int CMP_CTX_set1_transactionID( CMP_CTX *ctx, const ASN1_OCTET_STRING *id);
+int CMP_CTX_set1_senderNonce( CMP_CTX *ctx, const ASN1_OCTET_STRING *nonce);
+int CMP_CTX_set1_recipNonce( CMP_CTX *ctx, const ASN1_OCTET_STRING *nonce);
+int CMP_CTX_set1_protectionAlgor( CMP_CTX *ctx, const X509_ALGOR *algor);
+int CMP_CTX_set_compatibility( CMP_CTX *ctx, const int mode);
+int CMP_CTX_set1_serverName( CMP_CTX *ctx, const char *name);
+int CMP_CTX_set1_serverPort( CMP_CTX *ctx, int port);
+int CMP_CTX_set1_proxyName( CMP_CTX *ctx, const char *name);
+int CMP_CTX_set1_proxyPort( CMP_CTX *ctx, int port);
+int CMP_CTX_set1_timeOut( CMP_CTX *ctx, int time);
+int CMP_CTX_set1_popoMethod( CMP_CTX *ctx, int method);
+int CMP_CTX_set1_serverPath( CMP_CTX *ctx, const char *path);
+#define CMP_ALG_PBMAC 1
+#define CMP_ALG_SIG   2
+int CMP_CTX_set_protectionAlgor( CMP_CTX *ctx, const int algId);
+int CMP_CTX_set_failInfoCode(CMP_CTX *ctx, CMP_PKIFAILUREINFO *failInfo);
+unsigned long CMP_CTX_failInfoCode_get(CMP_CTX *ctx);
+#define CMP_CTX_OPT_UNSET           0
+#define CMP_CTX_OPT_SET             1
+#define CMP_CTX_OPT_IMPLICITCONFIRM 1
+#define CMP_CTX_OPT_POPMETHOD       2
+#define CMP_CTX_OPT_VALIDATEPATH    3
+#define CMP_CTX_OPT_MAXPOLLCOUNT    4
+int CMP_CTX_set_option( CMP_CTX *ctx, const int opt, const int val);
+#if 0
+int CMP_CTX_push_freeText( CMP_CTX *ctx, const char *text);
+#endif
+
+#ifdef HAVE_CURL
+long CMP_get_http_code(const CMPBIO *bio);
+#endif
+
+/* BIO definitions */
+#define d2i_CMP_PKIMESSAGE_bio(bp,p) ASN1_d2i_bio_of(CMP_PKIMESSAGE,CMP_PKIMESSAGE_new,d2i_CMP_PKIMESSAGE,bp,p)
+#define i2d_CMP_PKIMESSAGE_bio(bp,o) ASN1_i2d_bio_of(CMP_PKIMESSAGE,i2d_CMP_PKIMESSAGE,bp,o)
+#define d2i_CMP_PROTECTEDPART_bio(bp,p) ASN1_d2i_bio_of(CMP_PROTECTEDPART,CMP_PROTECTEDPART_new,d2i_CMP_PROTECTEDPART,bp,p)
+#define i2d_CMP_PROTECTEDPART_bio(bp,o) ASN1_i2d_bio_of(CMP_PROTECTEDPART,i2d_CMP_PROTECTEDPART,bp,o)
+
+#define CMP_VERSION 2L
+
+#ifndef CMP_printf
+	#ifdef CMP_DEBUG
+		void CMP_printf(const CMP_CTX *ctx, const char *fmt, ...);
+	#else
+		#define CMP_printf(...) //
+	#endif
+#endif
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_CMP_strings(void);
+
+/* Error codes for the CMP functions. */
+
+/* Function codes. */
+#define CMP_F_CERTREP_GET_CERTIFICATE			 162
+#define CMP_F_CMP_CERTCONF_NEW				 100
+#define CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1		 101
+#define CMP_F_CMP_CERTSTATUS_SET_CERTHASH		 102
+#define CMP_F_CMP_CKUANN_NEW				 103
+#define CMP_F_CMP_CR_NEW				 104
+#define CMP_F_CMP_CTX_CAPUBS_GET1			 105
+#define CMP_F_CMP_CTX_CAPUBS_NUM			 106
+#define CMP_F_CMP_CTX_CAPUBS_POP			 107
+#define CMP_F_CMP_CTX_CREATE				 108
+#define CMP_F_CMP_CTX_EXTRACERTSIN_GET1			 109
+#define CMP_F_CMP_CTX_EXTRACERTSIN_NUM			 110
+#define CMP_F_CMP_CTX_EXTRACERTSIN_POP			 111
+#define CMP_F_CMP_CTX_EXTRACERTS_NUM			 112
+#define CMP_F_CMP_CTX_EXTRACERTS_PUSH1			 113
+#define CMP_F_CMP_CTX_INIT				 114
+#define CMP_F_CMP_CTX_SET0_NEWPKEY			 115
+#define CMP_F_CMP_CTX_SET0_PKEY				 116
+#define CMP_F_CMP_CTX_SET1_CACERT			 117
+#define CMP_F_CMP_CTX_SET1_CAEXTRACERTS			 118
+#define CMP_F_CMP_CTX_SET1_CAPUBS			 119
+#define CMP_F_CMP_CTX_SET1_CLCERT			 120
+#define CMP_F_CMP_CTX_SET1_EXTRACERTS			 121
+#define CMP_F_CMP_CTX_SET1_NEWCLCERT			 122
+#define CMP_F_CMP_CTX_SET1_NEWPKEY			 123
+#define CMP_F_CMP_CTX_SET1_PKEY				 124
+#define CMP_F_CMP_CTX_SET1_POPOMETHOD			 125
+#define CMP_F_CMP_CTX_SET1_PROTECTIONALGOR		 126
+#define CMP_F_CMP_CTX_SET1_PROXYNAME			 127
+#define CMP_F_CMP_CTX_SET1_PROXYPORT			 128
+#define CMP_F_CMP_CTX_SET1_RECIPIENT			 129
+#define CMP_F_CMP_CTX_SET1_RECIPNONCE			 130
+#define CMP_F_CMP_CTX_SET1_REFERENCEVALUE		 131
+#define CMP_F_CMP_CTX_SET1_REGTOKEN			 163
+#define CMP_F_CMP_CTX_SET1_SECRETVALUE			 132
+#define CMP_F_CMP_CTX_SET1_SENDER			 133
+#define CMP_F_CMP_CTX_SET1_SERVERNAME			 134
+#define CMP_F_CMP_CTX_SET1_SERVERPATH			 135
+#define CMP_F_CMP_CTX_SET1_SERVERPORT			 136
+#define CMP_F_CMP_CTX_SET1_SUBJECTNAME			 137
+#define CMP_F_CMP_CTX_SET1_TIMEOUT			 138
+#define CMP_F_CMP_CTX_SET1_TRANSACTIONID		 139
+#define CMP_F_CMP_CTX_SET_COMPATIBILITY			 140
+#define CMP_F_CMP_CTX_SET_PROTECTIONALGOR		 141
+#define CMP_F_CMP_CTX_SUBJECTALTNAME_PUSH1		 142
+#define CMP_F_CMP_DOCERTIFICATEREQUESTSEQ		 143
+#define CMP_F_CMP_DOINITIALREQUESTSEQ			 144
+#define CMP_F_CMP_DOKEYUPDATEREQUESTSEQ			 145
+#define CMP_F_CMP_DOPKIINFOREQSEQ			 146
+#define CMP_F_CMP_DOREVOCATIONREQUESTSEQ		 147
+#define CMP_F_CMP_GENM_NEW				 148
+#define CMP_F_CMP_IR_NEW				 149
+#define CMP_F_CMP_KUR_NEW				 150
+#define CMP_F_CMP_NEW_HTTP_BIO_EX			 151
+#define CMP_F_CMP_PKIMESSAGE_HTTP_BIO_RECV		 152
+#define CMP_F_CMP_PKIMESSAGE_HTTP_BIO_SEND		 153
+#define CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM		 154
+#define CMP_F_CMP_PKISTATUSINFO_PKISTATUS_GET_STRING	 155
+#define CMP_F_CMP_PROTECTION_NEW			 156
+#define CMP_F_CMP_PROTECTION_VERIFY			 157
+#define CMP_F_CMP_RR_NEW				 158
+#define CMP_F_CMP_VALIDATE_CERT_PATH			 159
+#define CMP_F_PKEY_DUP					 160
+#define CMP_F_TRY_POLLING				 161
+
+/* Reason codes. */
+#define CMP_R_CERTIFICATE_NOT_FOUND			 100
+#define CMP_R_COULD_NOT_VALIDATE_CERTIFICATE_PATH	 101
+#define CMP_R_CP_NOT_RECEIVED				 102
+#define CMP_R_CURL_ERROR				 103
+#define CMP_R_DEPRECATED_FUNCTION			 104
+#define CMP_R_ERROR_CALCULATING_PROTECTION		 105
+#define CMP_R_ERROR_CREATING_CERTCONF			 106
+#define CMP_R_ERROR_CREATING_CKUANN			 107
+#define CMP_R_ERROR_CREATING_CR				 108
+#define CMP_R_ERROR_CREATING_GENM			 109
+#define CMP_R_ERROR_CREATING_IR				 110
+#define CMP_R_ERROR_CREATING_KUR			 111
+#define CMP_R_ERROR_CREATING_RR				 112
+#define CMP_R_ERROR_DECODING_CERTIFICATE		 113
+#define CMP_R_ERROR_DECRYPTING_CERTIFICATE		 114
+#define CMP_R_ERROR_DECRYPTING_ENCCERT			 115
+#define CMP_R_ERROR_DECRYPTING_KEY			 116
+#define CMP_R_ERROR_DECRYPTING_SYMMETRIC_KEY		 117
+#define CMP_R_ERROR_PARSING_PKISTATUS			 118
+#define CMP_R_ERROR_SETTING_CERTHASH			 119
+#define CMP_R_ERROR_SETTING_PROTECTION_ALGORITHM	 120
+#define CMP_R_ERROR_VALIDATING_PROTECTION		 121
+#define CMP_R_ERROR_VERIFYING_PROTECTION		 122
+#define CMP_R_FAILED_TO_DECODE_PKIMESSAGE		 148
+#define CMP_R_FAILED_TO_DETERMINE_PROTECTION_ALGORITHM	 123
+#define CMP_R_GENP_NOT_RECEIVED				 124
+#define CMP_R_INVALID_ARGS				 125
+#define CMP_R_INVALID_CONTENT_TYPE			 147
+#define CMP_R_INVALID_CONTEXT				 126
+#define CMP_R_INVALID_KEY				 127
+#define CMP_R_INVALID_PARAMETERS			 128
+#define CMP_R_IP_NOT_RECEIVED				 129
+#define CMP_R_KUP_NOT_RECEIVED				 130
+#define CMP_R_NO_CERTIFICATE_RECEIVED			 131
+#define CMP_R_NO_SECRET_VALUE_GIVEN_FOR_PBMAC		 132
+#define CMP_R_NO_TRUSTED_CERTIFICATES_SET		 133
+#define CMP_R_NULL_ARGUMENT				 134
+#define CMP_R_PKIBODY_ERROR				 135
+#define CMP_R_PKICONF_NOT_RECEIVED			 136
+#define CMP_R_POLLING_FAILED				 150
+#define CMP_R_RECEIVED_INVALID_RESPONSE_TO_POLLREQ	 137
+#define CMP_R_REQUEST_REJECTED_BY_CA			 138
+#define CMP_R_RP_NOT_RECEIVED				 139
+#define CMP_R_SERVER_NOT_REACHABLE			 149
+#define CMP_R_SUBJECT_NAME_NOT_SET			 140
+#define CMP_R_UNABLE_TO_CREATE_CONTEXT			 141
+#define CMP_R_UNKNOWN_ALGORITHM_ID			 142
+#define CMP_R_UNKNOWN_CIPHER				 143
+#define CMP_R_UNKNOWN_PKISTATUS				 144
+#define CMP_R_UNSUPPORTED_ALGORITHM			 145
+#define CMP_R_UNSUPPORTED_KEY_TYPE			 146
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
Index: openssl-1.0.0i-cmp/crypto/cmp/cmp_msg.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/cmp_msg.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/cmp_msg.c	(revision 469)
@@ -0,0 +1,735 @@
+/* crypto/cmp/cmp_msg.c
+ * Functions for creating CMP (RFC 4210) messages for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ * 2008 - Sami Lehtonen - added CMP_cr_new()
+ *                      - bugfix in CMP_certConf_new(): pkey or ref/secret pair is enough
+ * 06/2010 - Miikka Viljanen - Report errors with OpenSSL error codes instead
+ *                             of printf statements.
+ * 06/10/2010 - Martin Peylo - fixed potential NPD in CMP_ir_new(), CMP_cr_new() and 
+ *                             CMP_kur_new() and CMP_certConf_new() in case of failing 
+ *                             OPENSSL_malloc() and potential MLKS in error cases
+ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/cmp.h>
+#include <openssl/x509.h>
+#include <openssl/safestack.h>
+#include <openssl/err.h>
+
+#include <string.h>
+
+/* ############################################################################ 
+ * Takes a stack of GENERAL_NAMEs and adds them to the given extension stack.
+ * ############################################################################ */
+static int add_altname_extensions(X509_EXTENSIONS **extensions, STACK_OF(GENERAL_NAME) *altnames) {
+	X509_EXTENSION *ext = NULL;
+	unsigned char *der = NULL;
+	int derlen = 0;
+	ASN1_OCTET_STRING *str = ASN1_OCTET_STRING_new();
+
+	ASN1_seq_pack_GENERAL_NAME(altnames, i2d_GENERAL_NAME, &der, &derlen);
+
+	ASN1_STRING_set(str, der, derlen);
+	X509_EXTENSION_create_by_NID(&ext, NID_subject_alt_name, 0, str);
+
+	ASN1_OCTET_STRING_free(str);
+	OPENSSL_free(der);
+
+	X509v3_add_ext(extensions, ext, 0);
+
+	return 1;
+}
+
+static ASN1_OCTET_STRING *get_subject_key_id(const X509 *cert) {
+	const unsigned char *subjKeyIDStrDer = NULL;
+	ASN1_OCTET_STRING *subjKeyIDStr = NULL;
+	X509_EXTENSION *ex = NULL;
+	int subjKeyIDLoc = -1;
+
+	subjKeyIDLoc = X509_get_ext_by_NID( (X509*) cert, NID_subject_key_identifier, -1);
+	if (subjKeyIDLoc == -1) return NULL;
+
+	/* found a subject key ID */
+	ex = sk_X509_EXTENSION_value( cert->cert_info->extensions, subjKeyIDLoc);
+
+	subjKeyIDStrDer = (const unsigned char *) ex->value->data;
+	subjKeyIDStr = d2i_ASN1_OCTET_STRING( NULL, &subjKeyIDStrDer, ex->value->length);
+
+	return subjKeyIDStr;
+}
+
+static int add_extraCerts(CMP_CTX *ctx, CMP_PKIMESSAGE *msg) {
+	if (ctx->clCert) {
+		if( !msg->extraCerts && !(msg->extraCerts = sk_X509_new_null())) goto err;
+
+		/* if we have untrusted store, try to add all the intermediate certs and our own */
+		if (ctx->untrusted_store) {
+			STACK_OF(X509) *chain = CMP_build_cert_chain(ctx->untrusted_store, ctx->clCert, 0);
+			int i;
+			for(i = 0; i < sk_X509_num(chain); i++)
+				sk_X509_push(msg->extraCerts, sk_X509_value(chain, i));
+			sk_X509_free(chain);
+		}
+		if (sk_X509_num(msg->extraCerts) == 0)
+			/* Make sure that at least our own cert gets sent */
+			sk_X509_push(msg->extraCerts, X509_dup(ctx->clCert));
+	}
+
+	/* add any extraCertsOut that are set in the context */
+	if (sk_X509_num(ctx->extraCertsOut) > 0) {
+		int i;
+		if( !msg->extraCerts && !(msg->extraCerts = sk_X509_new_null())) goto err;
+		for (i = 0; i < sk_X509_num(ctx->extraCertsOut); i++)
+			sk_X509_push(msg->extraCerts, X509_dup(sk_X509_value(ctx->extraCertsOut, i)));
+	}
+
+	return 1;
+err:
+	return 0;
+}
+
+/* ############################################################################ 
+ * Returns the trust chain for a given certificate up to and including
+ * the trust anchor
+ * ############################################################################ */
+STACK_OF(X509) *CMP_build_cert_chain(X509_STORE *store, X509 *cert, int includeRoot) {
+	X509_STORE_CTX *csc;
+	STACK_OF(X509) *chain, *certs = NULL;
+	X509 *last_cert = cert;
+	int i;
+	X509_STORE_set_flags(store, 0);
+
+	if( !(csc = X509_STORE_CTX_new()))
+		return NULL;
+	if( !(chain = sk_X509_new_null())) {
+		X509_STORE_CTX_free(csc);
+		return NULL;
+	}
+
+	if(!X509_STORE_CTX_init(csc,store,cert,NULL))
+		goto err;
+
+	sk_X509_push(chain, X509_dup(cert));
+	while ((certs = X509_STORE_get1_certs(csc, X509_get_issuer_name(last_cert))) != NULL) {
+		X509 *issuer = NULL;
+		for (i = 0; i < sk_X509_num(certs); i++) {
+			X509 *current_cert = sk_X509_value(certs, i);
+			EVP_PKEY *pubkey = X509_get_pubkey(current_cert);
+			if (X509_verify(last_cert, pubkey)) {
+				EVP_PKEY_free(pubkey);
+				issuer = current_cert;
+				break;
+			}
+			EVP_PKEY_free(pubkey);
+		}
+		sk_X509_pop_free(certs, X509_free);
+		if (issuer == last_cert) {
+			if (includeRoot)
+				sk_X509_push(chain, X509_dup(last_cert));
+			break;
+		}
+		if (issuer == NULL) break;
+		last_cert = issuer;
+		sk_X509_push(chain, X509_dup(last_cert));
+	}
+	X509_STORE_CTX_free(csc);
+
+	return chain;
+err:
+	X509_STORE_CTX_free(csc);
+	sk_X509_free(chain);
+	return NULL;
+}
+
+/* ############################################################################ *
+ * Creates a new polling request PKIMessage for the given request ID
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_pollReq_new( CMP_CTX *ctx, int reqId) {
+	CMP_PKIMESSAGE *msg = NULL;
+	CMP_POLLREQ    *preq = NULL;
+	if (!ctx) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+
+	if( !CMP_PKIHEADER_set1( msg->header, ctx)) goto err;
+
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_POLLREQ);
+
+	preq = CMP_POLLREQ_new();
+	/* TODO support multiple cert request ids to poll */
+	ASN1_INTEGER_set(preq->certReqId, reqId);
+	if (!(msg->body->value.pollReq = sk_CMP_POLLREQ_new_null()))
+		goto err;
+
+	sk_CMP_POLLREQ_push(msg->body->value.pollReq, preq);
+
+	if( !(msg->protection = CMP_protection_new( msg, NULL, (EVP_PKEY *) ctx->pkey, ctx->secretValue))) 
+		goto err;
+
+	return msg;
+
+err:
+	return NULL;
+}
+
+/* ############################################################################ *
+ * Create a new Initial Request PKIMessage
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_ir_new( CMP_CTX *ctx) {
+	CMP_PKIMESSAGE  *msg=NULL;
+	CRMF_CERTREQMSG *certReq0=NULL;
+	X509_EXTENSIONS *extensions = NULL;
+	X509_NAME *subject=NULL;
+
+	/* check if all necessary options are set */
+	if (!ctx) goto err;
+#if 0
+	if (!ctx->caCert) goto err;
+#endif
+	/* for authentication we need either a reference value/secret or external identity certificate and private key */
+	if (!((ctx->referenceValue && ctx->secretValue) || (ctx->pkey && ctx->clCert))) goto err;
+	if (!ctx->newPkey) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+
+	/* E.7: get the subject_key_id from the external identity certificate to set it later as senderKID */
+	/* this actually seems to be explicity required not to be done by RFC 4210 (E.7, end of page 81)
+	 * HOWEVER, it seems as if the RFC is wrong here and it confuses the different
+	 * use cases of the senderKID field (referenceNUM vs. Key Identifier) */
+	/* TODO: make this generic and bring it close together with CMP_protection_new() */
+	if(ctx->clCert)
+	{
+		ASN1_OCTET_STRING *subjKeyIDStr = get_subject_key_id(ctx->clCert);
+		if (subjKeyIDStr) {
+			CMP_CTX_set1_referenceValue( ctx, subjKeyIDStr->data, subjKeyIDStr->length);
+			ASN1_OCTET_STRING_free(subjKeyIDStr);
+		}
+	}
+
+	if( !CMP_PKIHEADER_set1( msg->header, ctx)) goto err;
+
+	if (ctx->implicitConfirm)
+		if (! CMP_PKIMESSAGE_set_implicitConfirm(msg)) goto err;
+
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_IR);
+
+	if (ctx->subjectName)
+		subject = ctx->subjectName;
+	else if (ctx->clCert) /* E.7 */
+		subject = X509_get_subject_name(ctx->clCert);
+	else
+		subject = NULL;
+
+	if (sk_GENERAL_NAME_num(ctx->subjectAltNames) > 0)
+		add_altname_extensions(&extensions, ctx->subjectAltNames);
+
+	/* certReq 0 is not freed on error, but that's because it will become part of ir and is freed there */
+	if( !(certReq0 = CRMF_cr_new(0L, ctx->newPkey, subject, ctx->compatibility, ctx->popoMethod, extensions))) goto err;
+
+	if (ctx->regToken && !CRMF_CERTREQMSG_set1_regInfo_regToken(certReq0, ctx->regToken)) goto err;
+
+	if (extensions) sk_X509_EXTENSION_pop_free(extensions, X509_EXTENSION_free);
+
+	if( !(msg->body->value.ir = sk_CRMF_CERTREQMSG_new_null())) goto err;
+	sk_CRMF_CERTREQMSG_push( msg->body->value.ir, certReq0);
+
+	add_extraCerts(ctx, msg);
+
+	/* XXX what about setting the optional 2nd certreqmsg? */
+
+	if( !(msg->protection = CMP_protection_new( msg, NULL, (EVP_PKEY *) ctx->pkey, ctx->secretValue))) goto err;
+
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_IR_NEW, CMP_R_ERROR_CREATING_IR);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+
+	return NULL;
+}
+
+/* ############################################################################ *
+ * Creates a new Revocation Request PKIMessage
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_rr_new( CMP_CTX *ctx) {
+	CMP_PKIMESSAGE  *msg=NULL;
+	CRMF_CERTTEMPLATE *certTpl=NULL;
+	X509_NAME *subject=NULL;
+	CMP_REVDETAILS *rd=NULL;
+	ASN1_OCTET_STRING *subjKeyIDStr=NULL;
+
+	/* check if all necessary options are set */
+	if (!ctx) goto err;
+#if 0
+	if (!ctx->caCert) goto err;
+#endif
+	if (!ctx->clCert) goto err;
+	if (!ctx->pkey) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_RR);
+
+	if ((subjKeyIDStr = get_subject_key_id(ctx->clCert)) != NULL) {
+		CMP_CTX_set1_referenceValue( ctx, subjKeyIDStr->data, subjKeyIDStr->length);
+		ASN1_OCTET_STRING_free(subjKeyIDStr);
+	}
+		
+	if( !CMP_PKIHEADER_set1( msg->header, ctx)) goto err;
+
+	if (ctx->implicitConfirm)
+		if (! CMP_PKIMESSAGE_set_implicitConfirm(msg)) goto err;
+
+	certTpl = CRMF_CERTTEMPLATE_new();
+	/* Set the subject from the previous certificate */
+	subject = X509_get_subject_name(ctx->clCert);
+	X509_NAME_set(&certTpl->subject, subject);
+	X509_PUBKEY_set(&certTpl->publicKey, (EVP_PKEY*) ctx->pkey);
+	certTpl->serialNumber = ASN1_INTEGER_dup(ctx->clCert->cert_info->serialNumber);
+	X509_NAME_set(&certTpl->issuer, ctx->clCert->cert_info->issuer);
+
+	rd = CMP_REVDETAILS_new();
+	rd->certDetails = certTpl;
+
+	if( !(msg->body->value.rr = sk_CMP_REVDETAILS_new_null())) goto err;
+	sk_CMP_REVDETAILS_push( msg->body->value.rr, rd);
+
+	msg->protection = CMP_protection_new( msg, NULL, (EVP_PKEY*) ctx->pkey, ctx->secretValue);
+	if (!msg->protection) goto err;
+
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_RR_NEW, CMP_R_ERROR_CREATING_RR);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+
+	return NULL;
+}
+
+
+/* ############################################################################ *
+ * Creates a new Certificate Request PKIMessage
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_cr_new( CMP_CTX *ctx) {
+	CMP_PKIMESSAGE  *msg=NULL;
+	CRMF_CERTREQMSG *certReq0=NULL;
+
+	X509_NAME *subject=NULL;
+	ASN1_OCTET_STRING *subjKeyIDStr=NULL;
+
+	/* check if all necessary options are set */
+	if (!ctx) goto err;
+	if (!ctx->caCert) goto err;
+	if (!ctx->clCert) goto err;
+	if (!ctx->pkey) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+
+	subjKeyIDStr = get_subject_key_id(ctx->clCert);
+	if (subjKeyIDStr) {
+		CMP_CTX_set1_referenceValue( ctx, subjKeyIDStr->data, subjKeyIDStr->length);
+		ASN1_OCTET_STRING_free(subjKeyIDStr);
+	}
+
+	if( !CMP_PKIHEADER_set1( msg->header, ctx)) goto err;
+
+	if (ctx->implicitConfirm)
+		if (! CMP_PKIMESSAGE_set_implicitConfirm(msg)) goto err;
+
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_CR);
+
+	/* Set the subject from the previous certificate */
+	subject = X509_get_subject_name(ctx->clCert);
+
+	/* certReq 0 is not freed on error, but that's because it will become part of ir and is freed there */
+	if( !(certReq0 = CRMF_cr_new(0L, ctx->pkey, subject, ctx->compatibility, ctx->popoMethod, NULL))) goto err;
+
+	if( !(msg->body->value.cr = sk_CRMF_CERTREQMSG_new_null())) goto err;
+	sk_CRMF_CERTREQMSG_push( msg->body->value.cr, certReq0);
+
+	add_extraCerts(ctx, msg);
+
+	/* XXX what about setting the optional 2nd certreqmsg? */
+
+	msg->protection = CMP_protection_new( msg, NULL, (EVP_PKEY*) ctx->pkey, NULL);
+	if (!msg->protection) goto err;
+
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_CR_NEW, CMP_R_ERROR_CREATING_CR);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+
+	return NULL;
+}
+
+
+/* ############################################################################ *
+ * Creates a new Key Update Request PKIMessage
+ * TODO: KUR can actually also be done with MSG_MAC_ALG, check D.6, 2 *
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_kur_new( CMP_CTX *ctx) {
+	CMP_PKIMESSAGE *msg=NULL;
+	CRMF_CERTREQMSG *certReq0=NULL;
+	X509_NAME *subject=NULL;
+
+	/* check if all necessary options are set */
+	if (!ctx) goto err;
+	if (!ctx->caCert) goto err;
+	if (!ctx->clCert) goto err;
+	if (!ctx->pkey) goto err;
+	if (!ctx->newPkey) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+
+	/* get the subject_key_id from the certificate to set it later as senderKID */
+	/* this is not needed in case protection is done with MSG_MAC_ALG (what is not
+	 * implemented so far) */
+	if( ctx->clCert ) {
+		ASN1_OCTET_STRING *subjKeyIDStr = get_subject_key_id(ctx->clCert);
+		if (subjKeyIDStr) {
+			CMP_CTX_set1_referenceValue( ctx, subjKeyIDStr->data, subjKeyIDStr->length);
+			ASN1_OCTET_STRING_free(subjKeyIDStr);
+		}
+	}
+
+	if( !CMP_PKIHEADER_set1(msg->header, ctx)) goto err;
+
+	if (ctx->implicitConfirm)
+		if (! CMP_PKIMESSAGE_set_implicitConfirm( msg)) goto err;
+
+	if (ctx->subjectName)
+		subject = ctx->subjectName;
+	else
+		subject = X509_get_subject_name( (X509*) ctx->clCert);
+
+	/* certReq 0 is not freed on error, but that's because it will become part of kur and is freed there */
+	if( !(certReq0 = CRMF_cr_new(0L, ctx->newPkey, subject, ctx->compatibility, ctx->popoMethod, NULL))) goto err;
+
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_KUR);
+	if( !(msg->body->value.kur = sk_CRMF_CERTREQMSG_new_null())) goto err;
+
+	/* identify our cert */
+	/* this is like it is described in the RFC:
+	 * set oldCertId in "controls" of the CRMF cr message
+	 * CL does not like this to be set */
+	if( ctx->compatibility != CMP_COMPAT_CRYPTLIB) {
+		CRMF_CERTREQMSG_set1_control_oldCertId( certReq0, ctx->clCert);
+	}
+
+	/* this is like CL likes it:
+	 * set id-aa-signingCertificate "generalInfo" of the CMP header */
+	if( ctx->compatibility == CMP_COMPAT_CRYPTLIB) {
+		unsigned int hashLen;
+		unsigned char hash[EVP_MAX_MD_SIZE];
+		ESS_CERT_ID *essCertId = NULL;
+		ESS_SIGNING_CERT *signingCert = NULL;
+		CMP_INFOTYPEANDVALUE *itav = NULL;
+		STACK_OF(ESS_SIGNING_CERT) *set = NULL;
+
+		if (!X509_digest(ctx->clCert, EVP_sha1(), hash, &hashLen)) goto err;
+		essCertId = ESS_CERT_ID_new();
+		if (!ASN1_OCTET_STRING_set(essCertId->hash, hash, hashLen)) goto err;
+
+		signingCert = ESS_SIGNING_CERT_new();
+		if( !signingCert->cert_ids) {
+			if( !(signingCert->cert_ids = sk_ESS_CERT_ID_new_null())) goto err;
+		}
+		if(!sk_ESS_CERT_ID_push(signingCert->cert_ids, essCertId)) goto err;
+
+		if (!(set = sk_ESS_SIGNING_CERT_new_null())) goto err;
+		sk_ESS_SIGNING_CERT_push(set, signingCert);
+		itav = CMP_INFOTYPEANDVALUE_new();
+		itav->infoType = OBJ_nid2obj( NID_id_smime_aa_signingCertificate);
+		itav->infoValue.signingCertificate = set;
+		CMP_PKIHEADER_generalInfo_item_push0( msg->header, itav);
+	}
+
+	sk_CRMF_CERTREQMSG_push( msg->body->value.kur, certReq0);
+
+	add_extraCerts(ctx, msg);
+
+	/* XXX what about setting the optional 2nd certreqmsg? */
+
+	msg->protection = CMP_protection_new( msg, NULL, (EVP_PKEY*) ctx->pkey, NULL);
+	if (!msg->protection) goto err;
+
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_KUR_NEW, CMP_R_ERROR_CREATING_KUR);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+	return NULL;
+}
+
+
+/* ############################################################################ *
+ * Creates a new Certificate Confirmation PKIMessage
+ * ############################################################################ */
+CMP_PKIMESSAGE * CMP_certConf_new( CMP_CTX *ctx) {
+
+	CMP_PKIMESSAGE *msg=NULL;
+	CMP_CERTSTATUS *certStatus=NULL;
+
+	/* check if all necessary options are set */
+	if (!ctx) goto err;
+	/* if (!ctx->caCert) goto err; */
+	if (!ctx->newClCert) goto err;
+	if ( (!ctx->pkey) && ((!ctx->referenceValue) && (!ctx->secretValue)) ) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+
+	if( !CMP_PKIHEADER_set1(msg->header, ctx)) goto err;
+
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_CERTCONF);
+
+	if( !(certStatus = CMP_CERTSTATUS_new())) goto err;
+
+	/* set the # of the certReq */
+	ASN1_INTEGER_set(certStatus->certReqId,0L);
+
+	/*
+        -- the hash of the certificate, using the same hash algorithm
+        -- as is used to create and verify the certificate signature
+	*/
+	/* TODO: iterate through all the certificates in order to confirm them all */
+
+/* XXX the former value should be freed */
+	CMP_CERTSTATUS_set_certHash( certStatus, ctx->newClCert);
+
+	if (ctx->certConf_cb && ctx->newClCert && ctx->certConf_cb(ctx->lastStatus, ctx->newClCert) == 0) {
+		certStatus->statusInfo = CMP_PKISTATUSINFO_new();
+		ASN1_INTEGER_set(certStatus->statusInfo->status, CMP_PKISTATUS_rejection);
+		CMP_printf(ctx, "INFO: rejecting certificate.");
+	}
+
+
+	if( !(msg->body->value.certConf = sk_CMP_CERTSTATUS_new_null())) goto err;
+	if( !sk_CMP_CERTSTATUS_push( msg->body->value.certConf, certStatus)) goto err;
+
+	if( !(msg->protection = CMP_protection_new( msg, NULL, ctx->pkey, ctx->secretValue))) goto err;
+
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_CERTCONF_NEW, CMP_R_ERROR_CREATING_CERTCONF);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+    
+	return NULL;
+}
+
+
+/* ############################################################################ *
+ * Creates a new General Message with the given nid as type and the given value
+ * ############################################################################ */
+CMP_PKIMESSAGE *CMP_genm_new( CMP_CTX *ctx, int nid, char *value) {
+	CMP_PKIMESSAGE *msg=NULL;
+	CMP_INFOTYPEANDVALUE *itav=NULL;
+
+	/* check if all necessary options are set */
+	if (!ctx) goto err;
+
+#if 0
+	/* XXX What were these for and are they still useful??? */
+
+	/* XXX not setting senderNonce test for PKI INFO */
+	ctx->setSenderNonce  = 1;
+	/* XXX not setting transactionID test for PKI INFO */
+	ctx->setTransactionID  = 1;
+#endif
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+
+	if( !CMP_PKIHEADER_set1(msg->header, ctx)) goto err;
+
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_GENM);
+
+	itav = CMP_INFOTYPEANDVALUE_new();
+	itav->infoType = OBJ_nid2obj(nid);
+	itav->infoValue.ptr = value;
+	CMP_PKIMESSAGE_genm_item_push0( msg, itav);
+
+#if 0
+	/* create an empty message body */
+	if( CMP_PKIMESSAGE_genm_item_push0( msg, NULL)) {
+		CMP_printf("INFO: created message body\n");
+	}
+#endif
+#if 0
+	itav = CMP_INFOTYPEANDVALUE_new();
+	if( CMP_INFOTYPEANDVALUE_set0( itav, OBJ_txt2obj("1.3.6.1.5.5.7.4.4",1), V_ASN1_UNDEF, NULL)) {
+		CMP_printf( "INFO: setting itav\n");
+	} /* Preferred Symmetric Algorithm */
+	if( CMP_PKIMESSAGE_genm_item_push0( msg, itav)) {
+		CMP_printf( "INFO: pushing itav\n");
+	}
+#endif
+#if 0
+	itav = CMP_INFOTYPEANDVALUE_new();
+	if( CMP_INFOTYPEANDVALUE_set0( itav, OBJ_txt2obj("1.3.6.1.5.5.7.4.6",1), V_ASN1_UNDEF, NULL)) {
+		CMP_printf( "INFO: setting itav\n");
+	} /* CRL */
+	if( CMP_PKIMESSAGE_genm_item_push0( msg, itav)) {
+		CMP_printf( "INFO: pushing itav\n");
+	}
+#endif
+#if 0
+	itav = CMP_INFOTYPEANDVALUE_new();
+	if( CMP_INFOTYPEANDVALUE_set0( itav, OBJ_txt2obj("1.3.6.1.4.1.3029.3.1.2",1), V_ASN1_UNDEF, NULL)) {
+		CMP_printf( "INFO: setting itav\n");
+	} /* PKIBoot request */
+	if( CMP_PKIMESSAGE_genm_item_push0( msg, itav)) {
+		CMP_printf( "INFO: pushing itav\n");
+	}
+#endif
+#if 0
+	itav = CMP_INFOTYPEANDVALUE_new_by_def_noVal( CMP_ITAV_CRYPTLIB_PKIBOOT);
+	if( CMP_PKIMESSAGE_genm_item_push0( msg, itav)) {
+		CMP_printf( "INFO: pushing itav\n");
+	}
+#endif
+
+	if (!(msg->protection = CMP_protection_new( msg, NULL, NULL, ctx->secretValue))) goto err;
+
+	return msg;
+
+err:
+	CMPerr(CMP_F_CMP_GENM_NEW, CMP_R_ERROR_CREATING_GENM);
+	if (msg) CMP_PKIMESSAGE_free(msg);
+	return NULL;
+}
+
+/* ############################################################################ */
+/* XXX this is untested and work in progress */
+/* The sanity of this kind of message is not without controversy */
+	/* CKUANN looks like:
+	 * ckuann message:
+	 *
+	 * Field        Value                        Comment
+	 * --------------------------------------------------------------
+	 * sender       CA name CA name
+	 * body         ckuann(CAKeyUpdAnnContent)
+	 * oldWithNew   present                  see Appendix E.3 above
+	 * newWithOld   present                  see Appendix E.3 above
+	 * newWithNew   present                  see Appendix E.3 above
+	 * extraCerts   optionally present       can be used to "publish"
+	 * 					 certificates (e.g.,
+	 * 					 certificates signed using
+	 * 					 the new private key)
+	 */
+/* ############################################################################ */
+CMP_PKIMESSAGE *CMP_ckuann_new( const X509 *oldCaCert, const EVP_PKEY *oldPkey, const X509 *newCaCert, const EVP_PKEY *newPkey) {
+	CMP_PKIMESSAGE *msg=NULL;
+	X509_NAME *oldCaName=NULL;
+	X509_NAME *newCaName=NULL;
+	X509 *newWithNew=NULL;
+	X509 *newWithOld=NULL;
+	X509 *oldWithNew=NULL;
+
+#if 0
+	if (!ctx) goto err;
+#endif
+
+	/* get and compare the subject Names of the certificates */
+	if (!(oldCaName = X509_get_subject_name( (X509*) oldCaCert))) goto err;
+	if (!(newCaName = X509_get_subject_name( (X509*) newCaCert))) goto err;
+	/* the subjects of old and new CaCerts have to be equal */
+	if (! X509_NAME_cmp( oldCaName, newCaName)) goto err;
+
+	if (!(msg = CMP_PKIMESSAGE_new())) goto err;
+
+	CMP_PKIHEADER_set_version(msg->header, CMP_VERSION);
+	if( !CMP_PKIHEADER_set1_sender( msg->header, X509_get_subject_name( (X509*) oldCaCert))) goto err;
+
+	CMP_PKIMESSAGE_set_bodytype( msg, V_CMP_PKIBODY_CKUANN);
+	msg->body->value.ckuann = CMP_CAKEYUPDANNCONTENT_new();
+
+	/* as I understand the newWithNew is the same as the newCaCert */
+	newWithNew = X509_dup( (X509*) newCaCert);
+	msg->body->value.ckuann->newWithNew = newWithNew;
+
+	/* create the newWithOld and oldWithNew certificates */
+	newWithOld = X509_dup( (X509*) newCaCert);
+	/* XXX Do I have to check what digest to use? */
+	X509_sign( newWithOld, (EVP_PKEY*) oldPkey, EVP_sha1());
+	msg->body->value.ckuann->newWithOld = newWithOld;
+
+	oldWithNew = X509_dup( (X509*) oldCaCert);
+	/* XXX Do I have to check what digest to use? */
+	X509_sign( oldWithNew, (EVP_PKEY*) newPkey, EVP_sha1());
+	msg->body->value.ckuann->oldWithNew = oldWithNew;
+
+	return msg;
+err:
+	CMPerr(CMP_F_CMP_CKUANN_NEW, CMP_R_ERROR_CREATING_CKUANN);
+
+	if (msg) CMP_PKIMESSAGE_free(msg);
+	return NULL;
+}
Index: openssl-1.0.0i-cmp/crypto/cmp/CMP_msg.pod
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/CMP_msg.pod	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/CMP_msg.pod	(revision 469)
@@ -0,0 +1,62 @@
+=pod
+
+=head1 NAME
+
+ CMP_certConf_new,
+ CMP_ckuann_new,
+ CMP_cr_new,
+ CMP_genm_new,
+ CMP_ir_new,
+ CMP_kur_new	
+
+=head1 SYNOPSIS
+
+ #include <openssl/cmp.h>
+
+ CMP_PKIMESSAGE * CMP_ir_new( CMP_CTX *ctx);
+ CMP_PKIMESSAGE * CMP_cr_new( CMP_CTX *ctx);
+ CMP_PKIMESSAGE * CMP_kur_new( CMP_CTX *ctx);
+ CMP_PKIMESSAGE * CMP_certConf_new( CMP_CTX *ctx);
+ CMP_PKIMESSAGE * CMP_genm_new( CMP_CTX *ctx);
+ CMP_PKIMESSAGE * CMP_ckuann_new( const X509 *oldCaCert, const EVP_PKEY *oldPkey, const X509 *newCaCert, const EVP_PKEY *newPkey);
+
+=head1 DESCRIPTION
+
+This is the API for creating different CMP related PKIMESSAGES. The
+functions allocate a new message and fill it with the relevant data from
+the given CMP_CTX.
+
+CMP_ir_new() creates an Initial Request message.
+
+CMP_cr_new() creates a Certificate Request message.
+
+CMP_kur_new() creates a Key Update Request message.
+
+CMP_certConf_new() creates a Certificate Confirmation message.
+
+CMP_genm_new() creates a new General Message.
+
+CMP_ckuann_new() creates a new CA Key Update Announcement message.
+
+=head1 NOTES
+
+CMP is defined in RFC 4210 (and CRMF in RFC 4211).
+
+The implementation of CMP for OpenSSL is still work in progress. The API
+might change every release!
+
+=head1 RETURN VALUES
+
+All of the functions return a new CMP_PKIMESSAGE structure containing
+the generated message.
+
+=head1 EXAMPLE
+
+
+=head1 TODO
+
+A lot!
+
+=head1 SEE ALSO
+
+CMP_CTX, CMP_session, CMP_http
Index: openssl-1.0.0i-cmp/crypto/cmp/cmp_err.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/cmp_err.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/cmp_err.c	(revision 469)
@@ -0,0 +1,208 @@
+/* crypto/cmp/cmp_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/* NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/cmp.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+#define ERR_FUNC(func) ERR_PACK(ERR_LIB_CMP,func,0)
+#define ERR_REASON(reason) ERR_PACK(ERR_LIB_CMP,0,reason)
+
+static ERR_STRING_DATA CMP_str_functs[]=
+	{
+{ERR_FUNC(CMP_F_CERTREP_GET_CERTIFICATE),	"CERTREP_GET_CERTIFICATE"},
+{ERR_FUNC(CMP_F_CMP_CERTCONF_NEW),	"CMP_certConf_new"},
+{ERR_FUNC(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1),	"CMP_CERTREPMESSAGE_encCert_get1"},
+{ERR_FUNC(CMP_F_CMP_CERTSTATUS_SET_CERTHASH),	"CMP_CERTSTATUS_set_certHash"},
+{ERR_FUNC(CMP_F_CMP_CKUANN_NEW),	"CMP_ckuann_new"},
+{ERR_FUNC(CMP_F_CMP_CR_NEW),	"CMP_cr_new"},
+{ERR_FUNC(CMP_F_CMP_CTX_CAPUBS_GET1),	"CMP_CTX_caPubs_get1"},
+{ERR_FUNC(CMP_F_CMP_CTX_CAPUBS_NUM),	"CMP_CTX_caPubs_num"},
+{ERR_FUNC(CMP_F_CMP_CTX_CAPUBS_POP),	"CMP_CTX_caPubs_pop"},
+{ERR_FUNC(CMP_F_CMP_CTX_CREATE),	"CMP_CTX_create"},
+{ERR_FUNC(CMP_F_CMP_CTX_EXTRACERTSIN_GET1),	"CMP_CTX_extraCertsIn_get1"},
+{ERR_FUNC(CMP_F_CMP_CTX_EXTRACERTSIN_NUM),	"CMP_CTX_extraCertsIn_num"},
+{ERR_FUNC(CMP_F_CMP_CTX_EXTRACERTSIN_POP),	"CMP_CTX_extraCertsIn_pop"},
+{ERR_FUNC(CMP_F_CMP_CTX_EXTRACERTS_NUM),	"CMP_CTX_EXTRACERTS_NUM"},
+{ERR_FUNC(CMP_F_CMP_CTX_EXTRACERTS_PUSH1),	"CMP_CTX_EXTRACERTS_PUSH1"},
+{ERR_FUNC(CMP_F_CMP_CTX_INIT),	"CMP_CTX_init"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET0_NEWPKEY),	"CMP_CTX_set0_newPkey"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET0_PKEY),	"CMP_CTX_set0_pkey"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_CACERT),	"CMP_CTX_set1_caCert"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_CAEXTRACERTS),	"CMP_CTX_SET1_CAEXTRACERTS"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_CAPUBS),	"CMP_CTX_set1_caPubs"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_CLCERT),	"CMP_CTX_set1_clCert"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_EXTRACERTS),	"CMP_CTX_SET1_EXTRACERTS"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_NEWCLCERT),	"CMP_CTX_set1_newClCert"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_NEWPKEY),	"CMP_CTX_set1_newPkey"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_PKEY),	"CMP_CTX_set1_pkey"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_POPOMETHOD),	"CMP_CTX_set1_popoMethod"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_PROTECTIONALGOR),	"CMP_CTX_set1_protectionAlgor"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_PROXYNAME),	"CMP_CTX_set1_proxyName"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_PROXYPORT),	"CMP_CTX_set1_proxyPort"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_RECIPIENT),	"CMP_CTX_set1_recipient"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_RECIPNONCE),	"CMP_CTX_set1_recipNonce"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_REFERENCEVALUE),	"CMP_CTX_set1_referenceValue"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_REGTOKEN),	"CMP_CTX_SET1_REGTOKEN"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SECRETVALUE),	"CMP_CTX_set1_secretValue"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SENDER),	"CMP_CTX_set1_sender"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SERVERNAME),	"CMP_CTX_set1_serverName"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SERVERPATH),	"CMP_CTX_set1_serverPath"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SERVERPORT),	"CMP_CTX_set1_serverPort"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_SUBJECTNAME),	"CMP_CTX_set1_subjectName"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_TIMEOUT),	"CMP_CTX_set1_timeOut"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET1_TRANSACTIONID),	"CMP_CTX_set1_transactionID"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET_COMPATIBILITY),	"CMP_CTX_set_compatibility"},
+{ERR_FUNC(CMP_F_CMP_CTX_SET_PROTECTIONALGOR),	"CMP_CTX_set_protectionAlgor"},
+{ERR_FUNC(CMP_F_CMP_CTX_SUBJECTALTNAME_PUSH1),	"CMP_CTX_subjectAltName_push1"},
+{ERR_FUNC(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ),	"CMP_doCertificateRequestSeq"},
+{ERR_FUNC(CMP_F_CMP_DOINITIALREQUESTSEQ),	"CMP_doInitialRequestSeq"},
+{ERR_FUNC(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ),	"CMP_doKeyUpdateRequestSeq"},
+{ERR_FUNC(CMP_F_CMP_DOPKIINFOREQSEQ),	"CMP_doPKIInfoReqSeq"},
+{ERR_FUNC(CMP_F_CMP_DOREVOCATIONREQUESTSEQ),	"CMP_doRevocationRequestSeq"},
+{ERR_FUNC(CMP_F_CMP_GENM_NEW),	"CMP_genm_new"},
+{ERR_FUNC(CMP_F_CMP_IR_NEW),	"CMP_ir_new"},
+{ERR_FUNC(CMP_F_CMP_KUR_NEW),	"CMP_kur_new"},
+{ERR_FUNC(CMP_F_CMP_NEW_HTTP_BIO_EX),	"CMP_new_http_bio_ex"},
+{ERR_FUNC(CMP_F_CMP_PKIMESSAGE_HTTP_BIO_RECV),	"CMP_PKIMESSAGE_HTTP_BIO_RECV"},
+{ERR_FUNC(CMP_F_CMP_PKIMESSAGE_HTTP_BIO_SEND),	"CMP_PKIMESSAGE_HTTP_BIO_SEND"},
+{ERR_FUNC(CMP_F_CMP_PKIMESSAGE_HTTP_PERFORM),	"CMP_PKIMESSAGE_http_perform"},
+{ERR_FUNC(CMP_F_CMP_PKISTATUSINFO_PKISTATUS_GET_STRING),	"CMP_PKISTATUSINFO_PKIStatus_get_string"},
+{ERR_FUNC(CMP_F_CMP_PROTECTION_NEW),	"CMP_protection_new"},
+{ERR_FUNC(CMP_F_CMP_PROTECTION_VERIFY),	"CMP_protection_verify"},
+{ERR_FUNC(CMP_F_CMP_RR_NEW),	"CMP_rr_new"},
+{ERR_FUNC(CMP_F_CMP_VALIDATE_CERT_PATH),	"CMP_validate_cert_path"},
+{ERR_FUNC(CMP_F_PKEY_DUP),	"PKEY_DUP"},
+{ERR_FUNC(CMP_F_TRY_POLLING),	"TRY_POLLING"},
+{0,NULL}
+	};
+
+static ERR_STRING_DATA CMP_str_reasons[]=
+	{
+{ERR_REASON(CMP_R_CERTIFICATE_NOT_FOUND) ,"certificate not found"},
+{ERR_REASON(CMP_R_COULD_NOT_VALIDATE_CERTIFICATE_PATH),"could not validate certificate path"},
+{ERR_REASON(CMP_R_CP_NOT_RECEIVED)       ,"cp not received"},
+{ERR_REASON(CMP_R_CURL_ERROR)            ,"curl error"},
+{ERR_REASON(CMP_R_DEPRECATED_FUNCTION)   ,"deprecated function"},
+{ERR_REASON(CMP_R_ERROR_CALCULATING_PROTECTION),"error calculating protection"},
+{ERR_REASON(CMP_R_ERROR_CREATING_CERTCONF),"error creating certconf"},
+{ERR_REASON(CMP_R_ERROR_CREATING_CKUANN) ,"error creating ckuann"},
+{ERR_REASON(CMP_R_ERROR_CREATING_CR)     ,"error creating cr"},
+{ERR_REASON(CMP_R_ERROR_CREATING_GENM)   ,"error creating genm"},
+{ERR_REASON(CMP_R_ERROR_CREATING_IR)     ,"error creating ir"},
+{ERR_REASON(CMP_R_ERROR_CREATING_KUR)    ,"error creating kur"},
+{ERR_REASON(CMP_R_ERROR_CREATING_RR)     ,"error creating rr"},
+{ERR_REASON(CMP_R_ERROR_DECODING_CERTIFICATE),"error decoding certificate"},
+{ERR_REASON(CMP_R_ERROR_DECRYPTING_CERTIFICATE),"error decrypting certificate"},
+{ERR_REASON(CMP_R_ERROR_DECRYPTING_ENCCERT),"error decrypting enccert"},
+{ERR_REASON(CMP_R_ERROR_DECRYPTING_KEY)  ,"error decrypting key"},
+{ERR_REASON(CMP_R_ERROR_DECRYPTING_SYMMETRIC_KEY),"error decrypting symmetric key"},
+{ERR_REASON(CMP_R_ERROR_PARSING_PKISTATUS),"error parsing pkistatus"},
+{ERR_REASON(CMP_R_ERROR_SETTING_CERTHASH),"error setting certhash"},
+{ERR_REASON(CMP_R_ERROR_SETTING_PROTECTION_ALGORITHM),"error setting protection algorithm"},
+{ERR_REASON(CMP_R_ERROR_VALIDATING_PROTECTION),"error validating protection"},
+{ERR_REASON(CMP_R_ERROR_VERIFYING_PROTECTION),"error verifying protection"},
+{ERR_REASON(CMP_R_FAILED_TO_DECODE_PKIMESSAGE),"failed to decode pkimessage"},
+{ERR_REASON(CMP_R_FAILED_TO_DETERMINE_PROTECTION_ALGORITHM),"failed to determine protection algorithm"},
+{ERR_REASON(CMP_R_GENP_NOT_RECEIVED)     ,"genp not received"},
+{ERR_REASON(CMP_R_INVALID_ARGS)          ,"invalid args"},
+{ERR_REASON(CMP_R_INVALID_CONTENT_TYPE)  ,"invalid content type"},
+{ERR_REASON(CMP_R_INVALID_CONTEXT)       ,"invalid context"},
+{ERR_REASON(CMP_R_INVALID_KEY)           ,"invalid key"},
+{ERR_REASON(CMP_R_INVALID_PARAMETERS)    ,"invalid parameters"},
+{ERR_REASON(CMP_R_IP_NOT_RECEIVED)       ,"ip not received"},
+{ERR_REASON(CMP_R_KUP_NOT_RECEIVED)      ,"kup not received"},
+{ERR_REASON(CMP_R_NO_CERTIFICATE_RECEIVED),"no certificate received"},
+{ERR_REASON(CMP_R_NO_SECRET_VALUE_GIVEN_FOR_PBMAC),"no secret value given for pbmac"},
+{ERR_REASON(CMP_R_NO_TRUSTED_CERTIFICATES_SET),"no trusted certificates set"},
+{ERR_REASON(CMP_R_NULL_ARGUMENT)         ,"null argument"},
+{ERR_REASON(CMP_R_PKIBODY_ERROR)         ,"pkibody error"},
+{ERR_REASON(CMP_R_PKICONF_NOT_RECEIVED)  ,"pkiconf not received"},
+{ERR_REASON(CMP_R_POLLING_FAILED)        ,"polling failed"},
+{ERR_REASON(CMP_R_RECEIVED_INVALID_RESPONSE_TO_POLLREQ),"received invalid response to pollreq"},
+{ERR_REASON(CMP_R_REQUEST_REJECTED_BY_CA),"request rejected by ca"},
+{ERR_REASON(CMP_R_RP_NOT_RECEIVED)       ,"rp not received"},
+{ERR_REASON(CMP_R_SERVER_NOT_REACHABLE)  ,"server not reachable"},
+{ERR_REASON(CMP_R_SUBJECT_NAME_NOT_SET)  ,"subject name not set"},
+{ERR_REASON(CMP_R_UNABLE_TO_CREATE_CONTEXT),"unable to create context"},
+{ERR_REASON(CMP_R_UNKNOWN_ALGORITHM_ID)  ,"unknown algorithm id"},
+{ERR_REASON(CMP_R_UNKNOWN_CIPHER)        ,"unknown cipher"},
+{ERR_REASON(CMP_R_UNKNOWN_PKISTATUS)     ,"unknown pkistatus"},
+{ERR_REASON(CMP_R_UNSUPPORTED_ALGORITHM) ,"unsupported algorithm"},
+{ERR_REASON(CMP_R_UNSUPPORTED_KEY_TYPE)  ,"unsupported key type"},
+{0,NULL}
+	};
+
+#endif
+
+void ERR_load_CMP_strings(void)
+	{
+#ifndef OPENSSL_NO_ERR
+
+	if (ERR_func_error_string(CMP_str_functs[0].error) == NULL)
+		{
+		ERR_load_strings(0,CMP_str_functs);
+		ERR_load_strings(0,CMP_str_reasons);
+		}
+#endif
+	}
Index: openssl-1.0.0i-cmp/crypto/cmp/cmp_ses.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/cmp_ses.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/cmp_ses.c	(revision 469)
@@ -0,0 +1,1052 @@
+/* vim: set noet ts=4 sts=4 sw=4: */
+ /* crypto/cmp/cmp_ses.c
+ * Functions to do CMP (RFC 4210) message sequences for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ * 2008 - Sami Lehtonen - added CMP_doCertificateRequestSeq()
+ * 06/2010 - Miikka Viljanen - Report errors with OpenSSL error codes instead
+ *                             of printf statements.
+ */
+
+#include <string.h>
+
+#include <openssl/cmp.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/bio.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+
+#include <unistd.h>
+
+
+int CMP_error_callback(const char *str, size_t len, void *u) {
+	CMP_CTX *ctx = (CMP_CTX*) u;
+	if (ctx && ctx->error_cb) 
+		ctx->error_cb(str);
+	return 1;
+}
+
+#ifndef HAVE_CURL
+
+/* show some warning here? */
+
+#else
+
+// {{{ char V_CMP_TABLE[] 
+
+static char *V_CMP_TABLE[] = {
+  "IR",
+  "IP",
+  "CR",
+  "CP",
+  "P10CR",
+  "POPDECC",
+  "POPDECR",
+  "KUR",
+  "KUP",
+  "KRR",
+  "KRP",
+  "RR",
+  "RP",
+  "CCR",
+  "CCP",
+  "CKUANN",
+  "CANN",
+  "RANN",
+  "CRLANN",
+  "PKICONF",
+  "NESTED",
+  "GENM",
+  "GENP",
+  "ERROR",
+  "CERTCONF",
+  "POLLREQ",
+  "POLLREP",
+};
+
+//      }}}
+#define MSG_TYPE_STR(type)  \
+  (((unsigned int) (type) < sizeof(V_CMP_TABLE)/sizeof(V_CMP_TABLE[0])) \
+   ? V_CMP_TABLE[(unsigned int)(type)] : "unknown")
+
+/* ############################################################################ */
+/* Prints error data of the given CMP_PKIMESSAGE into a buffer specified by out */
+/* and returns pointer to the buffer.                                           */
+/* ############################################################################ */
+static char *PKIError_data(CMP_PKIMESSAGE *msg, char *out, int outsize) {
+	char tempbuf[256];
+	switch (CMP_PKIMESSAGE_get_bodytype(msg)) {
+		case V_CMP_PKIBODY_ERROR:
+			BIO_snprintf(out, outsize, "message=%d, error=\"%s\"",
+					CMP_PKIMESSAGE_get_bodytype( msg),
+					CMP_PKIMESSAGE_parse_error_msg( msg, tempbuf, sizeof(tempbuf)));
+			break;
+		case -1:
+			BIO_snprintf(out, outsize, "received NO message");
+			break;
+		default:
+			BIO_snprintf(out, outsize, "received unexpected message of type '%s'", MSG_TYPE_STR(CMP_PKIMESSAGE_get_bodytype( msg)));
+			break;
+	}
+	return out;
+}
+
+static X509 *find_cert_by_name(STACK_OF(X509) *certs, X509_NAME *name) {
+	if (!certs || !name) return NULL;
+	int n = sk_X509_num(certs);
+	while (n --> 0) {
+		X509 *cert = sk_X509_value(certs, n);
+		X509_NAME *cert_name = X509_get_subject_name(cert);
+		if (!X509_NAME_cmp(cert_name, name))
+			return cert;
+	}
+	return NULL;
+}
+
+static void add_error_data(const char *txt) {
+    ERR_STATE *es;
+	int i, len, newlen;
+    char *err;
+    
+    es=ERR_get_state();
+
+	i=es->top;
+	if (i == 0)
+		i=ERR_NUM_ERRORS-1;
+    err=es->err_data[i];
+
+    if (err == NULL) {
+        ERR_add_error_data(1, txt);
+        return;
+    }
+
+    len = strlen(es->err_data[i]);
+    newlen = len + 1 + strlen(txt);
+
+    if (newlen > 80) {
+        err=OPENSSL_realloc(err, newlen+1);
+        if (err == NULL)
+            return;
+    }
+
+    BUF_strlcat(err, ":", (size_t)newlen+1);        
+    BUF_strlcat(err, txt, (size_t)newlen+1);        
+}
+
+/* ############################################################################ *
+ * ############################################################################ */
+
+static X509 *certrep_get_certificate(CMP_CTX *ctx, CMP_CERTREPMESSAGE *certrep, EVP_PKEY *pkey) {
+	X509 *newClCert = NULL;
+	
+	CMP_CTX_set_failInfoCode(ctx, CMP_CERTREPMESSAGE_PKIFailureInfo_get0(certrep, 0));
+
+	ctx->lastStatus = CMP_CERTREPMESSAGE_PKIStatus_get( certrep, 0);
+	switch (ctx->lastStatus) {
+
+		case CMP_PKISTATUS_waiting:
+			goto err;
+			break;
+
+		case CMP_PKISTATUS_grantedWithMods:
+			CMP_printf( ctx, "WARNING: got \"grantedWithMods\"");
+
+		case CMP_PKISTATUS_accepted:
+			/* if we received a certificate then place it to ctx->newClCert and return,
+			 * if the cert is encrypted then we first decrypt it. */
+			switch (CMP_CERTREPMESSAGE_certType_get(certrep, 0)) {
+				case CMP_CERTORENCCERT_CERTIFICATE:
+					if( !(newClCert = CMP_CERTREPMESSAGE_cert_get1(certrep,0))) {
+						CMPerr(CMP_F_CERTREP_GET_CERTIFICATE, CMP_R_CERTIFICATE_NOT_FOUND);
+						goto err;
+					}					
+					break;
+				case CMP_CERTORENCCERT_ENCRYPTEDCERT:
+					if( !(newClCert = CMP_CERTREPMESSAGE_encCert_get1(certrep,0,pkey))) {
+						CMPerr(CMP_F_CERTREP_GET_CERTIFICATE, CMP_R_CERTIFICATE_NOT_FOUND);
+						goto err;
+					}					
+					break;
+			}
+			break;
+
+		case CMP_PKISTATUS_rejection: {
+			/* XXX Should a certconf message be sent even in case of rejection? */
+			char *statusString = NULL;
+			int statusLen = 0;
+			ASN1_UTF8STRING *status = NULL;
+			STACK_OF(ASN1_UTF8STRING) *strstack = CMP_CERTREPMESSAGE_PKIStatusString_get0(certrep, 0);
+
+			CMPerr(CMP_F_CERTREP_GET_CERTIFICATE, CMP_R_REQUEST_REJECTED_BY_CA);
+
+			statusString = CMP_CERTREPMESSAGE_PKIFailureInfoString_get0(certrep, 0);
+			if (!statusString) goto err;
+			statusString = OPENSSL_strdup(statusString);
+			if (!statusString) goto err;
+			statusLen = strlen(statusString);
+
+			statusString = OPENSSL_realloc(statusString, statusLen+20);
+			strcat(statusString, ", statusString: \"");
+			statusLen = strlen(statusString);
+
+			while ((status = sk_ASN1_UTF8STRING_pop(strstack))) {
+				statusLen += strlen((char*)status->data)+2;
+				statusString = OPENSSL_realloc(statusString, statusLen);
+				if (!statusString) goto err;
+				strcat(statusString, (char*)status->data);
+			}
+
+			strcat(statusString, "\"");
+			add_error_data(statusString);
+
+			goto err;
+			break;
+		}
+
+		case CMP_PKISTATUS_revocationWarning:
+		case CMP_PKISTATUS_revocationNotification:
+		case CMP_PKISTATUS_keyUpdateWarning:
+			CMPerr(CMP_F_CERTREP_GET_CERTIFICATE, CMP_R_NO_CERTIFICATE_RECEIVED);
+			goto err;
+			break;
+
+		default: {
+			STACK_OF(ASN1_UTF8STRING) *strstack = CMP_CERTREPMESSAGE_PKIStatusString_get0(certrep, 0);
+			ASN1_UTF8STRING *status = NULL;
+
+			CMPerr(CMP_F_CERTREP_GET_CERTIFICATE, CMP_R_UNKNOWN_PKISTATUS);
+			/* XXX ERR_add_error_data overwrites the previous error data, fix this! */
+			while ((status = sk_ASN1_UTF8STRING_pop(strstack)))
+				ERR_add_error_data(3, "statusString=\"", status->data, "\"");
+
+			CMP_printf( ctx, "ERROR: unknown pkistatus %ld", CMP_CERTREPMESSAGE_PKIStatus_get( certrep, 0));
+			goto err;
+			break;
+		}
+	}
+
+
+	return newClCert;
+err:
+	return NULL;
+}
+
+
+static int try_polling(CMP_CTX *ctx, CMPBIO *cbio, CMP_CERTREPMESSAGE *certrep, CMP_PKIMESSAGE **msg) {
+	int i;
+	CMP_printf(ctx, "INFO: Received 'waiting' PKIStatus, attempting to poll server for response.");
+	for (i = 0; i < ctx->maxPollCount; i++) {
+		CMP_PKIMESSAGE *preq = CMP_pollReq_new(ctx, 0);
+		CMP_PKIMESSAGE *prep = NULL;
+		CMP_POLLREP *pollRep = NULL;
+
+		if (! (CMP_PKIMESSAGE_http_perform(cbio, ctx, preq, &prep))) {
+			if (ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_NULL_ARGUMENT
+				&& ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_SERVER_NOT_REACHABLE)
+				CMPerr(CMP_F_TRY_POLLING, CMP_R_IP_NOT_RECEIVED);
+			else
+				add_error_data("unable to send ir");
+			goto err;
+		}
+
+		/* TODO handle multiple pollreqs */
+		if ( CMP_PKIMESSAGE_get_bodytype(prep) == V_CMP_PKIBODY_IP) {
+			CMP_PKIMESSAGE_free(preq);
+			if (CMP_CERTREPMESSAGE_PKIStatus_get( certrep, 0) != CMP_PKISTATUS_waiting) {
+				*msg = prep;
+				return 1;
+			}
+		} else if ( CMP_PKIMESSAGE_get_bodytype(prep) == V_CMP_PKIBODY_POLLREP) {
+			int checkAfter;
+			pollRep = sk_CMP_POLLREP_value(prep->body->value.pollRep, 0);
+			checkAfter = ASN1_INTEGER_get(pollRep->checkAfter);
+			CMP_printf(ctx, "INFO: Waiting %ld seconds before sending pollReq...\n", checkAfter);
+			sleep(checkAfter);
+		} else {
+			CMP_PKIMESSAGE_free(preq);
+			CMP_PKIMESSAGE_free(prep);
+			CMPerr(CMP_F_TRY_POLLING, CMP_R_RECEIVED_INVALID_RESPONSE_TO_POLLREQ);
+			goto err;
+		}
+
+		CMP_PKIMESSAGE_free(preq);
+		CMP_PKIMESSAGE_free(prep);
+	}
+
+err:
+	return 0;
+}
+
+
+
+/* ############################################################################ *
+ * ############################################################################ */
+X509 *CMP_doInitialRequestSeq( CMPBIO *cbio, CMP_CTX *ctx) {
+	CMP_PKIMESSAGE *ir=NULL;
+	CMP_PKIMESSAGE *ip=NULL;
+	CMP_PKIMESSAGE *certConf=NULL;
+	CMP_PKIMESSAGE *PKIconf=NULL;
+	X509 *caCert = NULL;
+
+	/* check if all necessary options are set */
+	if (!cbio || !ctx || !ctx->newPkey ||
+		 /* for authentication we need either reference/secret or external 
+		  * identity certificate and private key */
+		 (!(ctx->referenceValue && ctx->secretValue) && !(ctx->pkey && ctx->clCert)) ) {
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_INVALID_ARGS);
+		goto err;
+	}
+
+
+	/* set the protection Algor which will be used during the whole session */
+	/* E.7: if clCert is set, use that for signing instead of PBMAC */
+	if (! ctx->clCert)
+		CMP_CTX_set_protectionAlgor( ctx, CMP_ALG_PBMAC);
+	else 
+		if (!CMP_CTX_set_protectionAlgor( ctx, CMP_ALG_SIG)) goto err;
+
+	/* create Initialization Request - ir */
+	if (! (ir = CMP_ir_new(ctx))) goto err;
+
+	CMP_printf(ctx, "INFO: Sending Initialization Request");
+	if (! (CMP_PKIMESSAGE_http_perform(cbio, ctx, ir, &ip))) {
+        if (ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_NULL_ARGUMENT
+            && ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_SERVER_NOT_REACHABLE)
+            CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_IP_NOT_RECEIVED);
+        else
+            add_error_data("unable to send ir");
+		goto err;
+	}
+
+	CMP_CTX_set1_sender(ctx, ip->header->sender->d.directoryName);
+
+	/* if initializing with existing cert, first we'll see if the CA (sender) cert
+	 * can be found and validated using our root CA certificates */
+	if (ctx->trusted_store) {
+		STACK_OF(X509) *ca_stack=NULL;
+
+		if (CMP_PKIMESSAGE_get_bodytype(ip) == V_CMP_PKIBODY_IP) {
+			ca_stack = ip->body->value.ip->caPubs;
+			caCert = find_cert_by_name(ca_stack, ip->header->sender->d.directoryName);
+		}
+
+		if (!caCert) {
+			ca_stack = ip->extraCerts;
+			caCert = find_cert_by_name(ca_stack, ip->header->sender->d.directoryName);
+		}
+
+		if (caCert && CMP_validate_cert_path(ctx, 0, ca_stack, caCert) == 0) {
+			/* if there is a caCert provided, try to use that for verifying 
+			 * the message signature. otherwise fail here. */
+			if (!ctx->caCert) {
+				CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_COULD_NOT_VALIDATE_CERTIFICATE_PATH);
+				goto err;
+			}
+		}
+	}
+	/* either not using existing cert or couldn't find the CA cert in extracerts. */
+	if (!caCert) caCert = ctx->caCert;
+
+	if (ctx->validatePath && caCert) {
+		CMP_printf(ctx, "INFO: validating CA certificate path");
+		if( CMP_validate_cert_path(ctx, 0, ip->extraCerts, ctx->caCert) == 0) {
+			CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_COULD_NOT_VALIDATE_CERTIFICATE_PATH);
+			goto err;
+		}
+	}
+
+	if (CMP_protection_verify( ip, ctx->protectionAlgor, X509_get_pubkey( (X509*) caCert), ctx->secretValue))
+		CMP_printf( ctx, "SUCCESS: validating protection of incoming message");
+	else {
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+	}
+
+	/* make sure the received messagetype indicates an IP message */
+	if (CMP_PKIMESSAGE_get_bodytype(ip) != V_CMP_PKIBODY_IP) {
+		ASN1_UTF8STRING *ftstr = NULL;
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data(ip, errmsg, sizeof(errmsg)));
+		while ((ftstr = sk_ASN1_UTF8STRING_pop(ip->header->freeText)))
+			ERR_add_error_data(3, "freeText=\"", ftstr->data, "\"");
+		goto err;
+	}
+
+	/* make sure the PKIStatus for the *first* CERTrepmessage indicates a certificate was granted */
+	/* TODO - there could be two CERTrepmessages */
+
+	if (CMP_CERTREPMESSAGE_PKIStatus_get( ip->body->value.ip, 0) == CMP_PKISTATUS_waiting)
+		if (!try_polling(ctx, cbio, ip->body->value.ip, &ip)) {
+            CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_IP_NOT_RECEIVED);
+			ERR_add_error_data(1, "received 'waiting' pkistatus but polling failed");
+			goto err;
+		}
+
+	ctx->newClCert = certrep_get_certificate(ctx, ip->body->value.ip, ctx->pkey);
+	if (ctx->newClCert == NULL) goto err;
+
+	/* if the CA returned certificates in the caPubs field, copy them
+	 * to the context so that they can be retrieved if necessary */
+	if (ip->body->value.ip->caPubs)
+		CMP_CTX_set1_caPubs(ctx, ip->body->value.ip->caPubs);
+
+	/* copy any received extraCerts to ctx->etraCertsIn so they can be retrieved */
+	if (ip->extraCerts)
+		CMP_CTX_set1_extraCertsIn(ctx, ip->extraCerts);
+
+	/* check if implicit confirm is set in generalInfo */
+	if (CMP_PKIMESSAGE_check_implicitConfirm(ip)) goto cleanup;
+
+	/* create Certificate Confirmation - certConf */
+	if (! (certConf = CMP_certConf_new(ctx))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending Certificate Confirm");
+	if (! (CMP_PKIMESSAGE_http_perform(cbio, ctx, certConf, &PKIconf))) {
+        if (ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_NULL_ARGUMENT
+            && ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_SERVER_NOT_REACHABLE)
+            CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_PKICONF_NOT_RECEIVED);
+        else
+            add_error_data("unable to send certConf");
+		goto err;
+	}
+
+	if (CMP_protection_verify( PKIconf, ctx->protectionAlgor, X509_get_pubkey( (X509*) caCert), ctx->secretValue))
+		CMP_printf(  ctx, "SUCCESS: validating protection of incoming message");
+	else {
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+	}
+
+	/* make sure the received messagetype indicates an PKIconf message */
+	if (CMP_PKIMESSAGE_get_bodytype(PKIconf) != V_CMP_PKIBODY_PKICONF) {
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data(PKIconf, errmsg, sizeof(errmsg)));
+		goto err;
+	}
+
+
+cleanup:
+	/* clean up */
+	CMP_PKIMESSAGE_free(ir);
+	CMP_PKIMESSAGE_free(ip);
+	/* those are not set in case of implicitConfirm */
+	if (certConf) CMP_PKIMESSAGE_free(certConf);
+	if (PKIconf) CMP_PKIMESSAGE_free(PKIconf);
+	return ctx->newClCert;
+
+err:
+	if (ir) CMP_PKIMESSAGE_free(ir);
+	if (ip) CMP_PKIMESSAGE_free(ip);
+	if (certConf) CMP_PKIMESSAGE_free(certConf);
+	if (PKIconf) CMP_PKIMESSAGE_free(PKIconf);
+
+	/* print out openssl and cmp errors to error_cb if it's set */
+	if (ctx&&ctx->error_cb) ERR_print_errors_cb(CMP_error_callback, (void*) ctx);
+
+	return NULL;
+}
+
+int CMP_doRevocationRequestSeq( CMPBIO *cbio, CMP_CTX *ctx) {
+	CMP_PKIMESSAGE *rr=NULL;
+	CMP_PKIMESSAGE *rp=NULL;
+	// X509 *caCert=NULL;
+
+	if (!cbio || !ctx || !ctx->serverName || !ctx->pkey ||
+		!ctx->clCert || !ctx->caCert) {
+		CMPerr(CMP_F_CMP_DOREVOCATIONREQUESTSEQ, CMP_R_INVALID_ARGS);
+		goto err;
+	}
+
+	CMP_CTX_set_protectionAlgor( ctx, CMP_ALG_SIG);
+	// CMP_CTX_set_protectionAlgor( ctx, CMP_ALG_PBMAC);
+
+	if (! (rr = CMP_rr_new(ctx))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending Revocation Request");
+	if (! (CMP_PKIMESSAGE_http_perform(cbio, ctx, rr, &rp))) {
+        if (ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_NULL_ARGUMENT
+            && ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_SERVER_NOT_REACHABLE)
+            CMPerr(CMP_F_CMP_DOREVOCATIONREQUESTSEQ, CMP_R_RP_NOT_RECEIVED);
+        else
+            add_error_data("unable to send rr");
+		goto err;
+	}
+
+	CMP_CTX_set1_sender(ctx, rp->header->sender->d.directoryName);
+
+	if (CMP_PKIMESSAGE_get_bodytype( rp) != V_CMP_PKIBODY_RP) {
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOREVOCATIONREQUESTSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data(rp, errmsg, sizeof(errmsg)));
+		goto err;
+	}
+
+
+	if (CMP_protection_verify( rp, ctx->protectionAlgor, X509_get_pubkey( (X509*) ctx->caCert), ctx->secretValue)) {
+		CMP_printf(  ctx, "SUCCESS: validating protection of incoming message");
+	} else {
+		CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+	}
+
+	switch (CMP_REVREP_PKIStatus_get( rp->body->value.rp, 0)) 
+	{
+		case CMP_PKISTATUS_grantedWithMods:
+			CMP_printf(  ctx, "WARNING: got \"grantedWithMods\"");
+		case CMP_PKISTATUS_accepted:
+			CMP_printf(  ctx, "INFO: revocation accepted");
+			break;
+		case CMP_PKISTATUS_rejection:
+			goto err;
+			break;
+		case CMP_PKISTATUS_waiting:
+		case CMP_PKISTATUS_revocationWarning:
+		case CMP_PKISTATUS_revocationNotification:
+		case CMP_PKISTATUS_keyUpdateWarning:
+			CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_NO_CERTIFICATE_RECEIVED);
+			goto err;
+			break;
+		default:
+			CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_UNKNOWN_PKISTATUS);
+			goto err;
+			break;
+	}
+
+	return 1;
+
+err:
+	if (ctx&&ctx->error_cb) ERR_print_errors_cb(CMP_error_callback, (void*) ctx);
+	return 0;
+}
+
+
+/* ############################################################################ */
+/* ############################################################################ */
+X509 *CMP_doCertificateRequestSeq( CMPBIO *cbio, CMP_CTX *ctx) {
+	CMP_PKIMESSAGE *cr=NULL;
+	CMP_PKIMESSAGE *cp=NULL;
+	CMP_PKIMESSAGE *certConf=NULL;
+	CMP_PKIMESSAGE *PKIconf=NULL;
+	X509 *caCert=NULL;
+
+	/* check if all necessary options are set */
+	if (!cbio || !ctx || !ctx->serverName
+		|| !ctx->pkey || !ctx->clCert ||
+		(!ctx->caCert && !ctx->trusted_store)) {
+		CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_INVALID_ARGS);
+		goto err;
+	}
+
+	/* set the protection Algor which will be used during the whole session */
+	CMP_CTX_set_protectionAlgor( ctx, CMP_ALG_SIG);
+
+	/* create Certificate Request - cr */
+	if (! (cr = CMP_cr_new(ctx))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending Certificate Request");
+	if (! (CMP_PKIMESSAGE_http_perform(cbio, ctx, cr, &cp))) {
+        if (ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_NULL_ARGUMENT
+            && ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_SERVER_NOT_REACHABLE)
+            CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_CP_NOT_RECEIVED);
+        else
+            add_error_data("unable to send cr");
+		goto err;
+	}
+
+	CMP_CTX_set1_sender(ctx, cp->header->sender->d.directoryName);
+
+	if (CMP_PKIMESSAGE_get_bodytype( cp) != V_CMP_PKIBODY_CP) {
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data(cp, errmsg, sizeof(errmsg)));
+		goto err;
+	}
+
+	/* if  initializing with existing cert, first we'll see if the CA (sender) cert
+	 * can be found and validated using our root CA certificates */
+	if (ctx->trusted_store) {
+		caCert = find_cert_by_name(cp->extraCerts, cp->header->sender->d.directoryName);
+		if (caCert && CMP_validate_cert_path(ctx, 0, cp->extraCerts, caCert) == 0) {
+			/* if there is a caCert provided, try to use that for verifying 
+			 * the message signature. otherwise fail here. */
+			if (!ctx->caCert) {
+				CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_COULD_NOT_VALIDATE_CERTIFICATE_PATH);
+				goto err;
+			}
+		}
+	}
+	/* either not using existing cert or couldn't find the CA cert in extracerts. */
+	if (!caCert) caCert = ctx->caCert;
+
+	if (ctx->validatePath && caCert) {
+		CMP_printf(ctx, "INFO: validating CA certificate path");
+		if( CMP_validate_cert_path(ctx, 0, cp->extraCerts, caCert) == 0) {
+			CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_COULD_NOT_VALIDATE_CERTIFICATE_PATH);
+			goto err;
+		}
+	}
+
+	if (CMP_protection_verify( cp, ctx->protectionAlgor, X509_get_pubkey( (X509*) caCert), NULL)) {
+		CMP_printf(  ctx, "SUCCESS: validating protection of incoming message");
+	} else {
+		CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+	}
+
+	if (CMP_CERTREPMESSAGE_PKIStatus_get( cp->body->value.cp, 0) == CMP_PKISTATUS_waiting)
+		if (!try_polling(ctx, cbio, cp->body->value.cp, &cp)) {
+            CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_CP_NOT_RECEIVED);
+			ERR_add_error_data(1, "received 'waiting' pkistatus but polling failed");
+			goto err;
+		}
+
+	ctx->newClCert = certrep_get_certificate(ctx, cp->body->value.cp, ctx->pkey);
+	if (ctx->newClCert == NULL) goto err;
+
+
+#if 0 /* those can only come in an IR --> 5.3.2 */
+	/* if the CA returned certificates in the caPubs field, copy them
+	 * to the context so that they can be retrieved if necessary */
+	if (cp->body->value.cp->caPubs)
+		CMP_CTX_set1_caPubs(ctx, cp->body->value.cp->caPubs);
+#endif /* 0 */
+
+	/* copy any received extraCerts to ctx->etraCertsIn so they can be retrieved */
+	if (cp->extraCerts)
+		CMP_CTX_set1_extraCertsIn(ctx, cp->extraCerts);
+
+	/* check if implicit confirm is set in generalInfo */
+	if (CMP_PKIMESSAGE_check_implicitConfirm(cp)) goto cleanup;
+
+	/* crate Certificate Confirmation - certConf */
+	if (! (certConf = CMP_certConf_new(ctx))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending Certificate Confirm");
+	if (! (CMP_PKIMESSAGE_http_perform(cbio, ctx, certConf, &PKIconf))) {
+        if (ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_NULL_ARGUMENT
+            && ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_SERVER_NOT_REACHABLE)
+            CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_PKICONF_NOT_RECEIVED);
+        else
+            add_error_data("unable to send certConf");
+		goto err;
+	}
+
+	if (CMP_protection_verify( PKIconf, ctx->protectionAlgor, X509_get_pubkey( (X509*) caCert), NULL)) {
+		CMP_printf( ctx,  "SUCCESS: validating protection of incoming message");
+	} else {
+		/* old: "ERROR: validating protection of incoming message" */
+		CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+	}
+
+	/* make sure the received messagetype indicates an PKIconf message */
+	if (CMP_PKIMESSAGE_get_bodytype(PKIconf) != V_CMP_PKIBODY_PKICONF) {
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOCERTIFICATEREQUESTSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data(PKIconf, errmsg, sizeof(errmsg)));
+		goto err;
+	}
+
+cleanup:
+	/* clean up */
+	CMP_PKIMESSAGE_free(cr);
+	CMP_PKIMESSAGE_free(cp);
+	/* those are not set in case of implicitConfirm */
+	if (certConf) CMP_PKIMESSAGE_free(certConf);
+	if (PKIconf) CMP_PKIMESSAGE_free(PKIconf);
+	return ctx->newClCert;
+
+err:
+	if (cr) CMP_PKIMESSAGE_free(cr);
+	if (cp) CMP_PKIMESSAGE_free(cp);
+	if (certConf) CMP_PKIMESSAGE_free(certConf);
+	if (PKIconf) CMP_PKIMESSAGE_free(PKIconf);
+
+	/* print out openssl and cmp errors to error_cb if it's set */
+	if (ctx&&ctx->error_cb) ERR_print_errors_cb(CMP_error_callback, (void*) ctx);
+
+	return NULL;
+}
+
+
+/* ############################################################################ */
+/* ############################################################################ */
+X509 *CMP_doKeyUpdateRequestSeq( CMPBIO *cbio, CMP_CTX *ctx) {
+	CMP_PKIMESSAGE *kur=NULL;
+	CMP_PKIMESSAGE *kup=NULL;
+	CMP_PKIMESSAGE *certConf=NULL;
+	CMP_PKIMESSAGE *PKIconf=NULL;
+	X509 *caCert = NULL;
+
+	/* check if all necessary options are set */
+	if (!cbio || !ctx || !ctx->serverName
+		|| !ctx->pkey || !ctx->newPkey || !ctx->clCert
+		|| (!ctx->caCert && !ctx->trusted_store)) {
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_INVALID_ARGS);
+		goto err;
+	}
+
+	/* set the protection Algor which will be used during the whole session */
+	CMP_CTX_set_protectionAlgor( ctx, CMP_ALG_SIG);
+
+	/* create Key Update Request - kur */
+	if (! (kur = CMP_kur_new(ctx))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending Key Update Request");
+	if (! (CMP_PKIMESSAGE_http_perform(cbio, ctx, kur, &kup))) {
+        if (ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_NULL_ARGUMENT
+            && ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_SERVER_NOT_REACHABLE)
+            CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_KUP_NOT_RECEIVED);
+        else
+            add_error_data("unable to send kur");
+		goto err;
+	}
+
+	CMP_CTX_set1_sender(ctx, kup->header->sender->d.directoryName);
+
+	/* if  initializing with existing cert, first we'll see if the CA (sender) cert
+	 * can be found and validated using our root CA certificates */
+	if (ctx->trusted_store) {
+		caCert = find_cert_by_name(kup->extraCerts, kup->header->sender->d.directoryName);
+		if (caCert && CMP_validate_cert_path(ctx, 0, kup->extraCerts, caCert) == 0) {
+			/* if there is a caCert provided, try to use that for verifying 
+			 * the message signature. otherwise fail here. */
+			if (!ctx->caCert) {
+				CMPerr(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_COULD_NOT_VALIDATE_CERTIFICATE_PATH);
+				goto err;
+			}
+		}
+	}
+	/* either not using existing cert or couldn't find the CA cert in extracerts. */
+	if (!caCert) caCert = ctx->caCert;
+
+	if (ctx->validatePath && caCert) {
+		CMP_printf(ctx, "INFO: validating CA certificate path");
+		if( CMP_validate_cert_path(ctx, 0, kup->extraCerts, caCert) == 0) {
+			CMPerr(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_COULD_NOT_VALIDATE_CERTIFICATE_PATH);
+			goto err;
+		}
+	}
+
+	if (CMP_protection_verify( kup, ctx->protectionAlgor, X509_get_pubkey( (X509*) caCert), NULL)) {
+		CMP_printf( ctx,  "SUCCESS: validating protection of incoming message");
+	} else {
+		CMPerr(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+	}
+
+	if (CMP_PKIMESSAGE_get_bodytype( kup) != V_CMP_PKIBODY_KUP) {
+		ASN1_UTF8STRING *ftstr = NULL;
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data(kup, errmsg, sizeof(errmsg)));
+		while ((ftstr = sk_ASN1_UTF8STRING_pop(kup->header->freeText)))
+			ERR_add_error_data(3, "freeText=\"", ftstr->data, "\"");
+		goto err;
+	}
+
+	if (CMP_CERTREPMESSAGE_PKIStatus_get( kup->body->value.kup, 0) == CMP_PKISTATUS_waiting)
+		if (!try_polling(ctx, cbio, kup->body->value.kup, &kup)) {
+            CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_KUP_NOT_RECEIVED);
+			ERR_add_error_data(1, "received 'waiting' pkistatus but polling failed");
+			goto err;
+		}
+
+	ctx->newClCert = certrep_get_certificate(ctx, kup->body->value.kup, ctx->pkey);
+	if (ctx->newClCert == NULL) goto err;
+
+
+#if 0 /* those can only come in an IR --> 5.3.2 */
+	/* if the CA returned certificates in the caPubs field, copy them
+	 * to the context so that they can be retrieved if necessary */
+	if (kup->body->value.kup->caPubs)
+		CMP_CTX_set1_caPubs(ctx, kup->body->value.kup->caPubs);
+#endif /* 0 */
+
+	/* copy any received extraCerts to ctx->etraCertsIn so they can be retrieved */
+	if (kup->extraCerts)
+		CMP_CTX_set1_extraCertsIn(ctx, kup->extraCerts);
+
+	/* check if implicit confirm is set in generalInfo */
+	if (CMP_PKIMESSAGE_check_implicitConfirm(kup)) goto cleanup;
+
+	/* crate Certificate Confirmation - certConf */
+	if (! (certConf = CMP_certConf_new(ctx))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending Certificate Confirm");
+	if (! (CMP_PKIMESSAGE_http_perform(cbio, ctx, certConf, &PKIconf))) {
+        if (ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_NULL_ARGUMENT
+            && ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_SERVER_NOT_REACHABLE)
+            CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_PKICONF_NOT_RECEIVED);
+        else
+            add_error_data("unable to send certConf");
+		goto err;
+	}
+
+	if (CMP_protection_verify( PKIconf, ctx->protectionAlgor, X509_get_pubkey( (X509*) caCert), NULL)) {
+		CMP_printf( ctx,  "SUCCESS: validating protection of incoming message");
+	} else {
+		CMPerr(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+	}
+
+	/* make sure the received messagetype indicates an PKIconf message */
+	if (CMP_PKIMESSAGE_get_bodytype(PKIconf) != V_CMP_PKIBODY_PKICONF) {
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOKEYUPDATEREQUESTSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data(PKIconf, errmsg, sizeof(errmsg)));
+		goto err;
+	}
+
+cleanup:
+	/* clean up */
+	CMP_PKIMESSAGE_free(kur);
+	CMP_PKIMESSAGE_free(kup);
+	/* those are not set in case of implicitConfirm */
+	if (certConf) CMP_PKIMESSAGE_free(certConf);
+	if (PKIconf) CMP_PKIMESSAGE_free(PKIconf);
+	return ctx->newClCert;
+
+err:
+	if (kur) CMP_PKIMESSAGE_free(kur);
+	if (kup) CMP_PKIMESSAGE_free(kup);
+	if (certConf) CMP_PKIMESSAGE_free(certConf);
+	if (PKIconf) CMP_PKIMESSAGE_free(PKIconf);
+
+	/* print out openssl and cmp errors to error_cb if it's set */
+	if (ctx&&ctx->error_cb) ERR_print_errors_cb(CMP_error_callback, (void*) ctx);
+
+	return NULL;
+}
+
+CMP_CAKEYUPDANNCONTENT *CMP_doCAKeyUpdateReq( CMPBIO *cbio, CMP_CTX *ctx)
+{
+#if 0
+	itav = sk_CMP_INFOTYPEANDVALUE_value( genp->body->value.genp, 0);
+	cku = itav->infoValue.caKeyUpdateInfo;
+
+	CMP_printf( ctx, "INFO: Attempting to verify received ckuann certificates.");
+	// printf("%08x\n", cku->newWithNew->cert_info->key);
+	// printf("%08x\n", cku->newWithNew->cert_info->key->public_key);
+	
+	/*
+	EVP_PKEY *newpk = cku->newWithNew->cert_info->key->pkey;
+	EVP_PKEY *oldpk = cku->oldWithNew->cert_info->key->pkey;
+	printf("oldWithNew: %d\n", X509_verify(cku->oldWithNew, newpk));
+	printf("newWithold: %d\n", X509_verify(cku->newWithOld, oldpk));
+	*/
+#endif
+
+	return (CMP_CAKEYUPDANNCONTENT*) CMP_doGeneralMessageSeq( cbio, ctx, NID_id_it_caKeyUpdateInfo, NULL);
+}
+
+X509_CRL *CMP_doCurrentCRLReq( CMPBIO *cbio, CMP_CTX *ctx)
+{
+	return (X509_CRL*) CMP_doGeneralMessageSeq( cbio, ctx, NID_id_it_currentCRL, NULL);
+}
+
+/* ############################################################################ */
+/* ############################################################################ */
+char *CMP_doGeneralMessageSeq( CMPBIO *cbio, CMP_CTX *ctx, int nid, char *value)
+{
+	CMP_PKIMESSAGE *genm=NULL;
+	CMP_PKIMESSAGE *genp=NULL;
+	CMP_INFOTYPEANDVALUE *itav=NULL;
+
+	/* check if all necessary options are set */
+	if (!cbio || !ctx || !ctx->caCert || !ctx->referenceValue || !ctx->secretValue) {
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_INVALID_ARGS);
+	 	goto err;
+	}
+
+	/* set the protection Algor which will be used during the whole session */
+	CMP_CTX_set_protectionAlgor( ctx, CMP_ALG_PBMAC);
+
+	/* crate GenMsgContent - genm*/
+	// if (! (genm = CMP_genm_new(ctx, NID_id_it_caKeyUpdateInfo))) goto err;
+	if (! (genm = CMP_genm_new(ctx, nid, value))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending General Message");
+	if (! (CMP_PKIMESSAGE_http_perform(cbio, ctx, genm, &genp))) {
+        if (ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_NULL_ARGUMENT
+            && ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_SERVER_NOT_REACHABLE)
+            CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_GENP_NOT_RECEIVED);
+        else
+            add_error_data("unable to send genm");
+		goto err;
+	}
+
+	CMP_CTX_set1_sender(ctx, genp->header->sender->d.directoryName);
+
+	if (CMP_protection_verify( genp, ctx->protectionAlgor, NULL, ctx->secretValue))
+		CMP_printf( ctx,  "SUCCESS: validating protection of incoming message");
+	else {
+		CMPerr(CMP_F_CMP_DOPKIINFOREQSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+	}
+
+	/* make sure the received messagetype indicates an GENP message */
+	if (CMP_PKIMESSAGE_get_bodytype(genp) != V_CMP_PKIBODY_GENP) {
+		STACK_OF(ASN1_UTF8STRING) *strstack = CMP_CERTREPMESSAGE_PKIStatusString_get0(genp->body->value.ip, 0);
+		ASN1_UTF8STRING *status = NULL;
+
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOPKIINFOREQSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data(genp, errmsg, sizeof(errmsg)));
+
+
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_UNKNOWN_PKISTATUS);
+		while ((status = sk_ASN1_UTF8STRING_pop(strstack)))
+			ERR_add_error_data(3, "statusString=\"", status->data, "\"");
+		goto err;
+	}
+
+	itav = sk_CMP_INFOTYPEANDVALUE_value( genp->body->value.genp, 0);
+	if (!itav) goto err;
+
+	return itav->infoValue.ptr;
+err:
+
+	if (genm) CMP_PKIMESSAGE_free(genm);
+	if (genp) CMP_PKIMESSAGE_free(genp);
+
+	/* print out openssl and cmp errors to error_cb if it's set */
+	if (ctx&&ctx->error_cb) ERR_print_errors_cb(CMP_error_callback, (void*) ctx);
+
+	return NULL;
+}
+
+
+/* ############################################################################ */
+/* ############################################################################ */
+int CMP_doPKIInfoReqSeq( CMPBIO *cbio, CMP_CTX *ctx) {
+	CMP_PKIMESSAGE *genm=NULL;
+	CMP_PKIMESSAGE *genp=NULL;
+
+	/* check if all necessary options are set */
+	if (!cbio || !ctx || !ctx->caCert || !ctx->referenceValue || !ctx->secretValue) {
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_INVALID_ARGS);
+		goto err;
+	}
+
+	/* set the protection Algor which will be used during the whole session */
+	CMP_CTX_set_protectionAlgor( ctx, CMP_ALG_PBMAC);
+
+	/* crate GenMsgContent - genm*/
+	if (! (genm = CMP_genm_new(ctx, 0, NULL))) goto err;
+
+	CMP_printf( ctx, "INFO: Sending General Message");
+	if (! (CMP_PKIMESSAGE_http_perform(cbio, ctx, genm, &genp))) {
+        if (ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_NULL_ARGUMENT
+            && ERR_GET_REASON(ERR_peek_last_error()) != CMP_R_SERVER_NOT_REACHABLE)
+            CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_GENP_NOT_RECEIVED);
+        else
+            add_error_data("unable to send genm");
+		goto err;
+	}
+
+	if (CMP_protection_verify( genp, ctx->protectionAlgor, NULL, ctx->secretValue))
+		CMP_printf( ctx,  "SUCCESS: validating protection of incoming message");
+	else {
+		CMPerr(CMP_F_CMP_DOPKIINFOREQSEQ, CMP_R_ERROR_VALIDATING_PROTECTION);
+		goto err;
+	}
+
+	/* make sure the received messagetype indicates an GENP message */
+	if (CMP_PKIMESSAGE_get_bodytype(genp) != V_CMP_PKIBODY_GENP) {
+		STACK_OF(ASN1_UTF8STRING) *strstack = CMP_CERTREPMESSAGE_PKIStatusString_get0(genp->body->value.ip, 0);
+		ASN1_UTF8STRING *status = NULL;
+
+		char errmsg[256];
+		CMPerr(CMP_F_CMP_DOPKIINFOREQSEQ, CMP_R_PKIBODY_ERROR);
+		ERR_add_error_data(1, PKIError_data(genp, errmsg, sizeof(errmsg)));
+
+
+		CMPerr(CMP_F_CMP_DOINITIALREQUESTSEQ, CMP_R_UNKNOWN_PKISTATUS);
+		while ((status = sk_ASN1_UTF8STRING_pop(strstack)))
+			ERR_add_error_data(3, "statusString=\"", status->data, "\"");
+		goto err;
+	}
+
+	return 1;
+
+err:
+	if (genm) CMP_PKIMESSAGE_free(genm);
+	if (genp) CMP_PKIMESSAGE_free(genp);
+
+	/* print out openssl and cmp errors to error_cb if it's set */
+	if (ctx&&ctx->error_cb) ERR_print_errors_cb(CMP_error_callback, (void*) ctx);
+
+	return 0;
+}
+
+#endif
+
Index: openssl-1.0.0i-cmp/crypto/cmp/Makefile
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/Makefile	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/Makefile	(revision 469)
@@ -0,0 +1,193 @@
+#
+# OpenSSL/cmp/Makefile
+#
+
+DIR=	cmp
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG) -Wall -DCMP_DEBUG
+
+GENERAL=Makefile README
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= cmp_asn.c cmp_lib.c cmp_msg.c cmp_vfy.c cmp_http.c cmp_ses.c cmp_ctx.c cmp_err.c
+LIBOBJ= cmp_asn.o cmp_lib.o cmp_msg.o cmp_vfy.o cmp_http.o cmp_ses.o cmp_ctx.o cmp_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= cmp.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+cmp_asn.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+cmp_asn.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+cmp_asn.o: ../../include/openssl/cmp.h ../../include/openssl/conf.h
+cmp_asn.o: ../../include/openssl/crmf.h ../../include/openssl/crypto.h
+cmp_asn.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+cmp_asn.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+cmp_asn.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+cmp_asn.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+cmp_asn.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+cmp_asn.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pkcs7.h
+cmp_asn.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+cmp_asn.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+cmp_asn.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+cmp_asn.o: ../../include/openssl/x509v3.h cmp_asn.c
+cmp_ctx.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+cmp_ctx.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+cmp_ctx.o: ../../include/openssl/cmp.h ../../include/openssl/conf.h
+cmp_ctx.o: ../../include/openssl/crmf.h ../../include/openssl/crypto.h
+cmp_ctx.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+cmp_ctx.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+cmp_ctx.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+cmp_ctx.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+cmp_ctx.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+cmp_ctx.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+cmp_ctx.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+cmp_ctx.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+cmp_ctx.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+cmp_ctx.o: ../../include/openssl/x509_vfy.h ../../include/openssl/x509v3.h
+cmp_ctx.o: cmp_ctx.c
+cmp_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+cmp_err.o: ../../include/openssl/buffer.h ../../include/openssl/cmp.h
+cmp_err.o: ../../include/openssl/conf.h ../../include/openssl/crmf.h
+cmp_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+cmp_err.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+cmp_err.o: ../../include/openssl/ecdsa.h ../../include/openssl/err.h
+cmp_err.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+cmp_err.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+cmp_err.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+cmp_err.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pkcs7.h
+cmp_err.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+cmp_err.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+cmp_err.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+cmp_err.o: ../../include/openssl/x509v3.h cmp_err.c
+cmp_http.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+cmp_http.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+cmp_http.o: ../../include/openssl/cmp.h ../../include/openssl/conf.h
+cmp_http.o: ../../include/openssl/crmf.h ../../include/openssl/crypto.h
+cmp_http.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+cmp_http.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+cmp_http.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+cmp_http.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+cmp_http.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+cmp_http.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+cmp_http.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+cmp_http.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+cmp_http.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+cmp_http.o: ../../include/openssl/x509_vfy.h ../../include/openssl/x509v3.h
+cmp_http.o: cmp_http.c
+cmp_lib.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+cmp_lib.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+cmp_lib.o: ../../include/openssl/cmp.h ../../include/openssl/conf.h
+cmp_lib.o: ../../include/openssl/crmf.h ../../include/openssl/crypto.h
+cmp_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+cmp_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+cmp_lib.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+cmp_lib.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+cmp_lib.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+cmp_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+cmp_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/rand.h
+cmp_lib.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+cmp_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+cmp_lib.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+cmp_lib.o: ../../include/openssl/x509v3.h cmp_lib.c
+cmp_msg.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+cmp_msg.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+cmp_msg.o: ../../include/openssl/cmp.h ../../include/openssl/conf.h
+cmp_msg.o: ../../include/openssl/crmf.h ../../include/openssl/crypto.h
+cmp_msg.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+cmp_msg.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+cmp_msg.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+cmp_msg.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+cmp_msg.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+cmp_msg.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+cmp_msg.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+cmp_msg.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+cmp_msg.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+cmp_msg.o: ../../include/openssl/x509_vfy.h ../../include/openssl/x509v3.h
+cmp_msg.o: cmp_msg.c
+cmp_ses.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+cmp_ses.o: ../../include/openssl/buffer.h ../../include/openssl/cmp.h
+cmp_ses.o: ../../include/openssl/conf.h ../../include/openssl/crmf.h
+cmp_ses.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+cmp_ses.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+cmp_ses.o: ../../include/openssl/ecdsa.h ../../include/openssl/err.h
+cmp_ses.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+cmp_ses.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+cmp_ses.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+cmp_ses.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pkcs7.h
+cmp_ses.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+cmp_ses.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+cmp_ses.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+cmp_ses.o: ../../include/openssl/x509v3.h cmp_ses.c
+cmp_vfy.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+cmp_vfy.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+cmp_vfy.o: ../../include/openssl/cmp.h ../../include/openssl/conf.h
+cmp_vfy.o: ../../include/openssl/crmf.h ../../include/openssl/crypto.h
+cmp_vfy.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+cmp_vfy.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+cmp_vfy.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+cmp_vfy.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+cmp_vfy.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+cmp_vfy.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+cmp_vfy.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+cmp_vfy.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+cmp_vfy.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+cmp_vfy.o: ../../include/openssl/x509_vfy.h ../../include/openssl/x509v3.h
+cmp_vfy.o: cmp_vfy.c
Index: openssl-1.0.0i-cmp/crypto/cmp/cmp_ctx.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/cmp_ctx.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/cmp_ctx.c	(revision 469)
@@ -0,0 +1,1152 @@
+/* crypto/cmp/cmp_ctx.c
+ * CMP (RFC 4210) context functions for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/cmp.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/err.h>
+#include <string.h>
+#include <dirent.h>
+
+ /* NAMING
+  * The 0 version uses the supplied structure pointer directly in the parent and
+  * it will be freed up when the parent is freed. In the above example crl would
+  * be freed but rev would not.
+  *
+  * The 1 function uses a copy of the supplied structure pointer (or in some
+  * cases increases its link count) in the parent and so both (x and obj above)
+  * should be freed up.
+ */
+
+ASN1_SEQUENCE(CMP_CTX) = {
+	ASN1_OPT(CMP_CTX, referenceValue, ASN1_OCTET_STRING),
+	ASN1_OPT(CMP_CTX, secretValue, ASN1_OCTET_STRING),
+	ASN1_OPT(CMP_CTX, regToken, ASN1_UTF8STRING),
+	ASN1_OPT(CMP_CTX, caCert, X509),
+	ASN1_OPT(CMP_CTX, clCert, X509),
+	ASN1_OPT(CMP_CTX, subjectName, X509_NAME),
+	ASN1_OPT(CMP_CTX, recipient, X509_NAME),
+	ASN1_OPT(CMP_CTX, sender, X509_NAME),
+	ASN1_SEQUENCE_OF_OPT(CMP_CTX, subjectAltNames, GENERAL_NAME),
+	ASN1_SEQUENCE_OF_OPT(CMP_CTX, caPubs, X509),
+	ASN1_SEQUENCE_OF_OPT(CMP_CTX, extraCertsOut, X509),
+	ASN1_SEQUENCE_OF_OPT(CMP_CTX, extraCertsIn, X509),
+	/* EVP_PKEY *pkey */
+	ASN1_OPT(CMP_CTX, newClCert, X509),
+	/* EVP_PKEY *newPkey */
+	ASN1_OPT(CMP_CTX, transactionID, ASN1_OCTET_STRING),
+	ASN1_OPT(CMP_CTX, recipNonce, ASN1_OCTET_STRING),
+	ASN1_OPT(CMP_CTX, protectionAlgor, X509_ALGOR),
+#if 0
+	/* this is actually CMP_PKIFREETEXT which is STACK_OF(ANS1_UTF8STRING) */
+	ASN1_SEQUENCE_OPT(CMP_CTX, freeText, STACK_OF(UTF8STRING));
+#endif
+	/* the following are not ASN1 types and present in the declaration in cmp.h
+	 * int compatibilitiy
+	 * char *serverName
+	 * int serverPort
+	 * int transport
+	 * int implicitConfirm
+	 * int setSenderNonce
+	 * int setTransactionID
+	 * int popoMethod
+	 * int timeOut
+	 */
+} ASN1_SEQUENCE_END(CMP_CTX)
+IMPLEMENT_ASN1_FUNCTIONS(CMP_CTX)
+
+/* ############################################################################ *
+ * Returns a duplicate of the given stack of X509 certificates.
+ * ############################################################################ */
+static STACK_OF(X509)* X509_stack_dup(const STACK_OF(X509)* stack)
+{
+	STACK_OF(X509) *newsk = NULL;
+	int i;
+
+	if (!stack) goto err;
+	if (!(newsk = sk_X509_new_null())) goto err;
+
+	for (i = 0; i < sk_X509_num(stack); i++)
+		sk_X509_push(newsk, X509_dup(sk_X509_value(stack, i)));
+
+	return newsk;
+err:
+	return 0;
+}
+
+/* ############################################################################ *
+ * Creates a copy of the given EVP_PKEY.
+ * ############################################################################ */
+static EVP_PKEY *pkey_dup(const EVP_PKEY *pkey)
+{
+	EVP_PKEY *pkeyDup = EVP_PKEY_new();
+	switch (pkey->type) {
+#ifndef OPENSSL_NO_RSA
+		case EVP_PKEY_RSA:
+			EVP_PKEY_set1_RSA(pkeyDup, pkey->pkey.rsa);
+			break;
+#endif
+#ifndef OPENSSL_NO_DSA
+		case EVP_PKEY_DSA: 
+			EVP_PKEY_set1_DSA(pkeyDup, pkey->pkey.dsa);
+			break;
+#endif
+#ifndef OPENSSL_NO_DH
+		case EVP_PKEY_DH:
+			EVP_PKEY_set1_DH(pkeyDup, pkey->pkey.dh);
+			break;
+#endif
+#ifndef OPENSSL_NO_EC
+		case EVP_PKEY_EC:
+			EVP_PKEY_set1_EC_KEY(pkeyDup, pkey->pkey.ec);
+			break;
+#endif
+		default: 
+			CMPerr(CMP_F_PKEY_DUP, CMP_R_UNSUPPORTED_KEY_TYPE);
+			goto err;
+	}
+	return pkeyDup;
+
+err:
+	EVP_PKEY_free(pkeyDup);
+	return NULL;
+}
+
+;
+/* ############################################################################ *
+ * Set certificate store containing root CA certs.
+ * ############################################################################ */
+int CMP_CTX_set0_trustedStore( CMP_CTX *ctx, X509_STORE *store) {
+	if (!store) return 0;
+    X509_STORE_set_verify_cb(store, CMP_cert_callback);
+    if (ctx->trusted_store)
+    	X509_STORE_free(ctx->trusted_store);
+	ctx->trusted_store = store;
+	return 1;
+}
+
+#if 0
+int CMP_CTX_set1_trustedStore( CMP_CTX *ctx, X509_STORE *store) {
+	X509_STORE *dup = NULL;
+	if (!store) return 0;
+	if (!(dup = X509_STORE_dup(store))) return 0;
+	return CMP_CTX_trustedStore_set0(ctx, dup);
+}
+#endif
+
+/* ############################################################################ *
+ * Set certificate store containing intermediate certificates (for building
+ * our own cert chain to send in extraCerts).
+ * ############################################################################ */
+int CMP_CTX_set0_untrustedStore( CMP_CTX *ctx, X509_STORE *store) {
+	if (!store) return 0;
+    X509_STORE_set_verify_cb(store, CMP_cert_callback);
+    if (ctx->untrusted_store)
+    	X509_STORE_free(ctx->untrusted_store);
+	ctx->untrusted_store = store;
+	return 1;
+}
+
+#if 0
+int CMP_CTX_set1_untrustedStore( CMP_CTX *ctx, X509_STORE *store) {
+	X509_STORE *dup = NULL;
+	if (!store) return 0;
+	if (!(dup = X509_STORE_dup(store))) return 0;
+	return CMP_CTX_untrustedStore_set0(ctx, dup);
+}
+#endif
+
+/* ################################################################ *
+ * Allocates and initializes a CMP_CTX context structure with some 
+ * default values.
+ * ################################################################ */
+int CMP_CTX_init( CMP_CTX *ctx) {
+	if (!ctx) {
+		CMPerr(CMP_F_CMP_CTX_INIT, CMP_R_INVALID_CONTEXT);
+		goto err;
+	}
+
+	/* all other elements are initialized through ASN1 macros */
+	ctx->pkey            = NULL;
+	ctx->newPkey         = NULL;
+	ctx->compatibility   = CMP_COMPAT_RFC;
+	ctx->serverName      = NULL;
+	/* serverPath has to be an empty sting if not set since it is not mandatory */
+	/* this will be freed by CMP_CTX_delete() */
+	ctx->serverPath      = OPENSSL_malloc(1);
+	ctx->serverPath[0]   = 0;
+	ctx->serverPort      = 0;
+	ctx->proxyName       = NULL;
+	ctx->proxyPort       = 0;
+	ctx->transport       = CMP_TRANSPORT_HTTP;
+	ctx->implicitConfirm = 0;
+	ctx->setSenderNonce  = 1;
+	ctx->setTransactionID= 1;
+	ctx->popoMethod      = CMP_POPO_SIGNATURE;
+	ctx->timeOut         = 2*60;
+	/* ctx->popoMethod = CMP_POPO_ENCRCERT; */
+	ctx->validatePath    = 0;
+
+	ctx->error_cb = NULL;
+	ctx->debug_cb = (cmp_logfn_t) puts;
+	ctx->certConf_cb = NULL;
+
+	ctx->trusted_store   = NULL;
+	ctx->untrusted_store = NULL;
+
+	ctx->maxPollCount = 3;
+
+	ctx->lastStatus = -1;
+	ctx->failInfoCode = 0;
+
+#if 0
+	/* These are initialized already by the call to CMP_CTX_new() */
+	ctx->referenceValue  = NULL;
+	ctx->secretValue     = NULL;
+	ctx->caCert          = NULL;
+	ctx->clCert          = NULL;
+	ctx->newClCert       = NULL;
+	ctx->transactionID   = NULL;
+	ctx->recipNonce      = NULL;
+	ctx->protectionAlgor = NULL;
+
+	ctx->subjectName     = NULL;
+	ctx->recipient       = NULL;
+	ctx->subjectAltNames = NULL;
+	ctx->caPubs          = NULL;
+	ctx->extraCertsOut   = NULL;
+	ctx->extraCertsIn    = NULL;
+#endif
+
+	/* initialize OpenSSL */
+	OpenSSL_add_all_ciphers();
+	OpenSSL_add_all_digests();
+	ERR_load_crypto_strings();
+
+	return 1;
+
+err:
+	return 0;
+}
+
+/* ################################################################ */
+/* frees CMP_CTX variables allocated in CMP_CTX_init and calls CMP_CTX_free */
+/* ################################################################ */
+void CMP_CTX_delete(CMP_CTX *ctx) {
+	if (!ctx) return;
+	if (ctx->serverPath) OPENSSL_free(ctx->serverPath);
+	if (ctx->serverName) OPENSSL_free(ctx->serverName);
+	if (ctx->proxyName) OPENSSL_free(ctx->proxyName);
+	CMP_CTX_free(ctx);
+}
+
+
+/* ################################################################ */
+/* creates and initializes a CMP_CTX structure */
+/* ################################################################ */
+CMP_CTX *CMP_CTX_create(void) {
+	CMP_CTX *ctx=NULL;
+
+	if( !(ctx = CMP_CTX_new())) goto err;
+	if( !(CMP_CTX_init(ctx))) goto err;
+
+	return ctx;
+err:
+	CMPerr(CMP_F_CMP_CTX_CREATE, CMP_R_UNABLE_TO_CREATE_CONTEXT);
+	if (ctx) CMP_CTX_free(ctx);
+	return NULL;
+}
+
+unsigned long CMP_CTX_get_failInfoCode( CMP_CTX *ctx)
+{
+	if (!ctx) goto err;
+	return ctx->failInfoCode;
+err:
+	return 0;
+}
+
+/* ################################################################ *
+ * Set callback function for checking if the cert is ok or should
+ * it be rejected.
+ * ################################################################ */
+int CMP_CTX_set_certConf_callback( CMP_CTX *ctx, cmp_certConfFn_t cb)
+{
+	if (!ctx || !cb) goto err;
+	ctx->certConf_cb = cb;
+err:
+	return 0;
+}
+
+/* ################################################################ *
+ * Set a callback function which will receive debug messages.
+ * ################################################################ */
+int CMP_CTX_set_error_callback( CMP_CTX *ctx, cmp_logfn_t cb)
+{
+	if (!ctx || !cb) goto err;
+	ctx->error_cb = cb;
+err:
+	return 0;
+}
+
+/* ################################################################ *
+ * Set a callback function which will receive error messages.
+ * ################################################################ */
+int CMP_CTX_set_debug_callback( CMP_CTX *ctx, cmp_logfn_t cb)
+{
+	if (!ctx || !cb) goto err;
+	ctx->debug_cb = cb;
+err:
+	return 0;
+}
+
+/* ################################################################ *
+ * Set the reference value to be used for identification (i.e. the 
+ * username) when using PBMAC.
+ * ################################################################ */
+int CMP_CTX_set1_referenceValue( CMP_CTX *ctx, const unsigned char *ref, size_t len) {
+	if (!ctx || !ref) {
+		CMPerr(CMP_F_CMP_CTX_SET1_REFERENCEVALUE, CMP_R_INVALID_PARAMETERS);
+		goto err;
+	}
+
+	if (!ctx->referenceValue)
+		ctx->referenceValue = ASN1_OCTET_STRING_new();
+
+	return (ASN1_OCTET_STRING_set(ctx->referenceValue, ref, len));
+err:
+	return 0;
+}
+
+/* ################################################################ *
+ * Set the password to be used for protecting messages with PBMAC
+ * ################################################################ */
+int CMP_CTX_set1_secretValue( CMP_CTX *ctx, const unsigned char *sec, const size_t len) {
+	if (!ctx) goto err;
+	if (!sec) goto err;
+
+	if (!ctx->secretValue)
+		ctx->secretValue = ASN1_OCTET_STRING_new();
+
+	return (ASN1_OCTET_STRING_set(ctx->secretValue, sec, len));
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SECRETVALUE, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Set the registration token value (the password for EJBCA for example)
+ * ################################################################ */
+int CMP_CTX_set1_regToken( CMP_CTX *ctx, const char *regtoken, const size_t len) {
+	if (!ctx) goto err;
+	if (!regtoken) goto err;
+
+	if (!ctx->regToken)
+		ctx->regToken = ASN1_UTF8STRING_new();
+
+	return (ASN1_STRING_set(ctx->regToken, regtoken, len));
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_REGTOKEN, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Returns the stack of certificates received in a response message.
+ * The stack is duplicated so the caller must handle freeing it!
+ * ################################################################ */
+STACK_OF(X509)* CMP_CTX_extraCertsIn_get1( CMP_CTX *ctx) {
+	if (!ctx) goto err;
+	if (!ctx->extraCertsIn) return 0;
+	return X509_stack_dup(ctx->extraCertsIn);
+  err:
+	CMPerr(CMP_F_CMP_CTX_EXTRACERTSIN_GET1, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Pops and returns one certificate from the received extraCerts field
+ * ################################################################ */
+X509 *CMP_CTX_extraCertsIn_pop( CMP_CTX *ctx)
+{
+	if (!ctx) goto err;
+	if (!ctx->extraCertsIn) return NULL;
+	return sk_X509_pop(ctx->extraCertsIn);
+err:
+	CMPerr(CMP_F_CMP_CTX_EXTRACERTSIN_POP, CMP_R_NULL_ARGUMENT);
+	return NULL;
+}
+
+/* ################################################################ *
+ * Returns the number of extraCerts received in a response.
+ * ################################################################ */
+int CMP_CTX_extraCertsIn_num( CMP_CTX *ctx)
+{
+	if (!ctx) goto err;
+	if (!ctx->extraCertsIn) return 0;
+	return sk_X509_num(ctx->extraCertsIn);
+  err:
+	CMPerr(CMP_F_CMP_CTX_EXTRACERTSIN_NUM, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Copies the given stack of inbound X509 certificates to the 
+ * CMP_CTX structure so that they may be retrieved later.
+ * ################################################################ */
+int CMP_CTX_set1_extraCertsIn( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsIn) {
+	if (!ctx) goto err;
+	if (!extraCertsIn) goto err;
+
+/* if there are already inbound extraCerts on the stack deleten them */
+	if (ctx->extraCertsIn) {
+		sk_X509_pop_free(ctx->extraCertsIn, X509_free);
+		ctx->extraCertsIn = NULL;
+	}
+
+	if (!(ctx->extraCertsIn = X509_stack_dup(extraCertsIn))) goto err;
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_CAEXTRACERTS, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Duplicate and push the given X509 certificate to the stack of 
+ * outbound certificates to send in the extraCerts field.
+ * ################################################################ */
+int CMP_CTX_extraCertsOut_push1( CMP_CTX *ctx, const X509 *val)
+{
+	if (!ctx) goto err;
+	if (!ctx->extraCertsOut && !(ctx->extraCertsOut = sk_X509_new_null())) return 0;
+	return sk_X509_push(ctx->extraCertsOut, X509_dup((X509*)val));
+err:
+	CMPerr(CMP_F_CMP_CTX_EXTRACERTS_PUSH1, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Return the number of certificates we have in the outbound 
+ * extraCerts stack.
+ * ################################################################ */
+int CMP_CTX_extraCertsOut_num( CMP_CTX *ctx)
+{
+	if (!ctx) goto err;
+	if (!ctx->extraCertsOut) return 0;
+	return sk_X509_num(ctx->extraCertsOut);
+  err:
+	CMPerr(CMP_F_CMP_CTX_EXTRACERTS_NUM, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Duplicate and set the given stack as the new stack of X509 
+ * certificates to send out in the extraCerts field.
+ * ################################################################ */
+int CMP_CTX_set1_extraCertsOut( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsOut) {
+	if (!ctx) goto err;
+	if (!extraCertsOut) goto err;
+
+	if (ctx->extraCertsOut) {
+		sk_X509_pop_free(ctx->extraCertsOut, X509_free);
+		ctx->extraCertsOut = NULL;
+	}
+
+	if (!(ctx->extraCertsOut = X509_stack_dup(extraCertsOut))) goto err;
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_EXTRACERTS, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Returns a duplicate of the stack received X509 certificates that
+ * were received in the caPubs field of the last response message.
+ * ################################################################ */
+STACK_OF(X509)* CMP_CTX_caPubs_get1( CMP_CTX *ctx) {
+	if (!ctx) goto err;
+	if (!ctx->caPubs) return 0;
+	return X509_stack_dup(ctx->caPubs);
+  err:
+	CMPerr(CMP_F_CMP_CTX_CAPUBS_GET1, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Pop one certificate out of the list of certificates received in
+ * the caPubs field.
+ * ################################################################ */
+X509 *CMP_CTX_caPubs_pop( CMP_CTX *ctx) {
+	if (!ctx) goto err;
+	if (!ctx->caPubs) return NULL;
+	return sk_X509_pop(ctx->caPubs);
+err:
+	CMPerr(CMP_F_CMP_CTX_CAPUBS_POP, CMP_R_NULL_ARGUMENT);
+	return NULL;
+}
+
+/* ################################################################ *
+ * Return the number of certificates received in the caPubs field
+ * of the last response message.
+ * ################################################################ */
+int CMP_CTX_caPubs_num( CMP_CTX *ctx) {
+	if (!ctx) goto err;
+	if (!ctx->caPubs) return 0;
+	return sk_X509_num(ctx->caPubs);
+err:
+	CMPerr(CMP_F_CMP_CTX_CAPUBS_NUM, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Duplciate and copy the given stack of certificates to the given 
+ * CMP_CTX structure so that they may be retrieved later.
+ * ################################################################ */
+int CMP_CTX_set1_caPubs( CMP_CTX *ctx, const STACK_OF(X509) *caPubs) {
+	if (!ctx) goto err;
+	if (!caPubs) goto err;
+
+	if (ctx->caPubs) {
+		sk_X509_pop_free(ctx->caPubs, X509_free);
+		ctx->caPubs = NULL;
+	}
+
+	if (!(ctx->caPubs = X509_stack_dup(caPubs))) goto err;
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_CAPUBS, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Sets the CA certificate that is to be used for verifying response
+ * messages. Pointer is not consumed.
+ * ################################################################ */
+int CMP_CTX_set1_caCert( CMP_CTX *ctx, const X509 *cert) {
+	if (!ctx) goto err;
+	if (!cert) goto err;
+
+	if (ctx->caCert) {
+		X509_free(ctx->caCert);
+		ctx->caCert = NULL;
+	}
+
+	if (!(ctx->caCert = X509_dup( (X509*)cert))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_CACERT, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Set the X509 name of the recipient. Set in the PKIHeader.
+ * ################################################################ */
+int CMP_CTX_set1_recipient( CMP_CTX *ctx, const X509_NAME *name) {
+	if (!ctx) goto err;
+	if (!name) goto err;
+
+	if (ctx->recipient) {
+		X509_NAME_free(ctx->recipient);
+		ctx->recipient = NULL;
+	}
+
+	if (!(ctx->recipient = X509_NAME_dup( (X509_NAME*)name))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_RECIPIENT, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Set the subject name that will be placed in the certificate 
+ * request. This will be the subject name on the received certificate.
+ * ################################################################ */
+int CMP_CTX_set1_subjectName( CMP_CTX *ctx, const X509_NAME *name) {
+	if (!ctx) goto err;
+	if (!name) goto err;
+
+	if (ctx->subjectName) {
+		X509_NAME_free(ctx->subjectName);
+		ctx->subjectName = NULL;
+	}
+
+	if (!(ctx->subjectName = X509_NAME_dup( (X509_NAME*)name))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SUBJECTNAME, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Push a GENERAL_NAME structure that will be added to the CRMF
+ * request's extensions field to request subject alternative names.
+ * ################################################################ */
+int CMP_CTX_subjectAltName_push1( CMP_CTX *ctx, const GENERAL_NAME *name) {
+	if (!ctx) goto err;
+	if (!name) goto err;
+
+	if (!ctx->subjectAltNames && !(ctx->subjectAltNames = sk_GENERAL_NAME_new_null()))
+		goto err;
+
+	if (!sk_GENERAL_NAME_push(ctx->subjectAltNames, GENERAL_NAME_dup( (GENERAL_NAME*)name))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SUBJECTALTNAME_PUSH1, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Returns the name from the sender field of the last received 
+ * PKIMessage.
+ * ################################################################ */
+X509_NAME* CMP_CTX_sender_get( CMP_CTX *ctx) {
+	if (!ctx || !ctx->sender) return NULL;
+	return X509_NAME_dup(ctx->sender);
+}
+
+/* ################################################################ *
+ * Set the X509 name of the sender.
+ * ################################################################ */
+int CMP_CTX_set1_sender( CMP_CTX *ctx, const X509_NAME *name) {
+	if (!ctx) goto err;
+	if (!name) goto err;
+
+	if (ctx->sender) {
+		X509_NAME_free(ctx->sender);
+		ctx->sender = NULL;
+	}
+
+	if (!(ctx->sender = X509_NAME_dup( (X509_NAME*)name))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SENDER, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Set our own client certificate, used for example in KUR and when
+ * doing the IR with existing certificate.
+ * ################################################################ */
+int CMP_CTX_set1_clCert( CMP_CTX *ctx, const X509 *cert) {
+	if (!ctx) goto err;
+	if (!cert) goto err;
+
+	if (ctx->clCert) {
+		X509_free(ctx->clCert);
+		ctx->clCert = NULL;
+	}
+
+	if (!(ctx->clCert = X509_dup( (X509*)cert))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_CLCERT, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+
+/* ################################################################ *
+ * ################################################################ */
+int CMP_CTX_set1_newClCert( CMP_CTX *ctx, const X509 *cert) {
+	if (!ctx) goto err;
+	if (!cert) goto err;
+
+	if (ctx->newClCert) {
+		X509_free(ctx->newClCert);
+		ctx->newClCert = NULL;
+	}
+
+	if (!(ctx->newClCert = X509_dup( (X509*)cert))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_NEWCLCERT, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Set the client's private key. This creates a duplicate of the key
+ * so the given pointer is not used directly.
+ * ################################################################ */
+int CMP_CTX_set1_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey) {
+	EVP_PKEY *pkeyDup = NULL;
+	if (!ctx) goto err;
+	if (!pkey) goto err;
+
+	pkeyDup = pkey_dup(pkey);;
+	return CMP_CTX_set0_pkey(ctx, pkeyDup);
+
+err:
+	if (pkeyDup) EVP_PKEY_free(pkeyDup);
+	CMPerr(CMP_F_CMP_CTX_SET1_PKEY, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Set the client's current private key. NOTE: this version uses
+ * the given pointer directly!
+ * ################################################################ */
+int CMP_CTX_set0_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey) {
+	if (!ctx) goto err;
+	if (!pkey) goto err;
+
+	if (ctx->pkey) {
+		EVP_PKEY_free(ctx->pkey);
+		ctx->pkey = NULL;
+	}
+
+	ctx->pkey = (EVP_PKEY*) pkey;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET0_PKEY, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Set new private key. Used for example when doing Key Update.
+ * The key is duplicated so the original pointer is not directly used.
+ * ################################################################ */
+int CMP_CTX_set1_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey) {
+	EVP_PKEY *pkeyDup = NULL;
+	if (!ctx) goto err;
+	if (!pkey) goto err;
+
+	pkeyDup = pkey_dup(pkey);
+	return CMP_CTX_set0_newPkey(ctx, pkeyDup);
+
+err:
+	if (pkeyDup) EVP_PKEY_free(pkeyDup);
+	CMPerr(CMP_F_CMP_CTX_SET1_NEWPKEY, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Set new private key. Used for example when doing Key Update.
+ * NOTE: uses the pointer directly!
+ * ################################################################ */
+int CMP_CTX_set0_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey) {
+	if (!ctx) goto err;
+	if (!pkey) goto err;
+
+	if (ctx->newPkey) {
+		EVP_PKEY_free(ctx->newPkey);
+		ctx->newPkey = NULL;
+	}
+
+	ctx->newPkey = (EVP_PKEY*) pkey;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET0_NEWPKEY, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * 
+ * ################################################################ */
+int CMP_CTX_set1_transactionID( CMP_CTX *ctx, const ASN1_OCTET_STRING *id) {
+	if (!ctx) goto err;
+	if (!id) goto err;
+
+	if (ctx->transactionID) {
+		ASN1_OCTET_STRING_free(ctx->transactionID);
+		ctx->transactionID = NULL;
+	}
+
+	if (!(ctx->transactionID = ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)id)))
+	    return 0;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_TRANSACTIONID, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+
+/* ################################################################ */
+/* ################################################################ */
+int CMP_CTX_set1_recipNonce( CMP_CTX *ctx, const ASN1_OCTET_STRING *nonce) {
+	if (!ctx) goto err;
+	if (!nonce) goto err;
+
+	if (ctx->recipNonce) {
+		ASN1_OCTET_STRING_free(ctx->recipNonce);
+		ctx->recipNonce = NULL;
+	}
+
+	if (!(ctx->recipNonce = ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)nonce))) 
+	    return 0;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_RECIPNONCE, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ */
+/* ################################################################ */
+int CMP_CTX_set1_protectionAlgor( CMP_CTX *ctx, const X509_ALGOR *algor) {
+	if (!ctx) goto err;
+	if (!algor) goto err;
+
+	if (ctx->protectionAlgor) {
+		X509_ALGOR_free(ctx->protectionAlgor);
+		ctx->protectionAlgor = NULL;
+	}
+
+	if (!(ctx->protectionAlgor = X509_ALGOR_dup( (X509_ALGOR*)algor)))
+	    return 0;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_PROTECTIONALGOR, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ */
+/* ################################################################ */
+int CMP_CTX_set_compatibility( CMP_CTX *ctx, const int mode) {
+	if (!ctx) goto err;
+
+	ctx->compatibility = mode;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET_COMPATIBILITY, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Set the hostname of the proxy server to use for all connections
+ * ################################################################ */
+int CMP_CTX_set1_proxyName( CMP_CTX *ctx, const char *name) {
+	if (!ctx) goto err;
+	if (!name) goto err;
+
+	if (ctx->proxyName) {
+		OPENSSL_free( ctx->proxyName);
+		ctx->proxyName = NULL;
+	}
+
+	ctx->proxyName = OPENSSL_malloc( strlen(name)+1);
+	strcpy( ctx->proxyName, name);
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_PROXYNAME, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Set the hostname of the CA server
+ * ################################################################ */
+int CMP_CTX_set1_serverName( CMP_CTX *ctx, const char *name) {
+	if (!ctx) goto err;
+	if (!name) goto err;
+
+	if (ctx->serverName) {
+		OPENSSL_free( ctx->serverName);
+		ctx->serverName = NULL;
+	}
+
+	ctx->serverName = OPENSSL_malloc( strlen(name)+1);
+	strcpy( ctx->serverName, name);
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SERVERNAME, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ */
+/* ################################################################ */
+int CMP_CTX_set1_popoMethod( CMP_CTX *ctx, int method) {
+	if (!ctx) goto err;
+
+	ctx->popoMethod = method;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_POPOMETHOD, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ */
+/* ################################################################ */
+int CMP_CTX_set1_timeOut( CMP_CTX *ctx, int time) {
+	if (!ctx) goto err;
+
+	ctx->timeOut = time;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_TIMEOUT, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ */
+/* ################################################################ */
+int CMP_CTX_set1_proxyPort( CMP_CTX *ctx, int port) {
+	if (!ctx) goto err;
+
+	ctx->proxyPort = port;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_PROXYPORT, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ */
+/* ################################################################ */
+int CMP_CTX_set1_serverPort( CMP_CTX *ctx, int port) {
+	if (!ctx) goto err;
+
+	ctx->serverPort = port;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SERVERPORT, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Sets the HTTP path to be used on the server (normally "pkix/")
+ * ################################################################ */
+int CMP_CTX_set1_serverPath( CMP_CTX *ctx, const char *path) {
+	if (!ctx) goto err;
+
+	if (ctx->serverPath) {
+		/* clear the old value */
+		OPENSSL_free( ctx->serverPath);
+		ctx->serverPath = 0;
+	}
+
+	if (!path) {
+		/* clear the serverPath */
+		ctx->serverPath = OPENSSL_malloc(1);
+		ctx->serverPath[0] = 0;
+		return 1;
+	}
+
+	ctx->serverPath = OPENSSL_malloc( strlen(path)+1);
+	strcpy( ctx->serverPath, path);
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET1_SERVERPATH, CMP_R_NULL_ARGUMENT);
+	return 0;
+}
+
+/* ################################################################ *
+ * Sets the protection algorithm to be used for protecting messages.
+ * Possible choices are password based MAC and signature.
+ * ################################################################ */
+int CMP_CTX_set_protectionAlgor( CMP_CTX *ctx, const int algID) {
+	int nid;
+
+	if (!ctx) goto err;
+
+	switch (algID) {
+		case CMP_ALG_PBMAC:
+			nid = NID_id_PasswordBasedMAC;
+			break;
+		case CMP_ALG_SIG: {
+			/* first try to set algorithm based on the algorithm 
+			 * used in the certificate, if we already have one */
+			if (ctx->clCert && (ctx->protectionAlgor = ctx->clCert->sig_alg) != NULL)
+				return 1;
+
+			if (!ctx->pkey) goto err;
+#ifndef OPENSSL_NO_DSA
+			if (EVP_PKEY_type(ctx->pkey->type) == EVP_PKEY_DSA) {
+				nid = NID_dsaWithSHA1;
+				break;
+			}
+#endif
+#ifndef OPENSSL_NO_RSA
+			if (EVP_PKEY_type(ctx->pkey->type) == EVP_PKEY_RSA) {
+				nid = NID_sha1WithRSAEncryption;
+				break;
+			}
+#endif
+			goto err;
+			break;
+		}
+		default:
+			goto err;
+	}
+
+	if (ctx->protectionAlgor) {
+		X509_ALGOR_free(ctx->protectionAlgor);
+		ctx->protectionAlgor = NULL;
+	}
+
+	if (!(ctx->protectionAlgor = CMP_get_protectionAlgor_by_nid(nid))) goto err;
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CTX_SET_PROTECTIONALGOR, CMP_R_ERROR_SETTING_PROTECTION_ALGORITHM);
+	return 0;
+}
+
+/* ################################################################ *
+ * Set the failinfo error code bits in CMP_CTX based on the given
+ * CMP_PKIFAILUREINFO structure
+ * ################################################################ */
+int CMP_CTX_set_failInfoCode(CMP_CTX *ctx, CMP_PKIFAILUREINFO *failInfo) {
+	int i;
+
+	if (!ctx || !failInfo) return 0;
+
+	ctx->failInfoCode = 0;
+	for ( i=0; i <= CMP_PKIFAILUREINFO_MAX; i++)
+		if( ASN1_BIT_STRING_get_bit(failInfo, i))
+			ctx->failInfoCode |= 1 << i;
+
+	return 1;
+}
+
+unsigned long CMP_CTX_failInfoCode_get(CMP_CTX *ctx) {
+	if (!ctx) return 0;
+	return ctx->failInfoCode;
+}
+
+#if 0
+/* ################################################################ */
+/* pushes a given 0-terminated character string to ctx->freeText */
+/* this is inteded for human consumption */
+/* ################################################################ */
+int CMP_CTX_push_freeText( CMP_CTX *ctx, const char *text) {
+	ASN1_UTF8STRING *utf8string=NULL;
+
+	if (!ctx) goto err;
+	if (!text) goto err;
+
+	if (!ctx->freeText)
+		if( !(ctx->freeText = sk_ASN1_UTF8STRING_new())) goto err;
+
+	if( !(utf8string = ASN1_UTF8STRING_new())) goto err;
+	ASN1_UTF8STRING_set(utf8string, text, strlen(text));
+	if( !(sk_ASN1_UTF8STRING_push(ctx->freeText, utf8string) goto err;
+    return 1;
+err:
+    CMP_printf( "ERROR in FILE: %s, LINE: %d\n", __FILE__, __LINE__);
+	if (utf8string) ASN1_UTF8STRING_free(utf8string);
+	return 0;
+}
+#endif
+
+/* ################################################################ */
+/* sets a BOOLEAN option of the context to the "val" arg */
+/* ################################################################ */
+int CMP_CTX_set_option( CMP_CTX *ctx, const int opt, const int val) {
+	if (!ctx) goto err;
+
+	switch (opt) {
+		case CMP_CTX_OPT_IMPLICITCONFIRM:
+			ctx->implicitConfirm = val;
+			break;
+		case CMP_CTX_OPT_POPMETHOD:
+			ctx->popoMethod = val;
+			break;
+		case CMP_CTX_OPT_VALIDATEPATH:
+			ctx->validatePath = val;
+			break;
+		case CMP_CTX_OPT_MAXPOLLCOUNT:
+			ctx->maxPollCount = val;
+			break;
+		default:
+			goto err;
+	}
+
+	return 1;
+err:
+	return 0;
+}
+
+/* ################################################################ *
+ * Function used for printing debug messages.
+ * ################################################################ */
+void CMP_printf(const CMP_CTX *ctx, const char *fmt, ...)
+{
+	if (!ctx || !ctx->debug_cb) return;
+
+	va_list arg_ptr;
+	va_start(arg_ptr, fmt);
+
+	char buf[1024];
+	vsnprintf(buf, sizeof(buf), fmt, arg_ptr);
+	ctx->debug_cb(buf);
+
+	// else vfprintf(stdout, fmt, arg_ptr);
+	va_end(arg_ptr);
+}
+
+#ifdef HAVE_CURL
+long CMP_get_http_code(const CMPBIO *bio) {
+	long code = 0;
+	curl_easy_getinfo((CMPBIO*)bio, CURLINFO_RESPONSE_CODE, &code);
+	return code;
+}
+#endif
+
Index: openssl-1.0.0i-cmp/crypto/cmp/CMP_CTX.pod
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/CMP_CTX.pod	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/CMP_CTX.pod	(revision 469)
@@ -0,0 +1,375 @@
+=pod
+
+=head1 NAME
+
+ CMP_CTX_create,
+ CMP_CTX_init,
+ CMP_CTX_delete,
+ CMP_CTX_set1_referenceValue,
+ CMP_CTX_set1_secretValue,
+ CMP_CTX_set1_caCert,
+ CMP_CTX_set1_clCert,
+ CMP_CTX_set1_subjectName,
+ CMP_CTX_set1_newClCert,
+ CMP_CTX_set0_pkey,
+ CMP_CTX_set0_newPkey,
+ CMP_CTX_set1_pkey,
+ CMP_CTX_set1_newPkey,
+ CMP_CTX_set1_transactionID,
+ CMP_CTX_set1_recipNonce,
+ CMP_CTX_set1_protectionAlgor,
+ CMP_CTX_set_protectionAlgor,
+ CMP_CTX_set_compatibility,
+ CMP_CTX_set1_serverName,
+ CMP_CTX_set_option,
+ CMP_CTX_caPubs_pop,
+ CMP_CTX_caPubs_num,
+ CMP_CTX_set1_caPubs,
+ CMP_CTX_set1_extraCertsOut,
+ CMP_CTX_extraCertsOut_push1, 
+ CMP_CTX_extraCertsOut_num,
+ CMP_CTX_set1_extraCertsIn,
+ CMP_CTX_extraCertsIn_pop,
+ CMP_CTX_extraCertsIn_num,
+ CMP_CTX_set0_trustedStore,
+ CMP_CTX_set0_untrustedStore,
+ CMP_CTX_set_error_callback,
+ CMP_CTX_set_debug_callback
+
+ CMP_CTX_failInfoCode_get
+ CMP_CTX_sender_get
+ CMP_CTX_set1_popoMethod
+ CMP_CTX_set1_proxyName
+ CMP_CTX_set1_proxyPort
+ CMP_CTX_set1_recipient
+ CMP_CTX_set1_sender
+ CMP_CTX_set1_serverPath
+ CMP_CTX_set1_serverPort
+ CMP_CTX_set1_timeOut
+ CMP_CTX_set_certConf_callback
+ CMP_CTX_subjectAltName_push1
+
+=head1 SYNOPSIS
+
+ #include <openssl/cmp.h>
+
+ CMP_CTX *CMP_CTX_create();
+ int CMP_CTX_init( CMP_CTX *ctx);
+ void CMP_CTX_delete(CMP_CTX *ctx);
+
+ int CMP_CTX_set1_referenceValue( CMP_CTX *ctx, const unsigned char *ref, size_t len);
+ int CMP_CTX_set1_secretValue( CMP_CTX *ctx, const unsigned char *sec, const size_t len);
+ int CMP_CTX_set1_caCert( CMP_CTX *ctx, const X509 *cert);
+ int CMP_CTX_set1_clCert( CMP_CTX *ctx, const X509 *cert);
+ int CMP_CTX_set1_subjectName( CMP_CTX *ctx, const X509_NAME *name);
+ int CMP_CTX_set1_newClCert( CMP_CTX *ctx, const X509 *cert);
+ int CMP_CTX_set0_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+ int CMP_CTX_set0_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+ int CMP_CTX_set1_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+ int CMP_CTX_set1_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
+ int CMP_CTX_set1_transactionID( CMP_CTX *ctx, const ASN1_OCTET_STRING *id);
+ int CMP_CTX_set1_recipNonce( CMP_CTX *ctx, const ASN1_OCTET_STRING *nonce);
+ int CMP_CTX_set1_protectionAlgor( CMP_CTX *ctx, const X509_ALGOR *algor);
+ int CMP_CTX_set1_serverName( CMP_CTX *ctx, const char *name);
+ int CMP_CTX_set1_serverPort( CMP_CTX *ctx, int port);
+ X509 *CMP_CTX_caPubs_pop( CMP_CTX *ctx);
+ int CMP_CTX_caPubs_num( CMP_CTX *ctx);
+ int CMP_CTX_set1_caPubs( CMP_CTX *ctx, const STACK_OF(X509) *caPubs);
+
+ int CMP_CTX_set1_extraCertsOut( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsOut);
+ int CMP_CTX_extraCertsOut_push1( CMP_CTX *ctx, const X509 *val);
+ int CMP_CTX_extraCertsOut_num( CMP_CTX *ctx);
+ int CMP_CTX_set1_extraCertsIn( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsIn);
+ X509 *CMP_CTX_extraCertsIn_pop( CMP_CTX *ctx);
+ int CMP_CTX_extraCertsIn_num( CMP_CTX *ctx);
+
+ int CMP_CTX_set0_trustedStore( CMP_CTX *ctx, X509_STORE *store);
+ int CMP_CTX_set0_untrustedStore( CMP_CTX *ctx, X509_STORE *store);
+
+ int CMP_CTX_set_error_callback( CMP_CTX *ctx, cmp_logfn_t cb)
+ int CMP_CTX_set_debug_callback( CMP_CTX *ctx, cmp_logfn_t cb)
+
+ #define CMP_ALG_PBMAC 1
+ #define CMP_ALG_SIG   2
+ int CMP_CTX_set_protectionAlgor( CMP_CTX *ctx, const int algId);
+
+ #define CMP_COMPAT_RFC		1
+ #define CMP_COMPAT_CRYPTLIB	2
+ #define CMP_COMPAT_INSTA_3_3	4
+ int CMP_CTX_set_compatibility( CMP_CTX *ctx, const int mode);
+
+ #define CMP_CTX_OPT_UNSET           0
+ #define CMP_CTX_OPT_SET             1
+ #define CMP_CTX_OPT_IMPLICITCONFIRM 1
+ int CMP_CTX_set_option( CMP_CTX *ctx, const int opt, const int val);
+
+ unsigned long CMP_CTX_failInfoCode_get(CMP_CTX *ctx);
+ X509_NAME* CMP_CTX_sender_get( CMP_CTX *ctx);
+ int CMP_CTX_set1_popoMethod( CMP_CTX *ctx, int method);
+ int CMP_CTX_set1_proxyName( CMP_CTX *ctx, const char *name);
+ int CMP_CTX_set1_proxyPort( CMP_CTX *ctx, int port);
+ int CMP_CTX_set1_recipient( CMP_CTX *ctx, const X509_NAME *name);
+ int CMP_CTX_set1_sender( CMP_CTX *ctx, const X509_NAME *name);
+ int CMP_CTX_set1_serverPath( CMP_CTX *ctx, const char *path);
+ int CMP_CTX_set1_serverPort( CMP_CTX *ctx, int port);
+ int CMP_CTX_set1_timeOut( CMP_CTX *ctx, int time);
+ int CMP_CTX_set_certConf_callback( CMP_CTX *ctx, cmp_certConfFn_t cb);
+ int CMP_CTX_subjectAltName_push1( CMP_CTX *ctx, const GENERAL_NAME *name);
+
+=head1 DESCRIPTION
+
+This is the context API for using CMP (Certificate Management Protocol) with OpenSSL.
+
+CMP_CTX_create() allocates and initialized an CMP_CTX structure.
+
+CMP_CTX_init() initializes the context to default values. Compatibility
+is set to RFC, transport to HTTP, proof-of-posession method to
+POPOSigningKey
+
+CMP_CTX_delete() frees any allocated non-ASN1 fields of CMP_CTX and
+calls the ASN1 defined CMP_CTX_free() function to free the rest.
+
+CMP_CTX_set1_referenceValue() sets the given referenceValue in the given
+CMP_CTX structure.
+
+CMP_CTX_set1_secretValue() sets the given secretValue in the given
+CMP_CTX structure.
+
+CMP_CTX_set1_caCert() sets the given CA Certificate in the given CMP_CTX
+structure.
+
+CMP_CTX_set1_clCert() sets the given Client Certificate in the given
+CMP_CTX structure. The Client Certificate will then be used by the
+functions to set the "sender" field for messages originating from the
+client. The private key belonging to this certificate is then used
+create the protection in case of MSG_SIG_ALG.
+
+CMP_CTX_set1_subjectName() sets the subject name that will be used in
+the CertTemplate structure when requesting a new certificate. Note that
+if clCert is set, the name will be read from them and this will be
+ignored.
+
+CMP_CTX_set1_newClCert() sets the given (newly obtained) Client
+Certificate in the given CMP_CTX structure.
+
+CMP_CTX_set0_pkey() sets the given EVP_PKEY structure, holding the
+private and public keys, belonging to the Client Certificate, in the
+given CMP_CTX structure.
+
+CMP_CTX_set1_pkey() is the same as above, except that it does not
+consume the pointer.
+
+CMP_CTX_set0_newPkey() sets the given EVP_PKEY structure, holding the
+private and public keys, which shall be certified, in the given CMP_CTX
+structure
+
+CMP_CTX_set1_newPkey() is the same as above, except that it does not
+consume the pointer.
+
+CMP_CTX_set1_transactionID() sets the given transaction ID in the given
+CMP_CTX structure.
+
+CMP_CTX_set1_recipNonce() sets the given recip nonce in the given
+CMP_CTX structure.
+
+CMP_CTX_set1_protectionAlgor() sets the protection algorithm, which
+shall be used for the CMP conversation, in the given CMP_CTX structure.
+
+CMP_CTX_set1_serverName() sets the given server Address (as IP or name)
+in the given CMP_CTX structure.
+
+CMP_CTX_set1_serverPort() sets the port of the CMP server to connect to.
+
+CMP_CTX_set_protectionAlgor() sets the given definition (CMP_ALG_PBMAG
+or CMP_ALG_SIG) of the algorithm to use in the given CMP_CTX structure.
+
+CMP_CTX_set_compatibility() sets the given compatibility in the given
+CMP_CTX structure. This is needed since the CMP RFC can be interpreted
+in different ways so certain implementations may react different than
+others. Available Options are CMP_COMPAT_RFC for strict RFC conformace,
+CMP_COMPAT_CRYPTLIB for Cryptlib adaption, CMP_COMPAT_INSTA for Insta
+Certifier version < 3.3 adaption and CMP_COMPAT_INSTA_3_3 for Insta Certifier
+version => 3.3 adaption.
+
+CMP_CTX_set_option() sets the given values to the options
+(e.g. CMP_CTX_OPT_IMPLICITCONFIRM) in the given CMP_CTX structure. The
+values can be CMP_CTX_OPT_UNSET or CMP_CTX_OPT_SET. Options are always
+set to UNSET when the CMP_CTX structure is initialized.
+
+CMP_CTX_caPubs_num() can be used after an Initial Request or Key Update
+request to check the number of CA certificates that were sent from the
+server.
+
+CMP_CTX_caPubs_pop() pops one CA certificates of the stack of received
+CA certs and returns it
+
+CMP_CTX_set1_caPubs() copies the given caPubs stack to the context so
+that it may be accessed later by CMP_CTX_caPubs_num() and
+CMP_CTX_caPubs_pop().
+
+CMP_CTX_set1_extraCertsOut() sets the stack of extraCerts that will be
+sent to remote.
+
+CMP_CTX_extraCertsOut_push1() adds the given certificate to the outbound
+extraCerts stack, without consuming the pointer.
+ 
+CMP_CTX_extraCertsOut_num() returns the number of certificates in the
+outbound extraCerts stack.
+
+CMP_CTX_set1_extraCertsIn() sets the stack of extraCerts that was
+received from remote.
+
+CMP_CTX_extraCertsIn_pop() pops and returns one certificate off the
+stack of extra certificates received from remote.
+
+CMP_CTX_extraCertsIn_num() returns the number of certificates that were
+received from remote.
+
+CMP_CTX_set0_trustedStore() sets the X509_STORE type certifice store
+containing root CA certificates. This is used for example when
+attempting to validate CA certificate path.
+
+CMP_CTX_set0_untrustedStore() sets the X509_STORE type certifice store
+containing intermediate certificates needed for building our own
+certificate chain and including it in extraCerts.
+
+CMP_CTX_set_error_callback() sets a callback function for receiving
+error messages.
+
+CMP_CTX_set_debug_callback() sets a callback function for receiving
+debug messages.
+
+CMP_CTX_failInfoCode_get() returns the CMP error code from the failInfo
+field. This is a bit field and the flags for it are specified in
+cmp.h. The flags start with CMP_CTX_FAILINFO, for example:
+CMP_CTX_FAILINFO_badAlg.
+
+CMP_CTX_sender_get() Returns the name from the sender field of the last
+received PKIMessage.
+
+CMP_CTX_set1_popoMethod() sets the proof-of-posession method to be used
+for ir, kur etc. Possible values are CMP_POPO_SIGNATURE and
+CMP_POPO_ENCRCERT.
+
+CMP_CTX_set1_proxyName() sets the hostname of the HTTP proxy to be used
+for connecting to the CA server.
+
+CMP_CTX_set1_proxyPort() sets the port of the HTTP proxy.
+
+CMP_CTX_set1_recipient() sets the recipient name that will be set in the
+PKIHeader, i.e. the X509 name of the CA server.
+
+CMP_CTX_set1_sender() sets the X509 name of the sender.
+
+CMP_CTX_set1_serverPath() HTTP path of the CMP server on the host.
+
+CMP_CTX_set1_serverPort() server port to connect to.
+
+CMP_CTX_set1_timeOut() sets the maximum amount of time an operation is
+allowed to take before a timeout error is returned.
+
+CMP_CTX_set_certConf_callback() sets a callback that can be used to
+check the certificate received from the server. If the certificate
+should be accepted the callback must return 1, and 0 if the certificate
+is to be rejected.
+
+CMP_CTX_subjectAltName_push1() adds the given X509 name to the list of
+alternate names on the certificate template request.
+
+=head1 NOTES
+
+CMP is defined in RFC 4210 (and CRMF in RFC 4211).
+
+The implementation of CMP for OpenSSL is still work in progress. The API
+might change every release!
+
+=head1 RETURN VALUES
+
+CMP_CTX_create() returns a pointer to an initialized CMP_CTX structure.
+
+All other functions return 0 on error, 1 on success.
+
+=head1 EXAMPLE
+
+The following code does an Initial Request with a Cryptlib CA:
+
+	cmp_ctx = CMP_CTX_create();
+	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
+	CMP_CTX_set1_referenceValue( cmp_ctx, idString, idStringLen);
+	CMP_CTX_set1_secretValue( cmp_ctx, password, passwordLen);
+	CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
+	CMP_CTX_set1_caCert( cmp_ctx, caCert);
+
+	CMP_new_http_bio( &cbio, opt_serverName, opt_serverPort);
+
+	initialClCert = CMP_doInitialRequestSeq( cbio, cmp_ctx);
+	BIO_free(cbio);
+
+The following code does an Initial Request with an Insta CA, using an
+external identity certificate (Appendix E.7):
+
+	cmp_ctx = CMP_CTX_create();
+	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
+	CMP_CTX_set1_referenceValue( cmp_ctx, idString, idStringLen);
+	CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
+	CMP_CTX_set1_caCert( cmp_ctx, caCert);
+
+	CMP_new_bio( &cbio, opt_serverName, opt_serverPort);
+
+	initialClCert = CMP_doInitialRequestSeq( cbio, cmp_ctx);
+	BIO_free(cbio);
+
+Here externalCert is an X509 certificate granted to the EE by another CA
+which is trusted by the current CA the code will connect to.
+
+
+The following code does a Key Update Request:
+
+	cmp_ctx = CMP_CTX_create();
+	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
+	CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
+	CMP_CTX_set0_newPkey( cmp_ctx, updatedPkey);
+	CMP_CTX_set1_clCert( cmp_ctx, initialClCert);
+	CMP_CTX_set1_caCert( cmp_ctx, caCert);
+
+	CMP_new_bio( &cbio, opt_serverName, opt_serverPort);
+
+	updatedClCert = CMP_doKeyUpdateRequestSeq( cbio, cmp_ctx);
+	BIO_free(cbio);
+
+The following code does an Key Update Request with a Cryptlib CA:
+
+	cmp_ctx = CMP_CTX_create();
+	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
+	CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
+	CMP_CTX_set0_newPkey( cmp_ctx, updatedPkey);
+	CMP_CTX_set1_clCert( cmp_ctx, initialClCert);
+	CMP_CTX_set1_caCert( cmp_ctx, caCert);
+
+	CMP_new_http_bio( &cbio, opt_serverName, opt_serverPort);
+
+	updatedClCert = CMP_doKeyUpdateRequestSeq( cbio, cmp_ctx);
+	BIO_free(cbio);
+
+The following code does an Key Update Request with an Insta Certifier
+CA:
+
+	cmp_ctx = CMP_CTX_create();
+	CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
+	CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
+	CMP_CTX_set0_newPkey( cmp_ctx, updatedPkey);
+	CMP_CTX_set1_clCert( cmp_ctx, initialClCert);
+	CMP_CTX_set1_caCert( cmp_ctx, caCert);
+
+	CMP_new_bio( &cbio, opt_serverName, opt_serverPort);
+
+	updatedClCert = CMP_doKeyUpdateRequestSeq( cbio, cmp_ctx);
+	BIO_free(cbio);
+
+=head1 TODO
+
+A lot!
+
+=head1 SEE ALSO
+
+CMP_sessions, CMP_http
Index: openssl-1.0.0i-cmp/crypto/cmp/cmp_vfy.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/cmp_vfy.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/cmp_vfy.c	(revision 469)
@@ -0,0 +1,380 @@
+/* vim: set noet ts=4 sts=4 sw=4: */
+/* crypto/cmp/cmp_vfy.c
+ * Functions to verify CMP (RFC 4210) messages for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ * 06/2010 - Miikka Viljanen - Report errors with OpenSSL error codes instead
+ *                             of printf statements.
+ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/cmp.h>
+#include <openssl/err.h>
+
+int CMP_error_callback(const char *str, size_t len, void *u);
+
+/* ############################################################################ *
+ * validate a protected message (sha1+RSA/DSA or any other algorithm supported by OpenSSL)
+ * ############################################################################ */
+static int CMP_verify_signature( CMP_PKIMESSAGE *msg, X509_ALGOR *algor, EVP_PKEY *senderPkey) {
+    EVP_MD_CTX *ctx=NULL;
+    CMP_PROTECTEDPART protPart;
+    int ret;
+
+    size_t protPartDerLen;
+    unsigned char *protPartDer=NULL;
+
+    if (!msg || !algor || !senderPkey) return 0;
+
+    protPart.header = msg->header;
+    protPart.body   = msg->body;
+    protPartDerLen  = i2d_CMP_PROTECTEDPART(&protPart, &protPartDer);
+
+    ctx=EVP_MD_CTX_create();
+    EVP_VerifyInit_ex(ctx, EVP_get_digestbynid(OBJ_obj2nid(algor->algorithm)), NULL);
+    EVP_VerifyUpdate(ctx, protPartDer, protPartDerLen);
+    ret = EVP_VerifyFinal(ctx, msg->protection->data, msg->protection->length, senderPkey);
+
+    /* cleanup */
+    EVP_MD_CTX_destroy(ctx);
+    return ret;
+}
+
+/* ############################################################################ */
+/* Validate the protection of a PKIMessage
+ * returns 1 when valid
+ * returns 0 when invalid, not existent or on error
+ */
+/* ############################################################################ */
+int CMP_protection_verify(CMP_PKIMESSAGE *msg, 
+			    X509_ALGOR *_algor,
+			    EVP_PKEY *senderPkey,
+			    const ASN1_OCTET_STRING *secret)
+{
+    ASN1_BIT_STRING *protection=NULL;
+    X509_ALGOR *algor=NULL;
+    ASN1_OBJECT *algorOID=NULL;
+    int valid = 0;
+
+    int usedAlgorNid;
+
+    if (!msg->protection) goto err;
+    if (!msg->header->protectionAlg) goto err;
+    if (!(algor = X509_ALGOR_dup(msg->header->protectionAlg))) goto err;
+
+    X509_ALGOR_get0( &algorOID, NULL, NULL, algor);
+    usedAlgorNid = OBJ_obj2nid(algorOID);
+    if (usedAlgorNid == NID_id_PasswordBasedMAC) {
+        /* need to have params for PBMAC, so check that we have them */
+        if (!algor->parameter || 
+            ASN1_TYPE_get(algor->parameter) == V_ASN1_UNDEF ||
+            ASN1_TYPE_get(algor->parameter) == V_ASN1_NULL) {
+            /* if parameter is not given in PKIMessage, then try to use parameter from arguments */
+            if (!_algor || algor->algorithm->nid != _algor->algorithm->nid || 
+                ASN1_TYPE_get(_algor->parameter) == V_ASN1_UNDEF || 
+                ASN1_TYPE_get(_algor->parameter) == V_ASN1_NULL) {
+                CMPerr(CMP_F_CMP_PROTECTION_VERIFY, CMP_R_FAILED_TO_DETERMINE_PROTECTION_ALGORITHM);
+                goto err;
+            }
+            if (!algor->parameter)
+                algor->parameter = ASN1_TYPE_new();
+            ASN1_TYPE_set(algor->parameter, _algor->parameter->type, _algor->parameter->value.ptr);
+        }
+    }
+
+    // printf("INFO: Verifying protection, algorithm %s\n", OBJ_nid2sn(OBJ_obj2nid(msg->header->protectionAlg->algorithm)));
+
+    if (usedAlgorNid == NID_id_PasswordBasedMAC)  {
+        /* password based Mac */ 
+        if (!(protection = CMP_protection_new( msg, algor, NULL, secret)))
+            goto err; /* failed to generate protection string! */
+        if (!M_ASN1_BIT_STRING_cmp( protection, msg->protection))
+            /* protection is valid */
+            valid = 1;
+        else
+            /* strings are not equal */
+            valid = 0;
+    }
+    else {
+        valid = CMP_verify_signature(msg, algor, senderPkey);
+    }
+
+    X509_ALGOR_free(algor);
+
+    return valid;
+
+err:
+    if (algor) X509_ALGOR_free(algor);
+    CMPerr(CMP_F_CMP_PROTECTION_VERIFY, CMP_R_ERROR_VERIFYING_PROTECTION);
+    return 0;
+}
+
+/* ############################################################################ *
+ * Structure to hold the X509_STORE_CTX and a pointer to CMP_CTX so that we can
+ * provide extra data to the cert validation callback
+ * ############################################################################ */
+typedef struct {
+    X509_STORE_CTX cert_ctx;
+    CMP_CTX *cmp_ctx;
+} X509_STORE_CTX_ext;
+
+/* ############################################################################ *
+ * Attempt to validate certificate path. returns 1 if the path was
+ * validated successfully and 0 if not.
+ * ############################################################################ */
+int CMP_validate_cert_path(CMP_CTX *cmp_ctx, STACK_OF(X509) *tchain, STACK_OF(X509) *uchain, X509 *cert)
+{
+    int i=0,ret=0,valid=0;
+    X509_STORE *ctx=NULL;
+    X509_STORE_CTX *csc=NULL;
+    X509_STORE_CTX_ext cscex;
+    STACK_OF(X509) *untrusted_chain=NULL;
+
+    if (cmp_ctx == NULL || cert == NULL) goto end;
+
+    if (!cmp_ctx->trusted_store && !tchain) {
+        CMPerr(CMP_F_CMP_VALIDATE_CERT_PATH, CMP_R_NO_TRUSTED_CERTIFICATES_SET);
+        goto end;
+    }
+
+    if (!cmp_ctx->trusted_store)
+        cmp_ctx->trusted_store = ctx = X509_STORE_new();
+    else
+        ctx = cmp_ctx->trusted_store;
+    if (!ctx) goto end;
+
+    csc = X509_STORE_CTX_new();
+    if (csc == NULL) {
+		if (cmp_ctx&&cmp_ctx->error_cb) 
+			ERR_print_errors_cb(CMP_error_callback, (void*) cmp_ctx);
+		goto end;
+    }
+
+    /* include the certs in ctx->untrusted_store in the validation process.
+     * first attempt to find the relevant intermediate certs in the untrusted store */
+    if (cmp_ctx->untrusted_store)
+        untrusted_chain = CMP_build_cert_chain(cmp_ctx->untrusted_store, cert, 0);
+
+    /* failed to get any cert chain, so create an empty one */
+	if (!untrusted_chain) untrusted_chain = sk_X509_new_null();
+
+    /* add the untrusted certs give in arguments (i.e. caPubs/extraCerts) */
+    for (i = 0; i < sk_X509_num(uchain); i++)
+        sk_X509_push(untrusted_chain, X509_dup(sk_X509_value(uchain, i)));
+    
+	X509_STORE_set_flags(ctx, 0);
+	if(!X509_STORE_CTX_init(csc, ctx, cert, untrusted_chain)) {
+		if (cmp_ctx&&cmp_ctx->error_cb) 
+			ERR_print_errors_cb(CMP_error_callback, (void*) cmp_ctx);
+		goto end;
+	}
+
+    /* add whatever stuff we have in tcain to the trusted store.
+     * it we set tchain using X509_STORE_CTX_trusted_stack the
+     * trusted_store will be ignored, so we do it this way... */
+	for (i=0; i < sk_X509_num(tchain); i++)
+		X509_STORE_add_cert(cmp_ctx->trusted_store, X509_dup(sk_X509_value(tchain, i)));
+
+
+    /* if(tchain) X509_STORE_CTX_trusted_stack(csc, tchain); */
+
+    /* TODO handle CRLs? */
+    /* if (crls) X509_STORE_CTX_set0_crls(csc, crls); */
+
+    cscex.cert_ctx = *csc;
+    cscex.cmp_ctx = cmp_ctx;
+    valid=X509_verify_cert((X509_STORE_CTX*) &cscex);
+
+    X509_STORE_CTX_free(csc);
+
+    ret=0;
+end:
+	if (untrusted_chain)
+		sk_X509_pop_free(untrusted_chain, X509_free);
+    
+    if (valid > 0) {
+        CMP_printf(cmp_ctx, "Validation OK\n");
+        ret=1;
+    }
+    else if (cmp_ctx&&cmp_ctx->error_cb) 
+    	ERR_print_errors_cb(CMP_error_callback, (void*) cmp_ctx);
+
+    return(ret);
+}
+
+#if 0
+static void nodes_print(BIO *out, const char *name,
+    STACK_OF(X509_POLICY_NODE) *nodes)
+    {
+    X509_POLICY_NODE *node;
+    int i;
+    BIO_printf(out, "%s Policies:", name);
+    if (nodes)
+        {
+        BIO_puts(out, "\n");
+        for (i = 0; i < sk_X509_POLICY_NODE_num(nodes); i++)
+            {
+            node = sk_X509_POLICY_NODE_value(nodes, i);
+            X509_POLICY_NODE_print(out, node, 2);
+            }
+        }
+    else
+        BIO_puts(out, " <empty>\n");
+    }
+
+
+static void policies_print(BIO *out, X509_STORE_CTX *ctx)
+    {
+    X509_POLICY_TREE *tree;
+    int explicit_policy;
+    int free_out = 0;
+    if (out == NULL)
+        {
+        out = BIO_new_fp(stderr, BIO_NOCLOSE);
+        free_out = 1;
+        }
+    tree = X509_STORE_CTX_get0_policy_tree(ctx);
+    explicit_policy = X509_STORE_CTX_get_explicit_policy(ctx);
+
+    BIO_printf(out, "Require explicit Policy: %s\n", explicit_policy ? "True" : "False");
+
+    nodes_print(out, "Authority", X509_policy_tree_get0_policies(tree));
+    nodes_print(out, "User", X509_policy_tree_get0_user_policies(tree));
+    if (free_out)
+        BIO_free(out);
+    }
+#endif
+
+/* ############################################################################ *
+ * This is called for every valid certificate. Here we could add additional checks,
+ * for policies for example.
+ * ############################################################################ */
+int CMP_cert_callback(int ok, X509_STORE_CTX *ctx)
+{
+    X509_STORE_CTX_ext *ctxext = (X509_STORE_CTX_ext*) ctx;
+    int cert_error = X509_STORE_CTX_get_error(ctx);
+    X509 *current_cert = X509_STORE_CTX_get_current_cert(ctx);
+
+    /* TODO: we could check policies here too */
+
+    if (!ok)
+    {
+        char cert_name[512] = {0};
+        if (current_cert)
+        {
+            BIO *bio = BIO_new(BIO_s_mem());
+            X509_NAME_print(bio, X509_get_subject_name(current_cert), XN_FLAG_ONELINE);
+            BIO_read(bio, cert_name, sizeof(cert_name));
+            BIO_free(bio);
+        }
+
+        CMP_printf(ctxext->cmp_ctx, "Certificate '%s': %serror %d at %d depth lookup:%s\n",
+                   cert_name,
+                   X509_STORE_CTX_get0_parent_ctx(ctx) ? "[CRL path]" : "",
+                   cert_error,
+                   X509_STORE_CTX_get_error_depth(ctx),
+                   X509_verify_cert_error_string(cert_error));
+        switch(cert_error)
+        {
+            case X509_V_ERR_NO_EXPLICIT_POLICY:
+                // policies_print(NULL, ctx);
+            case X509_V_ERR_CERT_HAS_EXPIRED:
+
+                /* since we are just checking the certificates, it is
+                 * ok if they are self signed. But we should still warn
+                 * the user.
+                 */
+
+            case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
+                /* Continue after extension errors too */
+            case X509_V_ERR_INVALID_CA:
+            case X509_V_ERR_INVALID_NON_CA:
+            case X509_V_ERR_PATH_LENGTH_EXCEEDED:
+            case X509_V_ERR_INVALID_PURPOSE:
+            case X509_V_ERR_CRL_HAS_EXPIRED:
+            case X509_V_ERR_CRL_NOT_YET_VALID:
+            case X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:
+                ok = 1;
+
+        }
+
+        CMP_printf(ctxext->cmp_ctx, "cert_error = %d\n", cert_error);
+
+        return ok;
+
+    }
+#if 0
+    if (cert_error == X509_V_OK && ok == 2)
+        policies_print(NULL, ctx);
+#endif
+
+    return(ok);
+}
+
Index: openssl-1.0.0i-cmp/crypto/cmp/cmp_lib.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/cmp_lib.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/cmp_lib.c	(revision 469)
@@ -0,0 +1,1295 @@
+/* crypto/cmp/cmp_lib.c
+ * CMP (RFC 4210) library functions for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ * 06/2010 - Miikka Viljanen - Report errors with OpenSSL error codes instead
+ *                             of printf statements.
+ */
+
+
+ /* NAMING
+  * The 0 version uses the supplied structure pointer directly in the parent and
+  * it will be freed up when the parent is freed. In the above example crl would
+  * be freed but rev would not.
+  *
+  * The 1 function uses a copy of the supplied structure pointer (or in some
+  * cases increases its link count) in the parent and so both (x and obj above)
+  * should be freed up.
+ */
+
+/* ############################################################################ *
+ * In this file are the functions which set the individual items inside         *
+ * the CMP structures                                                           *
+ * ############################################################################ */
+
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/cmp.h>
+#include <openssl/x509.h>
+#include <openssl/rand.h>
+#include <openssl/safestack.h>
+#include <openssl/crypto.h>
+#include <openssl/engine.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+/* for bio_err */
+#include <openssl/err.h>
+
+#include <time.h>
+
+
+/* ############################################################################ *
+ * Sets the protocol version number in PKIHeader.
+ * ############################################################################ */
+int CMP_PKIHEADER_set_version(CMP_PKIHEADER *hdr, int version) {
+	if( !hdr) return 0;
+
+	ASN1_INTEGER_set(hdr->pvno, version);
+
+	return 1;
+}
+
+/* ############################################################################ *
+ * Set the recipient name of PKIHeader. The pointer nm is used directly!
+ * ############################################################################ */
+int CMP_PKIHEADER_set0_recipient(CMP_PKIHEADER *hdr, const X509_NAME *nm)
+{
+	GENERAL_NAME *gen=NULL;
+	if( !hdr) return 0;
+
+	gen = GENERAL_NAME_new();
+	if( !gen) return 0;
+
+	/* if nm is not set an empty dirname will be set */
+	if (nm == NULL) {
+		if(gen->d.directoryName) X509_NAME_free(gen->d.directoryName);
+		gen->d.directoryName = X509_NAME_new();
+	} else {
+		if (!X509_NAME_set(&gen->d.directoryName, (X509_NAME*) nm))
+		{
+			GENERAL_NAME_free(gen);
+			return 0;
+		}
+	}
+	gen->type = GEN_DIRNAME;
+	if (hdr->recipient)
+		GENERAL_NAME_free(hdr->recipient);
+	hdr->recipient = gen;
+	return 1;
+}
+
+/* ############################################################################ *
+ * Set the recipient name of PKIHeader. The contents of nm is copied.
+ * ############################################################################ */
+int CMP_PKIHEADER_set1_recipient(CMP_PKIHEADER *hdr, const X509_NAME *nm)
+{
+	X509_NAME *nmDup=NULL;
+
+	if( !hdr) return 0;
+
+	if(nm && !(nmDup = X509_NAME_dup( (X509_NAME*) nm)))
+		return 0;
+
+	return CMP_PKIHEADER_set0_recipient( hdr, nmDup);
+}
+
+/* ############################################################################ *
+ * Set the sender name in PKIHeader.
+ * ############################################################################ */
+int CMP_PKIHEADER_set0_sender(CMP_PKIHEADER *hdr, const X509_NAME *nm)
+{
+	GENERAL_NAME *gen=NULL;
+	if( !hdr) return 0;
+
+	gen = GENERAL_NAME_new();
+	if( !gen) return 0;
+
+	/* if nm is not set an empty dirname will be set */
+	if (nm == NULL) {
+		if(gen->d.directoryName) X509_NAME_free(gen->d.directoryName);
+		gen->d.directoryName = X509_NAME_new();
+	} else {
+		if (!X509_NAME_set(&gen->d.directoryName, (X509_NAME*) nm))
+		{
+			GENERAL_NAME_free(gen);
+			return 0;
+		}
+	}
+	gen->type = GEN_DIRNAME;
+	if (hdr->sender)
+		GENERAL_NAME_free(hdr->sender);
+	hdr->sender = gen;
+	return 1;
+}
+
+/* ############################################################################ *
+ * Set the sender name in PKIHeader. The contents of nm is duplicated.
+ * ############################################################################ */
+int CMP_PKIHEADER_set1_sender(CMP_PKIHEADER *hdr, const X509_NAME *nm)
+{
+	X509_NAME *nmDup=NULL;
+
+	if( !hdr) return 0;
+
+	if(nm)
+		nmDup = X509_NAME_dup( (X509_NAME*) nm);
+
+	return CMP_PKIHEADER_set0_sender( hdr, nmDup);
+}
+
+/* ############################################################################ *
+ * Creates an X509_ALGOR structure based on the given algorithm id.
+ * ############################################################################ */
+X509_ALGOR *CMP_get_protectionAlgor_by_nid(int nid) {
+	X509_ALGOR *alg=NULL;
+
+	switch(nid) {
+		case NID_id_PasswordBasedMAC:
+			return CMP_get_protectionAlgor_pbmac();
+			break;
+		case NID_sha1WithRSAEncryption:
+		case NID_dsaWithSHA1:
+		default:
+			if( !(alg = X509_ALGOR_new())) goto err;
+			if( !(X509_ALGOR_set0( alg, OBJ_nid2obj(nid), V_ASN1_NULL, NULL))) goto err;
+			break;
+	}
+	return alg;
+err:
+	if (alg) X509_ALGOR_free(alg);
+	return NULL;
+}
+
+/* ############################################################################ *
+ * Create an X509_ALGOR structure for PasswordBasedMAC protection
+ * ############################################################################ */
+X509_ALGOR *CMP_get_protectionAlgor_pbmac(void) {
+	X509_ALGOR *alg=NULL;
+	CRMF_PBMPARAMETER *pbm=NULL;
+	unsigned char *pbmDer=NULL;
+	int pbmDerLen;
+	ASN1_STRING *pbmStr=NULL;
+
+	if (!(alg = X509_ALGOR_new())) goto err;
+	if (!(pbm = CRMF_pbm_new())) goto err;
+	if (!(pbmStr = ASN1_STRING_new())) goto err;
+
+	pbmDerLen = i2d_CRMF_PBMPARAMETER( pbm, &pbmDer);
+
+	ASN1_STRING_set( pbmStr, pbmDer, pbmDerLen);
+	OPENSSL_free( pbmDer);
+	pbmDer = NULL; /* to avoid double free in case there would be a "goto err" inserted behind this point later in development */
+
+	X509_ALGOR_set0( alg, OBJ_nid2obj(NID_id_PasswordBasedMAC), V_ASN1_SEQUENCE, pbmStr);
+	pbmStr = NULL; /* pbmStr is not freed explicityly because the pointer was consumed by X509_ALGOR_set0() */
+
+	CRMF_PBMPARAMETER_free( pbm);
+	return alg;
+err:
+	if (alg) X509_ALGOR_free(alg);
+	if (pbm) CRMF_PBMPARAMETER_free( pbm);
+	if (pbmDer) OPENSSL_free( pbmDer);
+	return NULL;
+}
+
+/* ############################################################################ */
+	/*
+   It is RECOMMENDED that the clients fill the transactionID field with
+   128 bits of (pseudo-) random data for the start of a transaction to
+   reduce the probability of having the transactionID in use at the
+   server.
+   */
+int CMP_PKIHEADER_set1_transactionID(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *transactionID) {
+#define TRANSACTIONID_LENGTH 16
+	unsigned char *transactionIDuchar=NULL;
+
+	if( !hdr) goto err;
+
+	if (hdr->transactionID == NULL) {
+		hdr->transactionID = ASN1_OCTET_STRING_new();
+	}
+
+	/* generate a new value if none was given */
+	if (transactionID == NULL) {
+		transactionIDuchar = (unsigned char*)OPENSSL_malloc(TRANSACTIONID_LENGTH);
+		RAND_pseudo_bytes(transactionIDuchar, TRANSACTIONID_LENGTH);
+		if (!(ASN1_OCTET_STRING_set(hdr->transactionID, transactionIDuchar, TRANSACTIONID_LENGTH))) goto err;
+	} else {
+		if (!(hdr->transactionID = ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)transactionID))) goto err;
+	}
+
+	if(transactionIDuchar)
+		OPENSSL_free(transactionIDuchar);
+	return 1;
+err:
+	if(transactionIDuchar)
+		OPENSSL_free(transactionIDuchar);
+	return 0;
+}
+
+/* ############################################################################ */
+	/*
+   senderNonce          present
+     -- 128 (pseudo-)random bits
+   The senderNonce and recipNonce fields protect the PKIMessage against
+   replay attacks.  The senderNonce will typically be 128 bits of
+   (pseudo-) random data generated by the sender, whereas the recipNonce
+   is copied from the senderNonce of the previous message in the
+   transaction.
+     */
+
+int CMP_PKIHEADER_new_senderNonce(CMP_PKIHEADER *hdr) {
+#define SENDERNONCE_LENGTH 16
+	unsigned char senderNonce[SENDERNONCE_LENGTH];
+	RAND_pseudo_bytes(senderNonce, SENDERNONCE_LENGTH);
+
+	if( !hdr) goto err;
+
+	if (hdr->senderNonce == NULL) {
+		hdr->senderNonce = ASN1_OCTET_STRING_new();
+	}
+
+	if (!(ASN1_OCTET_STRING_set(hdr->senderNonce, senderNonce, SENDERNONCE_LENGTH))) goto err;
+
+	return 1;
+err:
+	return 0;
+}
+
+
+/* ############################################################################ */
+/*
+         -- nonces used to provide replay protection, senderNonce
+         -- is inserted by the creator of this message; recipNonce
+         -- is a nonce previously inserted in a related message by
+         -- the intended recipient of this message
+ */
+int CMP_PKIHEADER_set1_recipNonce(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *recipNonce) {
+	if( !hdr) goto err;
+	if( !recipNonce) goto err;
+
+	if (hdr->recipNonce != NULL)
+		ASN1_OCTET_STRING_free(hdr->recipNonce);
+
+	if (!(hdr->recipNonce = ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)recipNonce))) goto err;
+
+	return 1;
+err:
+	return 0;
+}
+
+
+/* ############################################################################ */
+/*
+   senderKID            referenceNum
+     -- the reference number which the CA has previously issued
+     -- to the end entity (together with the MACing key)
+     */
+int CMP_PKIHEADER_set1_senderKID(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *senderKID) {
+	if (!hdr) goto err;
+	if (!senderKID) goto err;
+
+	if (hdr->senderKID)
+		 ASN1_OCTET_STRING_free(hdr->senderKID);
+
+	if (!(hdr->senderKID = ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)senderKID))) goto err;
+
+	return 1;
+err:
+	return 0;
+}
+
+/* ############################################################################
+ * set the messageTime to the current system time
+ *
+ * The messageTime field contains the time at which the sender created
+ * the message.  This may be useful to allow end entities to
+ * correct/check their local time for consistency with the time on a
+ * central system.
+ * ############################################################################ */
+int CMP_PKIHEADER_set_messageTime(CMP_PKIHEADER *hdr) {
+	if (!hdr) goto err;
+
+	if (!hdr->messageTime)
+		 hdr->messageTime = ASN1_GENERALIZEDTIME_new();
+
+	if (! ASN1_GENERALIZEDTIME_set( hdr->messageTime, time(NULL))) goto err;
+	return 1;
+err:
+	return 0;
+}
+
+/* ############################################################################ *
+ * Set the algorithm to use for message protection.
+ * ############################################################################ */
+int CMP_PKIHEADER_set1_protectionAlgor(CMP_PKIHEADER *hdr, const X509_ALGOR *alg) {
+	if (!hdr) goto err;
+	if (!alg) goto err;
+
+	if (hdr->protectionAlg)
+		X509_ALGOR_free(hdr->protectionAlg);
+
+	if (!(hdr->protectionAlg = X509_ALGOR_dup((X509_ALGOR*)alg))) goto err;
+
+	return 1;
+err:
+	return 0;
+}
+
+/* ############################################################################ */
+/* push an ASN1_UTF8STRING to hdr->freeText and consume the given pointer       */
+/* ############################################################################ */
+int CMP_PKIHEADER_push0_freeText( CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text) {
+	if (!hdr) goto err;
+	if (!text) goto err;
+
+	if (!hdr->freeText)
+		if (!(hdr->freeText = sk_ASN1_UTF8STRING_new_null())) goto err;
+
+	if (!(sk_ASN1_UTF8STRING_push(hdr->freeText, text))) goto err;
+
+	return 1;
+err:
+	return 0;
+}
+
+/* ############################################################################ */
+/* push an ASN1_UTF8STRING to hdr->freeText and don't consume the given pointer */
+/* ############################################################################ */
+int CMP_PKIHEADER_push1_freeText( CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text) {
+	ASN1_UTF8STRING *textDup=NULL;
+
+	if (!hdr) goto err;
+	if (!text) goto err;
+
+	if( !(textDup = ASN1_UTF8STRING_new())) goto err;
+	if( !ASN1_STRING_set( textDup, text->data, text->length)) goto err;
+
+	return CMP_PKIHEADER_push0_freeText( hdr, textDup);
+err:
+	if (textDup) ASN1_UTF8STRING_free(textDup);
+	return 0;
+}
+
+#if 0
+/* ############################################################################ */
+/* set an ASN1_UTF8STRING stack to hdr->freeText and consume the given pointer */
+/* ############################################################################ */
+int CMP_PKIHEADER_set0_freeText( CMP_PKIHEADER *hdr, STACK_OF(ASN1_UTF8STRING) *text) {
+	STACK_OF(ASN1_UTF8STRING) *textDup;
+
+	if (!hdr) goto err;
+	if (!text) goto err;
+
+	if (!hdr->freeText)
+		sk_ASN1_UTF8STRING_free(hdr->freeText);
+
+	hdr->freeText = text;
+
+	return 1;
+err:
+	return 0;
+}
+
+/* ############################################################################ */
+/* set an ASN1_UTF8STRING stack to hdr->freeText and don't consume the given pointer */
+/* ############################################################################ */
+int CMP_PKIHEADER_set1_freeText( CMP_PKIHEADER *hdr, STACK_OF(ASN1_UTF8STRING) *text) {
+	STACK_OF(ASN1_UTF8STRING) *textDup;
+
+	if (!hdr) goto err;
+	if (!text) goto err;
+
+	if (!textDup = sk_ASN1_UTF8STRING_dup(text)) goto err;
+	return CMP_PKIHEADER_set0_freeText( hdr, textDup);
+err:
+	return 0;
+}
+#endif
+
+
+/* ############################################################################ *
+ * Initialize the given PkiHeader structure with values set in the CMP_CTX structure.
+ * if referenceValue is given in ctx, it will be set as senderKID
+ * ############################################################################ */
+int CMP_PKIHEADER_set1(CMP_PKIHEADER *hdr, CMP_CTX *ctx) {
+	/* check existence of mandatory arguments */
+	if( !hdr) goto err;
+	if( !ctx) goto err;
+
+	/* set the CMP version */
+	CMP_PKIHEADER_set_version( hdr, CMP_VERSION);
+
+	/* in case there is no OLD client cert and no subject name is set in ctx,
+	 * the subject name is not set */
+	if( ctx->clCert) {
+		if( !CMP_PKIHEADER_set1_sender( hdr, X509_get_subject_name( (X509*) ctx->clCert))) goto err;
+	} else {
+		if( !CMP_PKIHEADER_set1_sender( hdr, NULL)) goto err;
+	}
+
+	if( ctx->caCert) {
+		if( !CMP_PKIHEADER_set1_recipient( hdr, X509_get_subject_name( (X509*) ctx->caCert))) goto err;
+	} else if( ctx->recipient) {
+		if( !CMP_PKIHEADER_set1_recipient( hdr, ctx->recipient)) goto err;
+	}else {
+		if( !CMP_PKIHEADER_set1_recipient( hdr, NULL)) goto err;
+	}
+
+	if( !CMP_PKIHEADER_set_messageTime(hdr)) goto err;
+
+	if( ctx->protectionAlgor) {
+		if( !CMP_PKIHEADER_set1_protectionAlgor( hdr, ctx->protectionAlgor)) goto err;
+	}
+
+	if( ctx->referenceValue) {
+		if( !CMP_PKIHEADER_set1_senderKID(hdr, ctx->referenceValue)) goto err;
+	}
+
+	/* XXX not setting transactionID test for PKI INFO */
+	if( ctx->setTransactionID == 1) {
+		if( ctx->transactionID) {
+			if( !CMP_PKIHEADER_set1_transactionID(hdr, ctx->transactionID)) goto err;
+		} else {
+			/* create new transaction ID */
+			if( !CMP_PKIHEADER_set1_transactionID(hdr, NULL)) goto err;
+			/* XXX this is not nice, it should be done somehow through the function */
+			CMP_CTX_set1_transactionID( ctx, hdr->transactionID);
+		}
+	}
+
+	/* XXX not setting senderNonce test for PKI INFO */
+	if( ctx->setSenderNonce == 1) {
+		if( !CMP_PKIHEADER_new_senderNonce(hdr)) goto err;
+	}
+	if( ctx->recipNonce)
+		if( !CMP_PKIHEADER_set1_recipNonce(hdr, ctx->recipNonce)) goto err;
+
+#if 0
+	/*
+         freeText        [7] PKIFreeText             OPTIONAL,
+         -- this may be used to indicate context-specific instructions
+         -- (this field is intended for human consumption)
+	 */
+
+	if( ctx->freeText)
+		if( !CMP_PKIHEADER_push1_freeText(hdr, ctx->freeText)) goto err;
+#endif
+
+	return 1;
+err:
+	return 0;
+}
+
+
+/* ############################################################################ */
+/*
+   In the above protectionAlg, the salt value is appended to the shared
+   secret input.  The OWF is then applied iterationCount times, where
+   the salted secret is the input to the first iteration and, for each
+   successive iteration, the input is set to be the output of the
+   previous iteration.  The output of the final iteration (called
+   "BASEKEY" for ease of reference, with a size of "H") is what is used
+   to form the symmetric key.  If the MAC algorithm requires a K-bit key
+   and K <= H, then the most significant K bits of BASEKEY are used.  If
+   K > H, then all of BASEKEY is used for the most significant H bits of
+   the key, OWF("1" || BASEKEY) is used for the next most significant H
+   bits of the key, OWF("2" || BASEKEY) is used for the next most
+   significant H bits of the key, and so on, until all K bits have been
+   derived.  [Here "N" is the ASCII byte encoding the number N and "||"
+   represents concatenation.]
+
+   Note: it is RECOMMENDED that the fields of PBMParameter remain
+   constant throughout the messages of a single transaction (e.g.,
+   ir/ip/certConf/pkiConf) in order to reduce the overhead associated
+   with PasswordBasedMAC computation).
+   */
+
+ASN1_BIT_STRING *CMP_protection_new(CMP_PKIMESSAGE *pkimessage,
+				    X509_ALGOR *_algor,
+				    const EVP_PKEY *pkey,
+				    const ASN1_OCTET_STRING *secret) {
+	ASN1_BIT_STRING *prot=NULL;
+	CMP_PROTECTEDPART protPart;
+	ASN1_STRING *pbmStr=NULL;
+	X509_ALGOR *algor=NULL;
+	ASN1_OBJECT *algorOID=NULL;
+
+	CRMF_PBMPARAMETER *pbm=NULL;
+
+	size_t protPartDerLen;
+	unsigned int macLen;
+	size_t maxMacLen;
+	unsigned char *protPartDer=NULL;
+	unsigned char *mac=NULL;
+	const unsigned char *pbmStrUchar=NULL;
+
+	int pptype=0;
+	void *ppval=NULL;
+
+	int usedAlgorNid;
+
+	EVP_MD_CTX   *ctx=NULL;
+	const EVP_MD *md=NULL;
+
+	protPart.header = pkimessage->header;
+	protPart.body   = pkimessage->body;
+	protPartDerLen  = i2d_CMP_PROTECTEDPART(&protPart, &protPartDer);
+
+	if (_algor) {
+		/* algorithm is given with the arguments */
+		algor = _algor;
+	} else {
+		/* algorithm is taken from the message */
+		algor = pkimessage->header->protectionAlg;
+	}
+
+	X509_ALGOR_get0( &algorOID, &pptype, &ppval, algor);
+	usedAlgorNid = OBJ_obj2nid(algorOID);
+
+	if (usedAlgorNid == NID_id_PasswordBasedMAC) {
+		/* there is no pmb set in this message */
+		if (!ppval) goto err;
+		if (!secret) {
+			CMPerr(CMP_F_CMP_PROTECTION_NEW, CMP_R_NO_SECRET_VALUE_GIVEN_FOR_PBMAC);
+			goto err;
+		}
+
+		pbmStr = (ASN1_STRING *)ppval;
+		pbmStrUchar = (unsigned char *)pbmStr->data;
+		pbm = d2i_CRMF_PBMPARAMETER( NULL, &pbmStrUchar, pbmStr->length);
+
+		if(!(CRMF_passwordBasedMac_new(pbm, protPartDer, protPartDerLen, secret->data, secret->length, &mac, &macLen))) goto err;
+	}
+	else if ((md = EVP_get_digestbynid(usedAlgorNid)) != NULL) {
+		// printf("INFO: protecting with pkey, algorithm %s\n", OBJ_nid2sn(usedAlgorNid));
+		if (!pkey) { /* EVP_SignFinal() will check that pkey type is correct for the algorithm */
+			CMPerr(CMP_F_CMP_PROTECTION_NEW, CMP_R_INVALID_KEY);
+			ERR_add_error_data(1, "pkey was NULL although it is supposed to be used for generating protection");
+			goto err;
+		}
+
+		maxMacLen = EVP_PKEY_size( (EVP_PKEY*) pkey);
+		mac = OPENSSL_malloc(maxMacLen);
+
+		ctx = EVP_MD_CTX_create();
+		if (!(EVP_SignInit_ex(ctx, md, NULL))) goto err;
+		if (!(EVP_SignUpdate(ctx, protPartDer, protPartDerLen))) goto err;
+		if (!(EVP_SignFinal(ctx, mac, &macLen, (EVP_PKEY*) pkey))) goto err;
+	}
+	else {
+		CMPerr(CMP_F_CMP_PROTECTION_NEW, CMP_R_UNKNOWN_ALGORITHM_ID);
+		goto err;
+	}
+
+	if(!(prot = ASN1_BIT_STRING_new())) goto err;
+	ASN1_BIT_STRING_set(prot, mac, macLen);
+
+	/* Actually this should not be needed but OpenSSL defaults all bitstrings to be a NamedBitList */
+	prot->flags &= ~0x07;
+	prot->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+
+	/* cleanup */
+	if (ctx) EVP_MD_CTX_destroy(ctx);
+	if (mac) OPENSSL_free(mac);
+	return prot;
+
+err:
+	if (ctx) EVP_MD_CTX_destroy(ctx);
+	if (mac) OPENSSL_free(mac);
+
+	CMPerr(CMP_F_CMP_PROTECTION_NEW, CMP_R_ERROR_CALCULATING_PROTECTION);
+	if(prot) ASN1_BIT_STRING_free(prot);
+	return NULL;
+}
+
+
+/* ############################################################################ */
+	/*
+        -- the hash of the certificate, using the same hash algorithm
+        -- as is used to create and verify the certificate signature
+	*/
+int CMP_CERTSTATUS_set_certHash( CMP_CERTSTATUS *certStatus, const X509 *cert) {
+	ASN1_OCTET_STRING *certHash=NULL;
+	unsigned int hashLen;
+	unsigned char hash[EVP_MAX_MD_SIZE];
+	int sigAlgID;
+	const EVP_MD *md = NULL;
+
+	if (!certStatus) goto err;
+	if (!cert) goto err;
+
+	sigAlgID = OBJ_obj2nid(cert->sig_alg->algorithm);
+	// printf("INFO: certificate signature algorithm used: \"%s\"\n", OBJ_nid2sn(sigAlgID));
+
+	/* select algorithm based on the one used in the cert signature */
+	if ((md = EVP_get_digestbynid(sigAlgID))) {
+		if (!X509_digest(cert, md, hash, &hashLen)) goto err;
+		certHash=ASN1_OCTET_STRING_new();
+		if (!ASN1_OCTET_STRING_set(certHash, hash, hashLen)) goto err;
+
+		if (certStatus->certHash)
+			ASN1_OCTET_STRING_free(certStatus->certHash);
+		certStatus->certHash = certHash;
+	}
+	else {
+		CMPerr(CMP_F_CMP_CERTSTATUS_SET_CERTHASH, CMP_R_UNSUPPORTED_ALGORITHM);
+		goto err;
+	}
+
+	return 1;
+err:
+	CMPerr(CMP_F_CMP_CERTSTATUS_SET_CERTHASH, CMP_R_ERROR_SETTING_CERTHASH);
+	if( certHash) ASN1_OCTET_STRING_free(certHash);
+	return 0;
+}
+
+
+/* ############################################################################ */
+/* sets implicitConfirm in the generalInfo field of the header
+ * returns 1 on success, 0 on error
+ * ############################################################################ */
+int CMP_PKIMESSAGE_set_implicitConfirm(CMP_PKIMESSAGE *msg) {
+	CMP_INFOTYPEANDVALUE *itav=NULL;
+
+	if (!msg) goto err;
+
+	itav = CMP_INFOTYPEANDVALUE_new();
+	itav->infoType = OBJ_nid2obj(NID_id_it_implicitConfirm);
+	itav->infoValue.implicitConfirm = ASN1_NULL_new();
+	// if (! CMP_INFOTYPEANDVALUE_set0( itav, OBJ_nid2obj(NID_id_it_implicitConfirm), V_ASN1_NULL, NULL)) goto err;
+	if (! CMP_PKIHEADER_generalInfo_item_push0( msg->header, itav)) goto err;
+	return 1;
+err:
+	if (itav) CMP_INFOTYPEANDVALUE_free(itav);
+	return 0;
+}
+
+/* ############################################################################
+ * checks if implicitConfirm in the generalInfo field of the header is set
+ * returns 1 if it is set, 0 if not
+ * ############################################################################ */
+int CMP_PKIMESSAGE_check_implicitConfirm(CMP_PKIMESSAGE *msg) {
+	int itavCount;
+	int i;
+	CMP_INFOTYPEANDVALUE *itav=NULL;
+
+
+	if (!msg) return 0;
+
+	itavCount = sk_CMP_INFOTYPEANDVALUE_num(msg->header->generalInfo);
+
+	for( i=0; i < itavCount; i++) {
+		itav = sk_CMP_INFOTYPEANDVALUE_value(msg->header->generalInfo,i);
+		if (OBJ_obj2nid(itav->infoType) == NID_id_it_implicitConfirm)
+			return 1;
+	}
+
+	/* not found */
+	return 0;
+}
+
+
+/* ############################################################################ */
+/* ############################################################################ */
+int CMP_PKIHEADER_generalInfo_item_push0(CMP_PKIHEADER *hdr, const CMP_INFOTYPEANDVALUE *itav) {
+	if( !hdr)
+		return 0;
+#if 0
+	/* this is allowed and will just make sure the stack is created */
+	if( !itav)
+		return 0;
+#endif
+
+	if( !CMP_ITAV_stack_item_push0(&hdr->generalInfo, itav))
+		goto err;
+	return 1;
+err:
+	return 0;
+}
+
+/* ############################################################################ */
+/* ############################################################################ */
+int CMP_PKIMESSAGE_genm_item_push0(CMP_PKIMESSAGE *msg, const CMP_INFOTYPEANDVALUE *itav) {
+	if( !msg)
+		return 0;
+#if 0
+	/* this is allowed and will just make sure the stack is created */
+	if( !itav)
+		return 0;
+#endif
+
+	if( !CMP_ITAV_stack_item_push0( &msg->body->value.genm, itav))
+		goto err;
+	return 1;
+err:
+	return 0;
+}
+
+/* ############################################################################ */
+/* @itav: a pointer to the infoTypeAndValue item to push on the stack. */
+/*        If NULL it will be only made sure the stack exists */
+/* ############################################################################ */
+int CMP_ITAV_stack_item_push0(STACK_OF(CMP_INFOTYPEANDVALUE) **itav_sk_p, const CMP_INFOTYPEANDVALUE *itav) {
+	int created = 0;
+
+	if( !itav_sk_p)
+		return 0;
+#if 0
+	/* this is allowed and will just make sure the stack is created */
+	if( !itav)
+		return 0;
+#endif
+
+	if( !*itav_sk_p) {
+		/* not yet created */
+		if (!(*itav_sk_p = sk_CMP_INFOTYPEANDVALUE_new_null()))
+			goto err;
+		created= 1;
+	}
+	if( itav) {
+		if( !sk_CMP_INFOTYPEANDVALUE_push(*itav_sk_p, itav)) goto err;
+	}
+	return 1;
+err:
+	if( created) {
+		sk_CMP_INFOTYPEANDVALUE_pop_free(*itav_sk_p, CMP_INFOTYPEANDVALUE_free);
+		*itav_sk_p = NULL;
+	}
+	return 0;
+}
+
+/* ############################################################################ */
+/* returns the PKIStatus of the given PKIStatusInfo */
+/* returns -1 on error */
+/* ############################################################################ */
+long CMP_PKISTATUSINFO_PKIstatus_get( CMP_PKISTATUSINFO *statusInfo) {
+	if (!statusInfo) return -1;
+	return ASN1_INTEGER_get(statusInfo->status);
+}
+
+/* ############################################################################ */
+/* returns the PKIStatus of the given ErrorMessage */
+/* returns -1 on error */
+/* ############################################################################ */
+long CMP_ERRORMSGCONTENT_PKIStatus_get( CMP_ERRORMSGCONTENT *error) {
+	if (!error) return -1;
+	return CMP_PKISTATUSINFO_PKIstatus_get(error->pKIStatusInfo);
+}
+
+/* ############################################################################ */
+/* returns the PKIStatus of the given PKIStatusInfo */
+/* or NULL on error */
+/* ############################################################################ */
+char *CMP_PKISTATUSINFO_PKIstatus_get_string( CMP_PKISTATUSINFO *statusInfo) {
+	long PKIstatus;
+
+	if (!statusInfo) return 0;
+
+	PKIstatus = CMP_PKISTATUSINFO_PKIstatus_get(statusInfo);
+	switch (PKIstatus) {
+		case CMP_PKISTATUS_accepted:
+			return "PKIStatus: accepted";
+		case CMP_PKISTATUS_grantedWithMods:
+			return "PKIStatus: granded with mods";
+		case CMP_PKISTATUS_rejection:
+			return "PKIStatus: rejection";
+		case CMP_PKISTATUS_waiting:
+			return "PKIStatus: waiting";
+		case CMP_PKISTATUS_revocationWarning:
+			return "PKIStatus: revocation warning";
+		case CMP_PKISTATUS_revocationNotification:
+			return "PKIStatus: revocation notification";
+		case CMP_PKISTATUS_keyUpdateWarning:
+			return "PKIStatus: key update warning";
+		case -1:
+		default:
+			CMPerr(CMP_F_CMP_PKISTATUSINFO_PKISTATUS_GET_STRING, CMP_R_ERROR_PARSING_PKISTATUS);
+			return 0;
+	}
+	return 0;
+}
+
+/* ############################################################################ */
+/* returns the PKIStatus info of the given error message */
+/* returns 0 on error */
+/* ############################################################################ */
+char *CMP_ERRORMSGCONTENT_PKIStatus_get_string( CMP_ERRORMSGCONTENT *error) {
+	if (!error) return 0;
+	return CMP_PKISTATUSINFO_PKIstatus_get_string(error->pKIStatusInfo);
+}
+
+/* ############################################################################ */
+/* returns the PKIStatus of the given Certresponse */
+/* returns -1 on error */
+/* ############################################################################ */
+long CMP_CERTRESPONSE_PKIStatus_get( CMP_CERTRESPONSE *resp) {
+	if (!resp) return -1;
+	return CMP_PKISTATUSINFO_PKIstatus_get(resp->status);
+}
+
+STACK_OF(ASN1_UTF8STRING)* CMP_CERTRESPONSE_PKIStatusString_get0( CMP_CERTRESPONSE *resp) {
+	if (!resp) return NULL;
+	return resp->status->statusString;
+}
+
+/* ############################################################################ */
+/* returns the PKIFailureInfo */
+/* returns 0 on error */
+/* ############################################################################ */
+char *CMP_PKISTATUSINFO_PKIFailureInfo_get_string( CMP_PKISTATUSINFO *statusInfo) {
+	int i;
+
+	if (!statusInfo) return 0;
+	for ( i=0; i <= CMP_PKIFAILUREINFO_MAX; i++) {
+		if( ASN1_BIT_STRING_get_bit(statusInfo->failInfo, i)) {
+			switch (i) {
+				case CMP_PKIFAILUREINFO_badAlg:
+					return "PKIFailureInfo: badAlg";
+				case CMP_PKIFAILUREINFO_badMessageCheck:
+					return "PKIFailureInfo: badMessageCheck";
+				case CMP_PKIFAILUREINFO_badRequest:
+					return "PKIFailureInfo: badRequest";
+				case CMP_PKIFAILUREINFO_badTime:
+					return "PKIFailureInfo: badTime";
+				case CMP_PKIFAILUREINFO_badCertId:
+					return "PKIFailureInfo: badCertId";
+				case CMP_PKIFAILUREINFO_badDataFormat:
+					return "PKIFailureInfo: badDataFormat";
+				case CMP_PKIFAILUREINFO_wrongAuthority:
+					return "PKIFailureInfo: wrongAuthority";
+				case CMP_PKIFAILUREINFO_incorrectData:
+					return "PKIFailureInfo: incorrectData";
+				case CMP_PKIFAILUREINFO_missingTimeStamp:
+					return "PKIFailureInfo: missingTimeStamp";
+				case CMP_PKIFAILUREINFO_badPOP:
+					return "PKIFailureInfo: badPOP";
+				case CMP_PKIFAILUREINFO_certRevoked:
+					return "PKIFailureInfo: certRevoked";
+				case CMP_PKIFAILUREINFO_certConfirmed:
+					return "PKIFailureInfo: certConfirmed";
+				case CMP_PKIFAILUREINFO_wrongIntegrity:
+					return "PKIFailureInfo: wrongIntegrity";
+				case CMP_PKIFAILUREINFO_badRecipientNonce:
+					return "PKIFailureInfo: badRecipientNonce";
+				case CMP_PKIFAILUREINFO_timeNotAvailable:
+					return "PKIFailureInfo: timeNotAvailable";
+				case CMP_PKIFAILUREINFO_unacceptedPolicy:
+					return "PKIFailureInfo: unacceptedPolicy";
+				case CMP_PKIFAILUREINFO_unacceptedExtension:
+					return "PKIFailureInfo: unacceptedExtension";
+				case CMP_PKIFAILUREINFO_addInfoNotAvailable:
+					return "PKIFailureInfo: addInfoNotAvailable";
+				case CMP_PKIFAILUREINFO_badSenderNonce:
+					return "PKIFailureInfo: badSenderNonce";
+				case CMP_PKIFAILUREINFO_badCertTemplate:
+					return "PKIFailureInfo: badCertTemplate";
+				case CMP_PKIFAILUREINFO_signerNotTrusted:
+					return "PKIFailureInfo: signerNotTrusted";
+				case CMP_PKIFAILUREINFO_transactionIdInUse:
+					return "PKIFailureInfo: transactionIdInUse";
+				case CMP_PKIFAILUREINFO_unsupportedVersion:
+					return "PKIFailureInfo: unsupportedVersion";
+				case CMP_PKIFAILUREINFO_notAuthorized:
+					return "PKIFailureInfo: notAuthorized";
+				case CMP_PKIFAILUREINFO_systemUnavail:
+					return "PKIFailureInfo: systemUnavail";
+				case CMP_PKIFAILUREINFO_systemFailure:
+					return "PKIFailureInfo: systemFailure";
+				case CMP_PKIFAILUREINFO_duplicateCertReq:
+					return "PKIFailureInfo: duplicateCertReq";
+			}
+		}
+	}
+	return 0;
+}
+
+/* ############################################################################ */
+/* returns the PKIFailureInfo # of the given ErrorMessage */
+/* returns 1 on success */
+/* returns 0 on error */
+/* ############################################################################ */
+char *CMP_ERRORMSGCONTENT_PKIFailureInfo_get_string( CMP_ERRORMSGCONTENT *error) {
+	if (!error) return 0;
+	return CMP_PKISTATUSINFO_PKIFailureInfo_get_string(error->pKIStatusInfo);
+}
+
+/* ############################################################################ */
+/* returns the PKIStatus of the given certReqId inside a Rev */
+/* returns -1 on error */
+/* ############################################################################ */
+long CMP_REVREP_PKIStatus_get( CMP_REVREP *revRep, long reqId) {
+	CMP_PKISTATUSINFO *status=NULL;
+	if (!revRep) return -1;
+
+	if ( (status = sk_CMP_PKISTATUSINFO_value( revRep->status, reqId)) ) {
+		return CMP_PKISTATUSINFO_PKIstatus_get(status);
+	}
+
+	/* did not find a CertResponse with the right certRep */
+	return -1;
+}
+
+/* ############################################################################ */
+/* returns the PKIStatus of the given certReqId inside a CertRepMessage */
+/* returns -1 on error */
+/* ############################################################################ */
+long CMP_CERTREPMESSAGE_PKIStatus_get( CMP_CERTREPMESSAGE *certRep, long certReqId) {
+	CMP_CERTRESPONSE *certResponse=NULL;
+	if (!certRep) return -1;
+
+	if ( (certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) ) {
+		return (CMP_CERTRESPONSE_PKIStatus_get(certResponse));
+	}
+
+	/* did not find a CertResponse with the right certRep */
+	return -1;
+}
+
+CMP_PKIFAILUREINFO *CMP_CERTREPMESSAGE_PKIFailureInfo_get0(CMP_CERTREPMESSAGE *certRep, long certReqId) {
+	CMP_CERTRESPONSE *certResponse=NULL;
+	if (!certRep) return NULL;
+
+	if ( (certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) ) {
+
+		if (certResponse->status)
+			return certResponse->status->failInfo;
+	}
+
+	/* did not find a CertResponse with the right certRep */
+	return NULL;
+}
+
+char *CMP_CERTREPMESSAGE_PKIFailureInfoString_get0(CMP_CERTREPMESSAGE *certRep, long certReqId) {
+	CMP_CERTRESPONSE *certResponse=NULL;
+	if (!certRep) return NULL;
+
+	if ( (certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) ) {
+
+		if (certResponse->status)
+			return CMP_PKISTATUSINFO_PKIFailureInfo_get_string(certResponse->status);
+	}
+
+	/* did not find a CertResponse with the right certRep */
+	return NULL;
+}
+
+/* ############################################################################ */
+/* returns the status string of the given certReqId inside a CertRepMessage */
+/* returns NULL on error */
+/* ############################################################################ */
+STACK_OF(ASN1_UTF8STRING)* CMP_CERTREPMESSAGE_PKIStatusString_get0( CMP_CERTREPMESSAGE *certRep, long certReqId) {
+	CMP_CERTRESPONSE *certResponse=NULL;
+	if (!certRep) return NULL;
+
+	if ( (certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) ) {
+		return (CMP_CERTRESPONSE_PKIStatusString_get0(certResponse));
+	}
+
+	/* did not find a CertResponse with the right certRep */
+	return NULL;
+}
+
+/* ############################################################################ */
+/* returns 1 if a given bit is set in a PKIFailureInfo */
+/*              0 if            not set */
+/*             -1 on error */
+/* PKIFailureInfo ::= ASN1_BIT_STRING */
+/* ############################################################################ */
+int CMP_PKIFAILUREINFO_check( ASN1_BIT_STRING *failInfo, int codeBit) {
+	if (!failInfo) return -1;
+	if ( (codeBit < 0) || (codeBit > CMP_PKIFAILUREINFO_MAX)) return -1;
+
+	return ASN1_BIT_STRING_get_bit( failInfo, codeBit);
+}
+
+
+/* ############################################################################ */
+/* returns a pointer to the CertResponse with the given certReqId inside a CertRepMessage */
+/* returns NULL on error or if no CertResponse available */
+/* ############################################################################ */
+CMP_CERTRESPONSE *CMP_CERTREPMESSAGE_certResponse_get0( CMP_CERTREPMESSAGE *certRep, long certReqId) {
+	CMP_CERTRESPONSE *certResponse=NULL;
+	int certRespCount;
+	int i;
+
+	if( !certRep) return NULL;
+
+	certRespCount = sk_CMP_CERTRESPONSE_num( certRep->response);
+
+	for( i=0; i < certRespCount; i++) {
+		/* is it the right certReqId */
+		if( certReqId == ASN1_INTEGER_get(sk_CMP_CERTRESPONSE_value(certRep->response,i)->certReqId) ) {
+			certResponse = sk_CMP_CERTRESPONSE_value(certRep->response,i);
+			break;
+		}
+	}
+
+	return certResponse;
+}
+
+
+
+/* ############################################################################ */
+/* returns a pointer to the Certificate with the given certReqId inside a CertRepMessage */
+/* returns NULL on error or if no Certificate available */
+/* ############################################################################ */
+X509 *CMP_CERTREPMESSAGE_cert_get0( CMP_CERTREPMESSAGE *certRep, long certReqId) {
+	X509 *cert=NULL;
+	CMP_CERTRESPONSE *certResponse=NULL;
+
+	if( !certRep) return NULL;
+
+	if ( (certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) ) {
+		cert = certResponse->certifiedKeyPair->certOrEncCert->value.certificate;
+	}
+
+	return cert;
+}
+
+/* ############################################################################ */
+/* returns a pointer to a copy of the Certificate with the given certReqId inside a CertRepMessage */
+/* returns NULL on error or if no Certificate available */
+/* ############################################################################ */
+X509 *CMP_CERTREPMESSAGE_cert_get1( CMP_CERTREPMESSAGE *certRep, long certReqId) {
+	X509 *cert=NULL;
+	X509 *certCopy=NULL;
+
+	if( !certRep) return NULL;
+
+	if( (cert = CMP_CERTREPMESSAGE_cert_get0(certRep, certReqId)))
+		certCopy = X509_dup(cert);
+	return certCopy;
+}
+
+/* ############################################################################# */
+/* Decrypts the certificate with the given certReqId inside a CertRepMessage and */
+/* returns a pointer to the decrypted certificate                                */
+/* returns NULL on error or if no Certificate available                          */
+/* ############################################################################# */
+X509 *CMP_CERTREPMESSAGE_encCert_get1( CMP_CERTREPMESSAGE *certRep, long certReqId, EVP_PKEY *pkey) {
+	CRMF_ENCRYPTEDVALUE *encCert   = NULL;
+	X509                *cert      = NULL; /* decrypted certificate                   */
+	EVP_CIPHER_CTX      *ctx       = NULL; /* context for symmetric encryption        */
+	unsigned char       *ek        = NULL; /* decrypted symmetric encryption key      */
+	const EVP_CIPHER    *cipher    = NULL; /* used cipher                             */
+	unsigned char       *iv        = NULL; /* initial vector for symmetric encryption */
+	unsigned char       *outbuf    = NULL; /* decryption output buffer                */
+	const unsigned char *p         = NULL; /* needed for decoding ASN1                */
+	int                  symmAlg;  /* NIDs for key and symmetric algorithm    */
+	int                  n, outlen = 0;
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L 
+	EVP_PKEY_CTX        *pkctx     = NULL;   /* private key context */
+#endif
+
+	// printf("INFO: Received encrypted certificate, attempting to decrypt... \n");
+
+	CMP_CERTRESPONSE *certResponse = NULL;
+	if ( !(certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) )
+		goto err;
+
+	encCert = certResponse->certifiedKeyPair->certOrEncCert->value.encryptedCert;
+
+	/* keyAlg  = OBJ_obj2nid(encCert->keyAlg->algorithm); */
+	symmAlg = OBJ_obj2nid(encCert->symmAlg->algorithm);
+
+	/* first the symmetric key needs to be decrypted */
+
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L 
+	if ((pkctx = EVP_PKEY_CTX_new(pkey, NULL)) && EVP_PKEY_decrypt_init(pkctx)) {
+		ASN1_BIT_STRING *encKey = encCert->encSymmKey;
+
+		size_t eksize = 0;
+		if (EVP_PKEY_decrypt(pkctx, NULL, &eksize, encKey->data, encKey->length) <= 0
+				|| !(ek = OPENSSL_malloc(eksize))
+				|| EVP_PKEY_decrypt(pkctx, ek, &eksize, encKey->data, encKey->length) <= 0) {
+
+			CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_ERROR_DECRYPTING_SYMMETRIC_KEY);
+			goto err;
+		}
+		EVP_PKEY_CTX_free(pkctx);
+	}
+	else {
+		CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_ERROR_DECRYPTING_KEY);
+		goto err;
+	}
+#else
+    ASN1_BIT_STRING *encKey = encCert->encSymmKey;
+    ek = OPENSSL_malloc(encKey->length);
+    if (EVP_PKEY_decrypt(ek, encKey->data, encKey->length, pkey) == -1) {
+		CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_ERROR_DECRYPTING_KEY);
+		goto err;
+	}
+#endif
+
+	/* select cipher based on algorithm given in message */
+	if (!(cipher = EVP_get_cipherbynid(symmAlg))) {
+		CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_UNKNOWN_CIPHER);
+		goto err;
+	}
+	if (!(iv = OPENSSL_malloc(cipher->iv_len))) goto err;
+	ASN1_TYPE_get_octetstring(encCert->symmAlg->parameter, iv, cipher->iv_len);
+
+	/* d2i_X509 changes the given pointer, so use p for decoding the message and keep the 
+	 * original pointer in outbuf so that the memory can be freed later */
+	if (!(p = outbuf = OPENSSL_malloc(encCert->encValue->length + cipher->block_size - 1))) goto err;
+	ctx = EVP_CIPHER_CTX_new();
+	EVP_CIPHER_CTX_set_padding(ctx, 0);
+
+	if (!EVP_DecryptInit(ctx, cipher, ek, iv)
+			|| !EVP_DecryptUpdate(ctx, outbuf, &outlen, encCert->encValue->data, encCert->encValue->length)
+			|| !EVP_DecryptFinal(ctx, outbuf+outlen, &n)) {
+		CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_ERROR_DECRYPTING_CERTIFICATE);
+		goto err;
+	}
+	outlen += n;
+
+	if (!(cert = d2i_X509(NULL, &p, outlen))) {
+		CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_ERROR_DECODING_CERTIFICATE);
+		goto err;
+	}
+
+	OPENSSL_free(outbuf);
+	EVP_CIPHER_CTX_free(ctx);
+	OPENSSL_free(ek);
+	OPENSSL_free(iv);
+	return cert;
+
+err:
+	CMPerr(CMP_F_CMP_CERTREPMESSAGE_ENCCERT_GET1, CMP_R_ERROR_DECRYPTING_ENCCERT);
+	if (outbuf) OPENSSL_free(outbuf);
+	if (ctx) EVP_CIPHER_CTX_free(ctx);
+	if (ek) OPENSSL_free(ek);
+	if (iv) OPENSSL_free(iv);
+	return NULL;
+}
+
+/* ############################################################################ */
+/* returns the type of the certificate contained in the certificate response    */
+/* returns -1 on errror                                                         */
+/* ############################################################################ */
+int CMP_CERTREPMESSAGE_certType_get( CMP_CERTREPMESSAGE *certRep, long certReqId) {
+	CMP_CERTRESPONSE *certResponse=NULL;
+
+	if( !certRep) return -1;
+	if( !(certResponse = CMP_CERTREPMESSAGE_certResponse_get0( certRep, certReqId)) )
+		return -1;
+
+	return certResponse->certifiedKeyPair->certOrEncCert->type;
+}
+
+/* ############################################################################ */
+/* returns 1 on success */
+/* returns 0 on error */
+/* ############################################################################ */
+int CMP_PKIMESSAGE_set_bodytype( CMP_PKIMESSAGE *msg, int type) {
+	if( !msg) return 0;
+
+	msg->body->type = type;
+
+	return 1;
+}
+
+/* ############################################################################ */
+/* returns the body type of the given CMP message */
+/* returns -1 on error */
+/* ############################################################################ */
+int CMP_PKIMESSAGE_get_bodytype( CMP_PKIMESSAGE *msg) {
+	if( !msg) return -1;
+
+	return msg->body->type;
+}
+
+/* ############################################################################ */
+/* return error message string or NULL on error */
+/* ############################################################################ */
+char *CMP_PKIMESSAGE_parse_error_msg( CMP_PKIMESSAGE *msg, char *errormsg, int bufsize) {
+	char *status, *failureinfo;
+
+	if( !msg) return 0;
+	if( CMP_PKIMESSAGE_get_bodytype(msg) != V_CMP_PKIBODY_ERROR) return 0;
+
+	status = CMP_ERRORMSGCONTENT_PKIStatus_get_string(msg->body->value.error);
+	if (!status) {
+		BIO_snprintf(errormsg, bufsize, "failed to parse error message");
+		return errormsg;
+	}
+
+	/* PKIFailureInfo is optional */
+	failureinfo = CMP_ERRORMSGCONTENT_PKIFailureInfo_get_string(msg->body->value.error);
+
+	if (failureinfo)
+		BIO_snprintf(errormsg, bufsize, "Status: %s, Failureinfo: %s", status, failureinfo);
+	else
+		BIO_snprintf(errormsg, bufsize, "Status: %s", status);
+
+	return errormsg;
+}
+
Index: openssl-1.0.0i-cmp/crypto/cmp/CMP_lib.pod
===================================================================
--- openssl-1.0.0i-cmp/crypto/cmp/CMP_lib.pod	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/cmp/CMP_lib.pod	(revision 469)
@@ -0,0 +1,256 @@
+=pod
+
+=head1 NAME
+
+  CMP_CERTREPMESSAGE_PKIStatus_get,
+  CMP_CERTREPMESSAGE_certResponse_get0,
+  CMP_CERTREPMESSAGE_certType_get,
+  CMP_CERTREPMESSAGE_cert_get0,
+  CMP_CERTREPMESSAGE_cert_get1,
+  CMP_CERTREPMESSAGE_encCert_get1,
+  CMP_CERTRESPONSE_PKIStatus_get,
+  CMP_CERTSTATUS_set_certHash,
+  CMP_ERRORMSGCONTENT_PKIFailureInfo_get_string,
+  CMP_ERRORMSGCONTENT_PKIStatus_get,
+  CMP_ERRORMSGCONTENT_PKIStatus_get_string,
+  CMP_PKIFAILUREINFO_check,
+  CMP_PKIHEADER_generalInfo_item_push0,
+  CMP_PKIHEADER_new_senderNonce,
+  CMP_PKIHEADER_push0_freeText,
+  CMP_PKIHEADER_push1_freeText,
+  CMP_PKIHEADER_set0_recipient,
+  CMP_PKIHEADER_set0_sender,
+  CMP_PKIHEADER_set1,
+  CMP_PKIHEADER_set1_protectionAlgor,
+  CMP_PKIHEADER_set1_recipNonce,
+  CMP_PKIHEADER_set1_recipient,
+  CMP_PKIHEADER_set1_sender,
+  CMP_PKIHEADER_set1_senderKID,
+  CMP_PKIHEADER_set1_transactionID,
+  CMP_PKIHEADER_set_messageTime,
+  CMP_PKIHEADER_set_version,
+  CMP_PKIMESSAGE_check_implicitConfirm,
+  CMP_PKIMESSAGE_genm_item_push0,
+  CMP_PKIMESSAGE_get_bodytype,
+  CMP_PKIMESSAGE_parse_error_msg,
+  CMP_PKIMESSAGE_set_bodytype,
+  CMP_PKIMESSAGE_set_implicitConfirm,
+  CMP_PKISTATUSINFO_PKIFailureInfo_get_string,
+  CMP_PKISTATUSINFO_PKIstatus_get,
+  CMP_PKISTATUSINFO_PKIstatus_get_string,
+  CMP_get_protectionAlgor_by_nid,
+  CMP_get_protectionAlgor_pbmac,
+  CMP_protection_new,
+  CMP_CERTREPMESSAGE_PKIStatusString_get0,
+  CMP_CERTRESPONSE_PKIStatusString_get0,
+  CMP_ITAV_stack_item_push0
+
+=head1 SYNOPSIS
+
+  #include <openssl/cmp.h>
+
+  long CMP_CERTREPMESSAGE_PKIStatus_get( CMP_CERTREPMESSAGE *certRep, long certReqId);
+  CMP_CERTRESPONSE *CMP_CERTREPMESSAGE_certResponse_get0( CMP_CERTREPMESSAGE *certRep, long certReqId);
+  int CMP_CERTREPMESSAGE_certType_get( CMP_CERTREPMESSAGE *certRep, long certReqId);
+  X509 *CMP_CERTREPMESSAGE_cert_get0( CMP_CERTREPMESSAGE *certRep, long certReqId);
+  X509 *CMP_CERTREPMESSAGE_cert_get1( CMP_CERTREPMESSAGE *certRep, long certReqId);
+  X509 *CMP_CERTREPMESSAGE_encCert_get1( CMP_CERTREPMESSAGE *certRep, long certReqId, EVP_PKEY *pkey);
+  long CMP_CERTRESPONSE_PKIStatus_get( CMP_CERTRESPONSE *resp);
+  int CMP_CERTSTATUS_set_certHash( CMP_CERTSTATUS *certStatus, const X509 *cert);
+  char *CMP_ERRORMSGCONTENT_PKIFailureInfo_get_string( CMP_ERRORMSGCONTENT *error);
+  long CMP_ERRORMSGCONTENT_PKIStatus_get( CMP_ERRORMSGCONTENT *error);
+  char *CMP_ERRORMSGCONTENT_PKIStatus_get_string( CMP_ERRORMSGCONTENT *error);
+  int CMP_PKIFAILUREINFO_check( ASN1_BIT_STRING *failInfo, int codeBit);
+  int CMP_PKIHEADER_generalInfo_item_push0(CMP_PKIHEADER *hdr, const CMP_INFOTYPEANDVALUE *itav);
+  int CMP_PKIHEADER_new_senderNonce(CMP_PKIHEADER *hdr);
+  int CMP_PKIHEADER_push0_freeText( CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text);
+  int CMP_PKIHEADER_push1_freeText( CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text);
+  int CMP_PKIHEADER_set0_recipient(CMP_PKIHEADER *hdr, const X509_NAME *nm);
+  int CMP_PKIHEADER_set0_sender(CMP_PKIHEADER *hdr, const X509_NAME *nm);
+  int CMP_PKIHEADER_set1(CMP_PKIHEADER *hdr, CMP_CTX *ctx);
+  int CMP_PKIHEADER_set1_protectionAlgor(CMP_PKIHEADER *hdr, const X509_ALGOR *alg);
+  int CMP_PKIHEADER_set1_recipNonce(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *recipNonce);
+  int CMP_PKIHEADER_set1_recipient(CMP_PKIHEADER *hdr, const X509_NAME *nm);
+  int CMP_PKIHEADER_set1_sender(CMP_PKIHEADER *hdr, const X509_NAME *nm);
+  int CMP_PKIHEADER_set1_senderKID(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *senderKID);
+  int CMP_PKIHEADER_set1_transactionID(CMP_PKIHEADER *hdr, const ASN1_OCTET_STRING *transactionID);
+  int CMP_PKIHEADER_set_version(CMP_PKIHEADER *hdr, int version);
+  int CMP_PKIMESSAGE_check_implicitConfirm(CMP_PKIMESSAGE *msg);
+  int CMP_PKIMESSAGE_genm_item_push0(CMP_PKIMESSAGE *msg, const CMP_INFOTYPEANDVALUE *itav);
+  int CMP_PKIMESSAGE_get_bodytype( CMP_PKIMESSAGE *msg);
+  char *CMP_PKIMESSAGE_parse_error_msg( CMP_PKIMESSAGE *msg, char *errormsg, int bufsize);
+  int CMP_PKIMESSAGE_set_bodytype( CMP_PKIMESSAGE *msg, int type);
+  int CMP_PKIMESSAGE_set_implicitConfirm(CMP_PKIMESSAGE *msg);
+  char *CMP_PKISTATUSINFO_PKIFailureInfo_get_string( CMP_PKISTATUSINFO *statusInfo);
+  long CMP_PKISTATUSINFO_PKIstatus_get( CMP_PKISTATUSINFO *statusInfo);
+  char *CMP_PKISTATUSINFO_PKIstatus_get_string( CMP_PKISTATUSINFO *statusInfo);
+  X509_ALGOR *CMP_get_protectionAlgor_by_nid(int nid);
+  X509_ALGOR *CMP_get_protectionAlgor_pbmac();
+  ASN1_BIT_STRING *CMP_protection_new(CMP_PKIMESSAGE *pkimessage, X509_ALGOR *_algor, const EVP_PKEY *pkey, const ASN1_OCTET_STRING *secret);
+  STACK_OF(ASN1_UTF8STRING)* CMP_CERTREPMESSAGE_PKIStatusString_get0( CMP_CERTREPMESSAGE *certRep, long certReqId);
+  STACK_OF(ASN1_UTF8STRING)* CMP_CERTRESPONSE_PKIStatusString_get0( CMP_CERTRESPONSE *resp);
+  int CMP_ITAV_stack_item_push0(STACK_OF(CMP_INFOTYPEANDVALUE) **itav_sk_p, const CMP_INFOTYPEANDVALUE *itav);
+
+=head1 DESCRIPTION
+
+CMP_CERTREPMESSAGE_PKIStatus_get() returns the PKIStatus of the given
+certReqId inside a CertRepMessage, or -1 on error.
+
+CMP_CERTREPMESSAGE_certResponse_get0() returns a pointer to the
+CertResponse with the given certReqId inside a CertRepMessage. If no
+CertResponse is available or if there's an error, the function returns
+NULL.
+
+CMP_CERTREPMESSAGE_certType_get() returns the type of the certificate
+contained in the certificate response, or -1 on error.
+
+CMP_CERTREPMESSAGE_cert_get0() returns a pointer to the Certificate with
+the given certReqId inside a CertRepMessage. If no certificate is
+available or if there is an error, the function returns NULL.
+
+CMP_CERTREPMESSAGE_cert_get1() does the same as above, except it returns
+a pointer to a copy of the certificate instead of the original.
+
+CMP_CERTREPMESSAGE_encCert_get1() decrypts the certificate with the
+given certReqId inside a CertRepMessage and returns a pointer to the
+decrypted certificate. Returns NULL on error or if no Certificate
+available.
+
+CMP_CERTRESPONSE_PKIStatus_get() returns the PKIStatus of the given
+CertResponse, or -1 on error.
+
+CMP_CERTSTATUS_set_certHash() calculates a hash of the certificate,
+using the same hash algorithm as is used to create and verify the
+certificate signature, and places the has into the certHash field of a
+CMP_CERTSTATUS structure. This is used in the certConf message, for
+example, to confirm that the certificate was received successfully.
+
+CMP_ERRORMSGCONTENT_PKIFailureInfo_get_string() returns the failure info
+from the given error message.
+
+CMP_ERRORMSGCONTENT_PKIStatus_get() returns the PKIStatus value of the
+given error message.
+
+CMP_ERRORMSGCONTENT_PKIStatus_get_string() returns the PKIStatus info of
+the given error message.
+
+CMP_PKIFAILUREINFO_check() checks whether a given bit is set within a
+given PKIFailureInfo.
+
+CMP_PKIHEADER_generalInfo_item_push0() adds the given InfoTypeAndValue
+item to the hdr->generalInfo stack.
+
+CMP_PKIHEADER_new_senderNonce() generates a random value for the
+hdr->senderNonce field, which is used to proetct the PKIMessage against
+replay attacks.
+
+CMP_PKIHEADER_push0_freeText() pushes an ASN1_UTF8STRING to
+hdr->freeText and consume the given pointer.
+
+CMP_PKIHEADER_push1_freeText() does the same as above, but does not
+consume the pointer.
+
+CMP_PKIHEADER_set0_recipient() sets the recipient field in the given
+PKIHeader to the given X509 name.
+
+CMP_PKIHEADER_set0_sender() sets the sender field in the given PKIHeader
+structure.
+
+CMP_PKIHEADER_set1() initializes a PKIHeader structure based on the
+values in the given CMP_CTX structure.
+
+CMP_PKIHEADER_set1_protectionAlgor() sets hdr->protectionAlg to the
+given X509_ALGOR. This field specifies the algorithm that will be used
+to calculate the value of the protection field in a PKIMessage.
+
+CMP_PKIHEADER_set1_recipNonce() sets the recpiNonce field in the given
+hdr to the given value.
+
+CMP_PKIHEADER_set1_recipient() sets the recipient field in the given
+PKIHeader to the given X509 Name value, without consuming the pointer.
+
+CMP_PKIHEADER_set1_sender() sets the sender field in the given PKIHeader
+to the given X509 Name value, without consuming the pointer.
+
+CMP_PKIHEADER_set1_senderKID() Sets hdr->senderKID to the given
+string. In IR this is the reference number issued by the CA. In KUR with
+Insta or Cryptlib compatibility mode, this is set to the public key ID
+from the previously issued certificate.
+
+CMP_PKIHEADER_set1_transactionID() copies the given transactionID to
+hdr->transactionID. If the transactionID parameter is NULL, a new random
+value is generated for it.
+
+CMP_PKIHEADER_set_version() sets hdr->pvno to the given integer.
+
+CMP_PKIMESSAGE_check_implicitConfirm() returns 1 if implicitConfirm is
+set in the given PKIMessage, 0 if not.
+
+CMP_PKIMESSAGE_genm_item_push0() pushes an InfoTypeAndValue item to the
+stack of general messages (GenMsg).
+
+CMP_PKIMESSAGE_get_bodytype() returns the body type of the given
+PKIMessage.
+
+CMP_PKIMESSAGE_parse_error_msg() reads the error messages from the given
+PKIMessage, and prints out the results in the given errormsg buffer.
+
+CMP_PKIMESSAGE_set_bodytype() sets the type of the message contained in
+the PKIMessage body field.
+
+CMP_PKIMESSAGE_set_implicitConfirm() sets implicitConfirm in the
+generalInfo field of the header.
+
+CMP_PKISTATUSINFO_PKIFailureInfo_get_string() returns a string
+representing the failure code in the given PKIFailureInfo structure.
+
+CMP_PKISTATUSINFO_PKIstatus_get() finds the CertResponse with the given
+certReqId inside the given CertRepMessage, and returns the value of
+PKIStatus in that message.
+
+CMP_PKISTATUSINFO_PKIstatus_get_string() returns a string representing
+the status of the given PKIStatusInfo.
+
+CMP_get_protectionAlgor_by_nid() creates an X509_ALGOR structure based
+on the given nid. Either a PBMAC algorithm or signature key based.
+
+CMP_get_protectionAlgor_pbmac() initializes an X509_ALGOR structure for
+Password Based MAC. Creates a CRMF_PBMPARAMETER structure for the
+parameters.
+
+CMP_protection_new() calculates the value of protection field for the
+PKIMessage, either by using Password based MAC or signing it with a
+private key.
+
+CMP_CERTREPMESSAGE_PKIStatusString_get0() gets the CertResponse with the
+given certReqId inside the gven CertReqMessage, and returns the
+status->statuString field contained in it.
+
+CMP_CERTRESPONSE_PKIStatusString_get0() returns the status->statuString
+field of the given CertResponse structure.
+
+CMP_ITAV_stack_item_push0() pushes the given InfoTypeAndValue to the
+given stack, creating a new stack if one does not exist yet.
+
+
+=head1 NOTES
+
+CMP is defined in RFC 4210 (and CRMF in RFC 4211).
+
+The implementation of CMP for OpenSSL is still work in progress. The API
+might change every release!
+
+=head1 RETURN VALUES
+
+
+
+=head1 EXAMPLE
+
+
+=head1 TODO
+
+A lot!
+
+=head1 SEE ALSO
+
+CMP_CTX, CMP_session, CMP_msg, CMP_http
Index: openssl-1.0.0i-cmp/crypto/crmf/crmf_pbm.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/crmf/crmf_pbm.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/crmf/crmf_pbm.c	(revision 469)
@@ -0,0 +1,222 @@
+/* crypto/crmf/crmf_pbm.c
+ * CRMF (RFC 4211) "Password Based Mac" functions for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/rand.h>
+#include <openssl/evp.h>
+#include <openssl/hmac.h>
+#include <openssl/err.h>
+
+#define SALT_LEN         16
+#define ITERATION_COUNT 500
+
+/* ############################################################################ */
+/* id-PasswordBasedMAC OBJECT IDENTIFIER ::= { 1 2 840 113533 7 66 13} */
+CRMF_PBMPARAMETER * CRMF_pbm_new(void) {
+	CRMF_PBMPARAMETER *pbm=NULL;
+	unsigned char salt[SALT_LEN];
+
+	if(!(pbm = CRMF_PBMPARAMETER_new())) goto err;
+
+	/* salt contains a randomly generated value used in computing the key
+	 * of the MAC process.  The salt SHOULD be at least 8 octets (64
+	 * bits) long.
+	 */
+	/* XXX XXX XXX */
+	RAND_pseudo_bytes(salt, SALT_LEN);
+	if (!(ASN1_OCTET_STRING_set(pbm->salt, salt, SALT_LEN))) goto err;
+
+	/* owf identifies the algorithm and associated parameters used to
+	 * compute the key used in the MAC process.  All implementations MUST
+	 * support SHA-1.
+	 */
+	/* TODO right now SHA-1 is hardcoded */
+	X509_ALGOR_set0(pbm->owf, OBJ_nid2obj(NID_sha1), V_ASN1_UNDEF, NULL);
+
+	/*
+	   iterationCount identifies the number of times the hash is applied
+	   during the key computation process.  The iterationCount MUST be a
+	   minimum of 100.  Many people suggest using values as high as 1000
+	   iterations as the minimum value.  The trade off here is between
+	   protection of the password from attacks and the time spent by the
+	   server processing all of the different iterations in deriving
+	   passwords.  Hashing is generally considered a cheap operation but
+	   this may not be true with all hash functions in the future.
+	   */
+	ASN1_INTEGER_set(pbm->iterationCount, ITERATION_COUNT);
+
+	/*
+	   mac identifies the algorithm and associated parameters of the MAC
+	   function to be used.  All implementations MUST support HMAC-SHA1
+	   [HMAC].  All implementations SHOULD support DES-MAC and Triple-
+	   DES-MAC [PKCS11].
+	   */
+	/* TODO right now HMAC-SHA1 is hardcoded */
+	/* X509_ALGOR_set0(mac, OBJ_nid2obj(NID_id_alg_dh_sig_hmac_sha1), V_ASN1_UNDEF, NULL); */
+	X509_ALGOR_set0(pbm->mac, OBJ_nid2obj(NID_hmac_sha1), V_ASN1_UNDEF, NULL);
+
+	return pbm;
+err:
+	if(pbm) CRMF_PBMPARAMETER_free(pbm);
+	return NULL;
+}
+
+
+/* ############################################################################ */
+/* this function calculates the PBM
+ * @pbm identifies the algorithms to use TODO: this is not evaluated comletely,
+ *      standard parameters are used
+ * @msg message to apply the PBM for
+ * @msgLen length of the message
+ * @secret key to use
+ * @secretLen length of the key
+ * @mac pointer to the computed mac, is allocated here, will be freed if not
+ *      pointing to NULL
+ * @macLen pointer to the length of the mac, will be set
+ *
+ * returns 1 at success, 0 at error
+ */
+int CRMF_passwordBasedMac_new( const CRMF_PBMPARAMETER *pbm,
+			   const unsigned char* msg, size_t msgLen, 
+			   const unsigned char* secret, size_t secretLen,
+			   unsigned char** mac, unsigned int* macLen
+			   ) {
+
+	const EVP_MD *m=NULL;
+	EVP_MD_CTX *ctx=NULL;
+	unsigned char basekey[EVP_MAX_MD_SIZE];
+	unsigned int basekeyLen;
+	long iterations;
+
+	if (!mac) goto err;
+	if( *mac) OPENSSL_free(*mac);
+
+	if (!pbm) goto err;
+	if (!msg) goto err;
+	if (!secret) goto err;
+
+	*mac = OPENSSL_malloc(EVP_MAX_MD_SIZE);
+
+	OpenSSL_add_all_digests();
+
+	/*
+	 * owf identifies the algorithm and associated parameters used to
+	 * compute the key used in the MAC process.  All implementations MUST
+	 * support SHA-1.
+	 */
+	if (!(m = EVP_get_digestbyobj(pbm->owf->algorithm))) goto err;
+
+	ctx=EVP_MD_CTX_create();
+
+	/* compute the basekey of the salted secret */
+	if (!(EVP_DigestInit_ex(ctx, m, NULL))) goto err;
+	/* first the secret */
+	EVP_DigestUpdate(ctx, secret, secretLen);
+	/* then the salt */
+	EVP_DigestUpdate(ctx, pbm->salt->data, pbm->salt->length);
+	if (!(EVP_DigestFinal_ex(ctx, basekey, &basekeyLen))) goto err;
+
+	/* the first iteration is already done above -> -1 */
+	iterations = ASN1_INTEGER_get(pbm->iterationCount)-1;
+	while( iterations--) {
+		if (!(EVP_DigestInit_ex(ctx, m, NULL))) goto err;
+		EVP_DigestUpdate(ctx, basekey, basekeyLen);
+		if (!(EVP_DigestFinal_ex(ctx, basekey, &basekeyLen))) goto err;
+	}
+
+	/*
+	 * mac identifies the algorithm and associated parameters of the MAC
+	 * function to be used.  All implementations MUST support HMAC-SHA1
+	 * [HMAC].  All implementations SHOULD support DES-MAC and Triple-
+	 * DES-MAC [PKCS11].
+	 */
+	switch (OBJ_obj2nid(pbm->mac->algorithm)) {
+		case NID_hmac_sha1:
+			HMAC(EVP_sha1(), basekey, basekeyLen, msg, msgLen, *mac, macLen);
+			break;
+			/* optional TODO: DES-MAC, Triple DES-MAC */
+			/* which NIDs to use for these algorithms??? */
+		default:
+			CRMFerr(CRMF_F_CRMF_PASSWORDBASEDMAC_NEW, CRMF_R_UNSUPPORTED_ALGORITHM);
+			exit(1);
+	}
+
+	/* cleanup */
+	EVP_MD_CTX_destroy(ctx);
+
+	return 1;
+err:
+	if( mac && *mac) OPENSSL_free(*mac);
+	CRMFerr(CRMF_F_CRMF_PASSWORDBASEDMAC_NEW, CRMF_R_CRMFERROR);
+	return 0;
+}
Index: openssl-1.0.0i-cmp/crypto/crmf/crmf_asn.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/crmf/crmf_asn.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/crmf/crmf_asn.c	(revision 469)
@@ -0,0 +1,289 @@
+/* crmf_asn.c
+ * OpenSSL ASN.1 definitions for CRMF (RFC 4211)
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+
+ASN1_SEQUENCE(CRMF_PRIVATEKEYINFO) = {
+	ASN1_SIMPLE(CRMF_PRIVATEKEYINFO, version, ASN1_INTEGER),
+	ASN1_SIMPLE(CRMF_PRIVATEKEYINFO, AlgorithmIdentifier, X509_ALGOR),
+	ASN1_SIMPLE(CRMF_PRIVATEKEYINFO, privateKey, ASN1_OCTET_STRING),
+	ASN1_IMP_SET_OF_OPT(X509_REQ_INFO, attributes, X509_ATTRIBUTE, 0)
+} ASN1_SEQUENCE_END(CRMF_PRIVATEKEYINFO)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_PRIVATEKEYINFO)
+
+
+ASN1_CHOICE(CRMF_ENCKEYWITHID_IDENTIFIER) = {
+	ASN1_IMP(CRMF_ENCKEYWITHID_IDENTIFIER, value.string, ASN1_UTF8STRING, 0),
+	ASN1_IMP(CRMF_ENCKEYWITHID_IDENTIFIER, value.generalName, GENERAL_NAME, 1)
+} ASN1_CHOICE_END(CRMF_ENCKEYWITHID_IDENTIFIER)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_ENCKEYWITHID_IDENTIFIER)
+
+
+ASN1_SEQUENCE(CRMF_ENCKEYWITHID) = {
+	ASN1_SIMPLE(CRMF_ENCKEYWITHID, privateKey, CRMF_PRIVATEKEYINFO),
+	ASN1_IMP_OPT(CRMF_ENCKEYWITHID, identifier, CRMF_ENCKEYWITHID_IDENTIFIER,0)
+} ASN1_SEQUENCE_END(CRMF_ENCKEYWITHID)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_ENCKEYWITHID)
+
+
+ASN1_SEQUENCE(CRMF_CERTID) = {
+	ASN1_SIMPLE(CRMF_CERTID, issuer, GENERAL_NAME),
+	ASN1_SIMPLE(CRMF_CERTID, serialNumber, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(CRMF_CERTID)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_CERTID)
+
+
+ASN1_SEQUENCE(CRMF_ENCRYPTEDVALUE) = {
+	ASN1_IMP_OPT(CRMF_ENCRYPTEDVALUE, intendedAlg, X509_ALGOR,0),
+	ASN1_IMP_OPT(CRMF_ENCRYPTEDVALUE, symmAlg, X509_ALGOR,1),
+	ASN1_IMP_OPT(CRMF_ENCRYPTEDVALUE, encSymmKey, ASN1_BIT_STRING,2),
+	ASN1_IMP_OPT(CRMF_ENCRYPTEDVALUE, keyAlg, X509_ALGOR,3),
+	ASN1_IMP_OPT(CRMF_ENCRYPTEDVALUE, valueHint, ASN1_OCTET_STRING,4),
+	ASN1_SIMPLE(CRMF_ENCRYPTEDVALUE, encValue, ASN1_BIT_STRING)
+} ASN1_SEQUENCE_END(CRMF_ENCRYPTEDVALUE)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_ENCRYPTEDVALUE)
+
+
+/* TODO CMS_ENVELOPEDDATA */
+ASN1_SEQUENCE(CMS_ENVELOPEDDATA) = {
+	ASN1_SIMPLE(CMS_ENVELOPEDDATA, version, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(CMS_ENVELOPEDDATA)
+IMPLEMENT_ASN1_FUNCTIONS(CMS_ENVELOPEDDATA)
+
+
+ASN1_CHOICE(CRMF_ENCRYPTEDKEY) = {
+	ASN1_IMP(CRMF_ENCRYPTEDKEY, value.encryptedValue, CRMF_ENCRYPTEDVALUE, 0),
+	ASN1_IMP(CRMF_ENCRYPTEDKEY, value.envelopedData, CMS_ENVELOPEDDATA, 1)
+} ASN1_CHOICE_END(CRMF_ENCRYPTEDKEY)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_ENCRYPTEDKEY)
+
+
+ASN1_CHOICE(CRMF_PKIARCHIVEOPTIONS) = {
+	ASN1_EXP(CRMF_PKIARCHIVEOPTIONS, value.encryptedPrivKey, CRMF_ENCRYPTEDKEY, 0),
+	ASN1_EXP(CRMF_PKIARCHIVEOPTIONS, value.keyGenParameters, ASN1_OCTET_STRING, 1),
+	ASN1_EXP(CRMF_PKIARCHIVEOPTIONS, value.archiveRemGenPrivKey, ASN1_BOOLEAN, 2)
+} ASN1_CHOICE_END(CRMF_PKIARCHIVEOPTIONS)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_PKIARCHIVEOPTIONS)
+IMPLEMENT_ASN1_DUP_FUNCTION(CRMF_PKIARCHIVEOPTIONS)
+
+
+ASN1_SEQUENCE(CRMF_SINGLEPUBINFO) = {
+	ASN1_SIMPLE(CRMF_SINGLEPUBINFO, pubMethod, ASN1_INTEGER),
+	ASN1_SIMPLE(CRMF_SINGLEPUBINFO, pubLocation, GENERAL_NAME)
+} ASN1_SEQUENCE_END(CRMF_SINGLEPUBINFO)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_SINGLEPUBINFO)
+
+
+ASN1_SEQUENCE(CRMF_PKIPUBLICATIONINFO) = {
+	ASN1_SIMPLE(CRMF_PKIPUBLICATIONINFO, action, ASN1_INTEGER),
+	ASN1_SEQUENCE_OF_OPT(CRMF_PKIPUBLICATIONINFO, pubinfos, GENERAL_NAME)
+} ASN1_SEQUENCE_END(CRMF_PKIPUBLICATIONINFO)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_PKIPUBLICATIONINFO)
+IMPLEMENT_ASN1_DUP_FUNCTION(CRMF_PKIPUBLICATIONINFO)
+
+
+ASN1_SEQUENCE(CRMF_PKMACVALUE) = {
+	ASN1_SIMPLE(CRMF_PKMACVALUE, algId, X509_ALGOR),
+	ASN1_SIMPLE(CRMF_PKMACVALUE, value, ASN1_BIT_STRING)
+} ASN1_SEQUENCE_END(CRMF_PKMACVALUE)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_PKMACVALUE)
+
+
+ASN1_CHOICE(CRMF_POPOPRIVKEY) = {
+	ASN1_IMP(CRMF_POPOPRIVKEY, value.thisMessage, ASN1_BIT_STRING, 0),
+	ASN1_IMP(CRMF_POPOPRIVKEY, value.subsequentMessage, ASN1_INTEGER, 1),
+	ASN1_IMP(CRMF_POPOPRIVKEY, value.dhMAC, ASN1_BIT_STRING, 2),
+	ASN1_IMP(CRMF_POPOPRIVKEY, value.agreeMAC, CRMF_PKMACVALUE, 3),
+	ASN1_IMP(CRMF_POPOPRIVKEY, value.encryptedKey, CMS_ENVELOPEDDATA, 4),
+} ASN1_CHOICE_END(CRMF_POPOPRIVKEY)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_POPOPRIVKEY)
+
+
+ASN1_SEQUENCE(CRMF_PBMPARAMETER) = {
+	ASN1_SIMPLE(CRMF_PBMPARAMETER, salt, ASN1_OCTET_STRING),
+	ASN1_SIMPLE(CRMF_PBMPARAMETER, owf, X509_ALGOR),
+	ASN1_SIMPLE(CRMF_PBMPARAMETER, iterationCount, ASN1_INTEGER),
+	ASN1_SIMPLE(CRMF_PBMPARAMETER, mac, X509_ALGOR)
+} ASN1_SEQUENCE_END(CRMF_PBMPARAMETER)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_PBMPARAMETER)
+
+
+ASN1_CHOICE(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO) = {
+	ASN1_EXP(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO, value.sender, GENERAL_NAME, 0),
+	ASN1_IMP(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO, value.publicKeyMAC, CRMF_PKMACVALUE, 1)
+} ASN1_CHOICE_END(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO)
+
+
+ASN1_SEQUENCE(CRMF_POPOSIGNINGKEYINPUT) = {
+	ASN1_SIMPLE(CRMF_POPOSIGNINGKEYINPUT, authinfo, CRMF_POPOSIGNINGKEYINPUT_AUTHINFO),
+	ASN1_SIMPLE(CRMF_POPOSIGNINGKEYINPUT, publicKey, X509_PUBKEY)
+} ASN1_SEQUENCE_END(CRMF_POPOSIGNINGKEYINPUT)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_POPOSIGNINGKEYINPUT)
+
+
+ASN1_SEQUENCE(CRMF_POPOSIGNINGKEY) = {
+	ASN1_IMP_OPT(CRMF_POPOSIGNINGKEY, poposkInput, CRMF_POPOSIGNINGKEYINPUT,0),
+	ASN1_SIMPLE(CRMF_POPOSIGNINGKEY, algorithmIdentifier, X509_ALGOR),
+	ASN1_SIMPLE(CRMF_POPOSIGNINGKEY, signature, ASN1_BIT_STRING)
+} ASN1_SEQUENCE_END(CRMF_POPOSIGNINGKEY)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_POPOSIGNINGKEY)
+
+
+ASN1_CHOICE(CRMF_PROOFOFPOSSESION) = {
+	ASN1_IMP(CRMF_PROOFOFPOSSESION, value.raVerified, ASN1_NULL, 0),
+	ASN1_IMP(CRMF_PROOFOFPOSSESION, value.signature, CRMF_POPOSIGNINGKEY, 1),
+	ASN1_EXP(CRMF_PROOFOFPOSSESION, value.keyEncipherment, CRMF_POPOPRIVKEY, 2),
+	ASN1_IMP(CRMF_PROOFOFPOSSESION, value.keyAgreement, CRMF_POPOPRIVKEY, 3)
+} ASN1_CHOICE_END(CRMF_PROOFOFPOSSESION)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_PROOFOFPOSSESION)
+
+
+ASN1_ADB_TEMPLATE(attributetypeandvalue_default) = ASN1_OPT(CRMF_ATTRIBUTETYPEANDVALUE, value.other, ASN1_ANY);
+ASN1_ADB(CRMF_ATTRIBUTETYPEANDVALUE) = {
+	ADB_ENTRY(NID_id_regCtrl_regToken,           ASN1_SIMPLE(CRMF_ATTRIBUTETYPEANDVALUE, value.regToken,           ASN1_UTF8STRING)),
+	ADB_ENTRY(NID_id_regCtrl_authenticator,      ASN1_SIMPLE(CRMF_ATTRIBUTETYPEANDVALUE, value.authenticator,      ASN1_UTF8STRING)),
+	ADB_ENTRY(NID_id_regCtrl_pkiPublicationInfo, ASN1_SIMPLE(CRMF_ATTRIBUTETYPEANDVALUE, value.pkiPublicationInfo, CRMF_PKIPUBLICATIONINFO)),
+	ADB_ENTRY(NID_id_regCtrl_pkiArchiveOptions,  ASN1_SIMPLE(CRMF_ATTRIBUTETYPEANDVALUE, value.pkiArchiveOptions,  CRMF_PKIARCHIVEOPTIONS)),
+	ADB_ENTRY(NID_id_regCtrl_oldCertID,          ASN1_SIMPLE(CRMF_ATTRIBUTETYPEANDVALUE, value.oldCertId,          CRMF_CERTID)),
+	ADB_ENTRY(NID_id_regCtrl_protocolEncrKey,    ASN1_SIMPLE(CRMF_ATTRIBUTETYPEANDVALUE, value.protocolEncrKey,    X509_PUBKEY)),
+	ADB_ENTRY(NID_id_regInfo_utf8Pairs,          ASN1_SIMPLE(CRMF_ATTRIBUTETYPEANDVALUE, value.utf8pairs,          ASN1_UTF8STRING)),
+	ADB_ENTRY(NID_id_regInfo_certReq,            ASN1_SIMPLE(CRMF_ATTRIBUTETYPEANDVALUE, value.certReq,            CRMF_CERTREQUEST)),
+} ASN1_ADB_END(CRMF_ATTRIBUTETYPEANDVALUE, 0, type, 0, &attributetypeandvalue_default_tt, NULL);
+
+ASN1_SEQUENCE(CRMF_ATTRIBUTETYPEANDVALUE) = 
+{
+	ASN1_SIMPLE(CRMF_ATTRIBUTETYPEANDVALUE, type, ASN1_OBJECT),
+	ASN1_ADB_OBJECT(CRMF_ATTRIBUTETYPEANDVALUE)
+} ASN1_SEQUENCE_END(CRMF_ATTRIBUTETYPEANDVALUE)
+
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_ATTRIBUTETYPEANDVALUE)
+IMPLEMENT_ASN1_DUP_FUNCTION(CRMF_ATTRIBUTETYPEANDVALUE)
+
+
+
+
+ASN1_SEQUENCE(CRMF_OPTIONALVALIDITY) = {
+	ASN1_EXP_OPT(CRMF_OPTIONALVALIDITY, notBefore, ASN1_TIME, 0),
+	ASN1_EXP_OPT(CRMF_OPTIONALVALIDITY, notAfter, ASN1_TIME, 1)
+} ASN1_SEQUENCE_END(CRMF_OPTIONALVALIDITY)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_OPTIONALVALIDITY)
+
+
+ASN1_SEQUENCE(CRMF_CERTTEMPLATE) = {
+	/* Figured out that I have to use IMP here - don't know why */
+	ASN1_IMP_OPT(CRMF_CERTTEMPLATE, version, ASN1_INTEGER, 0),
+	/* serialNumber MUST be omitted.  This field is assigned by the CA
+	 * during certificate creation. */
+	ASN1_IMP_OPT(CRMF_CERTTEMPLATE, serialNumber, ASN1_INTEGER, 1),
+	/* signingAlg MUST be omitted.  This field is assigned by the CA
+	 * during certificate creation. */
+	ASN1_IMP_OPT(CRMF_CERTTEMPLATE, signingAlg, X509_ALGOR, 2),
+	ASN1_EXP_OPT(CRMF_CERTTEMPLATE, issuer, X509_NAME, 3),
+	ASN1_IMP_OPT(CRMF_CERTTEMPLATE, validity, CRMF_OPTIONALVALIDITY, 4),
+	ASN1_EXP_OPT(CRMF_CERTTEMPLATE, subject, X509_NAME, 5),
+	ASN1_IMP_OPT(CRMF_CERTTEMPLATE, publicKey, X509_PUBKEY, 6),
+	/* issuerUID is deprecated in version 2 */
+	ASN1_IMP_OPT(CRMF_CERTTEMPLATE, issuerUID, ASN1_BIT_STRING, 7),
+	/* subjectUID is deprecated in version 2 */
+	ASN1_IMP_OPT(CRMF_CERTTEMPLATE, subjectUID, ASN1_BIT_STRING, 8),
+	ASN1_IMP_SEQUENCE_OF_OPT(CRMF_CERTTEMPLATE, extensions, X509_EXTENSION, 9),
+} ASN1_SEQUENCE_END(CRMF_CERTTEMPLATE)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_CERTTEMPLATE)
+
+
+ASN1_SEQUENCE(CRMF_CERTREQUEST) = {
+	ASN1_SIMPLE(CRMF_CERTREQUEST, certReqId, ASN1_INTEGER),
+	ASN1_SIMPLE(CRMF_CERTREQUEST, certTemplate, CRMF_CERTTEMPLATE),
+	ASN1_SEQUENCE_OF_OPT(CRMF_CERTREQUEST, controls, CRMF_ATTRIBUTETYPEANDVALUE)
+} ASN1_SEQUENCE_END(CRMF_CERTREQUEST)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_CERTREQUEST)
+IMPLEMENT_ASN1_DUP_FUNCTION(CRMF_CERTREQUEST)
+
+
+ASN1_SEQUENCE(CRMF_CERTREQMSG) = {
+	ASN1_SIMPLE(CRMF_CERTREQMSG, certReq, CRMF_CERTREQUEST),
+	ASN1_OPT(CRMF_CERTREQMSG, popo, CRMF_PROOFOFPOSSESION),
+	ASN1_SEQUENCE_OF_OPT(CRMF_CERTREQMSG, regInfo, CRMF_ATTRIBUTETYPEANDVALUE)
+} ASN1_SEQUENCE_END(CRMF_CERTREQMSG)
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_CERTREQMSG)
+
+
+#if 0
+ASN1_ITEM_TEMPLATE(CRMF_CERTREQMESSAGES) =
+	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, CertReqMessages, CRMF_CERTREQMSG)
+	ASN1_ITEM_TEMPLATE_END(CRMF_CERTREQMESSAGES)
+
+IMPLEMENT_ASN1_FUNCTIONS(CRMF_CERTREQMESSAGES)
+#endif
+
Index: openssl-1.0.0i-cmp/crypto/crmf/Makefile
===================================================================
--- openssl-1.0.0i-cmp/crypto/crmf/Makefile	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/crmf/Makefile	(revision 469)
@@ -0,0 +1,164 @@
+#
+# OpenSSL/crmf/Makefile
+#
+
+DIR=	crmf
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG) -Wall -DCRMF_DEBUG
+
+GENERAL=Makefile README
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= crmf_asn.c crmf_lib.c crmf_pbm.c crmf_msg.c crmf_atav.c crmf_err.c
+LIBOBJ= crmf_asn.o crmf_lib.o crmf_pbm.o crmf_msg.o crmf_atav.o crmf_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= crmf.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+crmf_asn.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+crmf_asn.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+crmf_asn.o: ../../include/openssl/conf.h ../../include/openssl/crmf.h
+crmf_asn.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+crmf_asn.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+crmf_asn.o: ../../include/openssl/ecdsa.h ../../include/openssl/evp.h
+crmf_asn.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+crmf_asn.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+crmf_asn.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+crmf_asn.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+crmf_asn.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+crmf_asn.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+crmf_asn.o: ../../include/openssl/x509_vfy.h ../../include/openssl/x509v3.h
+crmf_asn.o: crmf_asn.c
+crmf_atav.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+crmf_atav.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+crmf_atav.o: ../../include/openssl/conf.h ../../include/openssl/crmf.h
+crmf_atav.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+crmf_atav.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+crmf_atav.o: ../../include/openssl/ecdsa.h ../../include/openssl/evp.h
+crmf_atav.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+crmf_atav.o: ../../include/openssl/objects.h
+crmf_atav.o: ../../include/openssl/opensslconf.h
+crmf_atav.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+crmf_atav.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+crmf_atav.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+crmf_atav.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+crmf_atav.o: ../../include/openssl/x509_vfy.h ../../include/openssl/x509v3.h
+crmf_atav.o: crmf_atav.c
+crmf_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+crmf_err.o: ../../include/openssl/buffer.h ../../include/openssl/conf.h
+crmf_err.o: ../../include/openssl/crmf.h ../../include/openssl/crypto.h
+crmf_err.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+crmf_err.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+crmf_err.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+crmf_err.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+crmf_err.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+crmf_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+crmf_err.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+crmf_err.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+crmf_err.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+crmf_err.o: ../../include/openssl/x509_vfy.h ../../include/openssl/x509v3.h
+crmf_err.o: crmf_err.c
+crmf_lib.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+crmf_lib.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+crmf_lib.o: ../../include/openssl/conf.h ../../include/openssl/crmf.h
+crmf_lib.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+crmf_lib.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+crmf_lib.o: ../../include/openssl/ecdsa.h ../../include/openssl/err.h
+crmf_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+crmf_lib.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+crmf_lib.o: ../../include/openssl/opensslconf.h
+crmf_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+crmf_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+crmf_lib.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+crmf_lib.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+crmf_lib.o: ../../include/openssl/x509_vfy.h ../../include/openssl/x509v3.h
+crmf_lib.o: crmf_lib.c
+crmf_msg.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+crmf_msg.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+crmf_msg.o: ../../include/openssl/cmp.h ../../include/openssl/conf.h
+crmf_msg.o: ../../include/openssl/crmf.h ../../include/openssl/crypto.h
+crmf_msg.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+crmf_msg.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+crmf_msg.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+crmf_msg.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+crmf_msg.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+crmf_msg.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+crmf_msg.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+crmf_msg.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+crmf_msg.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+crmf_msg.o: ../../include/openssl/x509_vfy.h ../../include/openssl/x509v3.h
+crmf_msg.o: crmf_msg.c
+crmf_pbm.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+crmf_pbm.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+crmf_pbm.o: ../../include/openssl/conf.h ../../include/openssl/crmf.h
+crmf_pbm.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+crmf_pbm.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+crmf_pbm.o: ../../include/openssl/ecdsa.h ../../include/openssl/err.h
+crmf_pbm.o: ../../include/openssl/evp.h ../../include/openssl/hmac.h
+crmf_pbm.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+crmf_pbm.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+crmf_pbm.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+crmf_pbm.o: ../../include/openssl/pkcs7.h ../../include/openssl/rand.h
+crmf_pbm.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+crmf_pbm.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+crmf_pbm.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+crmf_pbm.o: ../../include/openssl/x509v3.h crmf_pbm.c
Index: openssl-1.0.0i-cmp/crypto/crmf/crmf.h
===================================================================
--- openssl-1.0.0i-cmp/crypto/crmf/crmf.h	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/crmf/crmf.h	(revision 469)
@@ -0,0 +1,619 @@
+/* crypto/crmf/crmf.h
+ * Header file for CRMF (RFC 4211) for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ */
+
+#ifndef HEADER_CRMF_H
+#define HEADER_CRMF_H
+
+#include <openssl/ossl_typ.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/safestack.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+// make sure this is defined only once if both cmp.h and crmf.h are included
+#ifndef HEADER_CMP_H
+#if OPENSSL_VERSION_NUMBER < 0x10000000L 
+typedef STACK_OF(X509_EXTENSION) X509_EXTENSIONS;
+#endif
+#endif
+
+/*
+Attributes ::= SET OF Attribute
+=> X509_ATTRIBUTE
+
+PrivateKeyInfo ::= SEQUENCE {
+   version                   INTEGER,
+   privateKeyAlgorithm       AlgorithmIdentifier,
+   privateKey                OCTET STRING,
+   attributes                [0] IMPLICIT Attributes OPTIONAL
+}
+*/
+
+typedef struct crmf_privatekeyinfo_st
+{
+	ASN1_INTEGER             *version;
+	X509_ALGOR               *AlgorithmIdentifier;
+	ASN1_OCTET_STRING        *privateKey;
+	STACK_OF(X509_ATTRIBUTE) *attributes; /* [ 0 ] */
+} CRMF_PRIVATEKEYINFO;
+DECLARE_ASN1_FUNCTIONS(CRMF_PRIVATEKEYINFO)
+
+/*
+EncKeyWithID ::= SEQUENCE {
+  privateKey           PrivateKeyInfo,
+  identifier CHOICE {
+    string             UTF8String,
+    generalName        GeneralName
+  } OPTIONAL
+}
+*/
+typedef struct crmf_enckeywithid_identifier_st
+{
+	int type;
+	union   {
+		ASN1_UTF8STRING *string;
+		GENERAL_NAME    *generalName;
+	} value;
+} CRMF_ENCKEYWITHID_IDENTIFIER;
+DECLARE_ASN1_FUNCTIONS(CRMF_ENCKEYWITHID_IDENTIFIER)
+
+typedef struct crmf_enckeywithid_st
+{
+	CRMF_PRIVATEKEYINFO          *privateKey;
+	CRMF_ENCKEYWITHID_IDENTIFIER *identifier; /* [0] */
+
+} CRMF_ENCKEYWITHID;
+DECLARE_ASN1_FUNCTIONS(CRMF_ENCKEYWITHID)
+
+/*
+CertId ::= SEQUENCE {
+ issuer           GeneralName,
+ serialNumber     INTEGER }
+ */
+
+typedef struct crmf_certid_st
+{
+	GENERAL_NAME *issuer;
+	ASN1_INTEGER *serialNumber;
+} CRMF_CERTID;
+DECLARE_ASN1_FUNCTIONS(CRMF_CERTID)
+DECLARE_STACK_OF(CRMF_CERTID)
+
+/*
+EncryptedValue ::= SEQUENCE {
+ intendedAlg   [0] AlgorithmIdentifier  OPTIONAL,
+ -- the intended algorithm for which the value will be used
+ symmAlg       [1] AlgorithmIdentifier  OPTIONAL,
+ -- the symmetric algorithm used to encrypt the value
+ encSymmKey    [2] BIT STRING           OPTIONAL,
+ -- the (encrypted) symmetric key used to encrypt the value
+ keyAlg        [3] AlgorithmIdentifier  OPTIONAL,
+ -- algorithm used to encrypt the symmetric key
+ valueHint     [4] OCTET STRING         OPTIONAL,
+ -- a brief description or identifier of the encValue content
+ -- (may be meaningful only to the sending entity, and used only
+ -- if EncryptedValue might be re-examined by the sending entity
+ -- in the future)
+ encValue       BIT STRING }
+ -- the encrypted value itself
+*/
+
+typedef struct crmf_encrypetedvalue_st
+{
+	X509_ALGOR               *intendedAlg; /* 0 */
+	X509_ALGOR               *symmAlg; /* 1 */
+	ASN1_BIT_STRING          *encSymmKey; /* 2 */
+	X509_ALGOR               *keyAlg; /* 3 */
+	ASN1_OCTET_STRING        *valueHint; /* 4 */
+	ASN1_BIT_STRING          *encValue;
+} CRMF_ENCRYPTEDVALUE;
+DECLARE_ASN1_FUNCTIONS(CRMF_ENCRYPTEDVALUE)
+
+/*
+TODO
+   -- Cryptographic Message Syntax
+   EnvelopedData
+   FROM CryptographicMessageSyntax2004 { iso(1) member-body(2)
+   us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16)
+   modules(0) cms-2004(24) };  -- found in [CMS]
+
+[CMS] Housley, R., "Cryptographic Message Syntax (CMS)", RFC 3852, July 2004.
+
+*/
+typedef struct cms_envelopeddata_st
+{
+	/* TODO
+	 * There is actually much more
+	 * I hope I'll not need that 
+	 */
+	ASN1_INTEGER *version;
+
+} CMS_ENVELOPEDDATA;
+DECLARE_ASN1_FUNCTIONS(CMS_ENVELOPEDDATA)
+
+
+/*
+EncryptedKey ::= CHOICE {
+ encryptedValue        EncryptedValue,   -- Deprecated
+ envelopedData     [0] EnvelopedData }
+ */
+typedef struct crmf_encryptedkey_st
+{
+	int type;
+	union   {
+		CRMF_ENCRYPTEDVALUE *encryptedValue; /* Deprecated */
+		CMS_ENVELOPEDDATA *envelopedData; /* XXX this is not really implemented so far */ /* 0 */
+	} value;
+} CRMF_ENCRYPTEDKEY;
+DECLARE_ASN1_FUNCTIONS(CRMF_ENCRYPTEDKEY)
+
+/*
+PKIArchiveOptions ::= CHOICE {
+ encryptedPrivKey     [0] EncryptedKey,
+ -- the actual value of the private key
+ keyGenParameters     [1] KeyGenParameters,
+ -- parameters that allow the private key to be re-generated
+ archiveRemGenPrivKey [2] BOOLEAN }
+ -- set to TRUE if sender wishes receiver to archive the private
+ -- key of a key pair that the receiver generates in response to
+ -- this request; set to FALSE if no archival is desired.
+*/
+typedef struct crmf_pkiarchiveoptions_st
+{
+	int type;
+	union   {
+		CRMF_ENCRYPTEDKEY *encryptedPrivKey; /* 0 */
+		ASN1_OCTET_STRING *keyGenParameters; /* KeyGenParameters ::= OCTET STRING */ /* 1 */
+		ASN1_BOOLEAN      *archiveRemGenPrivKey; /* 2 */
+	} value;
+} CRMF_PKIARCHIVEOPTIONS;
+DECLARE_ASN1_FUNCTIONS(CRMF_PKIARCHIVEOPTIONS)
+CRMF_PKIARCHIVEOPTIONS *CRMF_PKIARCHIVEOPTIONS_dup( CRMF_PKIARCHIVEOPTIONS *pkiPubInfo);
+
+/*
+SinglePubInfo ::= SEQUENCE {
+ pubMethod    INTEGER {
+     dontCare    (0),
+     x500        (1),
+     web         (2),
+     ldap        (3) },
+ pubLocation  GeneralName OPTIONAL }
+ */
+
+typedef struct crmf_singlepubinfo_st
+{
+	ASN1_INTEGER *pubMethod;
+	GENERAL_NAME *pubLocation;
+} CRMF_SINGLEPUBINFO;
+DECLARE_ASN1_FUNCTIONS(CRMF_SINGLEPUBINFO)
+
+
+/*
+PKIPublicationInfo ::= SEQUENCE {
+action     INTEGER {
+             dontPublish (0),
+             pleasePublish (1) },
+pubInfos  SEQUENCE SIZE (1..MAX) OF SinglePubInfo OPTIONAL }
+  -- pubInfos MUST NOT be present if action is "dontPublish"
+  -- (if action is "pleasePublish" and pubInfos is omitted,
+  -- "dontCare" is assumed)
+*/
+
+typedef struct crmf_pkipublicationinfo_st
+{
+	ASN1_INTEGER *action;
+	CRMF_SINGLEPUBINFO *pubinfos; /* XXX what to do with the SEQUENCE SIZE... ? */
+} CRMF_PKIPUBLICATIONINFO;
+DECLARE_ASN1_FUNCTIONS(CRMF_PKIPUBLICATIONINFO)
+CRMF_PKIPUBLICATIONINFO *CRMF_PKIPUBLICATIONINFO_dup( CRMF_PKIPUBLICATIONINFO *pkiPubInfo);
+
+/*
+TODO
+PKMACValue ::= SEQUENCE {
+algId  AlgorithmIdentifier,
+-- algorithm value shall be PasswordBasedMac {1 2 840 113533 7 66 13}
+-- parameter value is PBMParameter
+value  BIT STRING }
+*/
+typedef struct crmf_pkmacvalue_st
+{
+	X509_ALGOR      *algId;
+	ASN1_BIT_STRING *value;
+} CRMF_PKMACVALUE;
+DECLARE_ASN1_FUNCTIONS(CRMF_PKMACVALUE)
+
+
+/*
+SubsequentMessage ::= INTEGER {
+ encrCert (0),
+ -- requests that resulting certificate be encrypted for the
+ -- end entity (following which, POP will be proven in a
+ -- confirmation message)
+ challengeResp (1) }
+ -- requests that CA engage in challenge-response exchange with
+ -- end entity in order to prove private key possession
+
+POPOPrivKey ::= CHOICE {
+ thisMessage       [0] BIT STRING,         -- Deprecated
+ -- possession is proven in this message (which contains the private
+ -- key itself (encrypted for the CA))
+ subsequentMessage [1] SubsequentMessage,
+ -- possession will be proven in a subsequent message
+ dhMAC             [2] BIT STRING,         -- Deprecated
+ agreeMAC          [3] PKMACValue,
+ encryptedKey      [4] EnvelopedData }
+*/
+#define CRMF_POPOPRIVKEY_THISMESSAGE       0
+#define CRMF_POPOPRIVKEY_SUBSEQUENTMESSAGE 1
+#define CRMF_POPOPRIVKEY_DHMAC             2
+#define CRMF_POPOPRIVKEY_AGREEMAC          3
+#define CRMF_POPOPRIVKEY_ENCRYPTEDKEY      4
+
+#define CRMF_SUBSEQUENTMESSAGE_ENCRCERT      0
+#define CRMF_SUBSEQUENTMESSAGE_CHALLENGERESP 1
+
+typedef struct crmf_popoprivkey_st
+{
+	int type;
+	union   {
+		ASN1_BIT_STRING   *thisMessage; /* Deprecated */ /* 0 */
+		ASN1_INTEGER      *subsequentMessage; /* XXX what to do with the SEQUENCE SIZE... ? */ /* 1 */
+		ASN1_BIT_STRING   *dhMAC; /* 2 */
+		CRMF_PKMACVALUE   *agreeMAC; /* 3 */
+		CMS_ENVELOPEDDATA *encryptedKey; /* 4 */
+	} value;
+} CRMF_POPOPRIVKEY;
+DECLARE_ASN1_FUNCTIONS(CRMF_POPOPRIVKEY)
+
+/*
+PBMParameter ::= SEQUENCE {
+   salt                OCTET STRING,
+   owf                 AlgorithmIdentifier,
+   -- AlgId for a One-Way Function (SHA-1 recommended)
+   iterationCount      INTEGER,
+   -- number of times the OWF is applied
+   mac                 AlgorithmIdentifier
+   -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+}   -- or HMAC [HMAC, RFC2202])
+*/
+typedef struct crmf_pbmparameter_st
+{
+	ASN1_OCTET_STRING *salt;
+	X509_ALGOR        *owf;
+	ASN1_INTEGER      *iterationCount;
+	X509_ALGOR        *mac;
+} CRMF_PBMPARAMETER;
+DECLARE_ASN1_FUNCTIONS(CRMF_PBMPARAMETER)
+
+/*
+POPOSigningKeyInput ::= SEQUENCE {
+ authInfo            CHOICE {
+     sender              [0] GeneralName,
+     -- used only if an authenticated identity has been
+     -- established for the sender (e.g., a DN from a
+     -- previously-issued and currently-valid certificate)
+     publicKeyMAC        PKMACValue },
+     -- used if no authenticated GeneralName currently exists for
+     -- the sender; publicKeyMAC contains a password-based MAC
+     -- on the DER-encoded value of publicKey
+ publicKey           SubjectPublicKeyInfo }  -- from CertTemplate
+*/
+typedef struct crmf_poposigningkeyinput_authinfo_st
+{
+	int type;
+	union   {
+		GENERAL_NAME    *sender; /* 0 */
+		CRMF_PKMACVALUE *publicKeyMAC; /* XXX imp/exp? */ /* 1 */
+	} value;
+} CRMF_POPOSIGNINGKEYINPUT_AUTHINFO;
+DECLARE_ASN1_FUNCTIONS(CRMF_POPOSIGNINGKEYINPUT_AUTHINFO)
+
+typedef struct crmf_poposigningkeyinput_st
+{
+	CRMF_POPOSIGNINGKEYINPUT_AUTHINFO *authinfo;
+	X509_PUBKEY *publicKey;
+} CRMF_POPOSIGNINGKEYINPUT;
+DECLARE_ASN1_FUNCTIONS(CRMF_POPOSIGNINGKEYINPUT)
+
+/*
+POPOSigningKey ::= SEQUENCE {
+ poposkInput           [0] POPOSigningKeyInput OPTIONAL,
+ algorithmIdentifier   AlgorithmIdentifier,
+ signature             BIT STRING }
+ */
+
+typedef struct crmf_poposigningkey_st
+{
+	CRMF_POPOSIGNINGKEYINPUT *poposkInput;
+	X509_ALGOR               *algorithmIdentifier;
+	ASN1_BIT_STRING          *signature;
+} CRMF_POPOSIGNINGKEY;
+DECLARE_ASN1_FUNCTIONS(CRMF_POPOSIGNINGKEY)
+
+/*
+ProofOfPossession ::= CHOICE {
+ raVerified        [0] NULL,
+ -- used if the RA has already verified that the requester is in
+ -- possession of the private key
+ signature         [1] POPOSigningKey,
+ keyEncipherment   [2] POPOPrivKey,
+ keyAgreement      [3] POPOPrivKey }
+ */
+#define CRMF_PROOFOFPOSESSION_RAVERIFIED      0
+#define CRMF_PROOFOFPOSESSION_SIGNATURE       1
+#define CRMF_PROOFOFPOSESSION_KEYENCIPHERMENT 2
+#define CRMF_PROOFOFPOSESSION_KEYAGREEMENT    3
+typedef struct crmf_proofofpossesion_st
+{
+	int type;
+	union   {
+		ASN1_NULL           *raVerified; /* 0 */
+		CRMF_POPOSIGNINGKEY *signature;  /* 1 */
+		CRMF_POPOPRIVKEY    *keyEncipherment; /* 2 */
+		CRMF_POPOPRIVKEY    *keyAgreement; /* 3 */
+	} value;
+} CRMF_PROOFOFPOSSESION;
+DECLARE_ASN1_FUNCTIONS(CRMF_PROOFOFPOSSESION)
+
+/*
+OptionalValidity ::= SEQUENCE {
+ notBefore  [0] Time OPTIONAL,
+ notAfter   [1] Time OPTIONAL } -- at least one MUST be present
+ */
+typedef struct crmf_optionalvalidity_st
+{
+	ASN1_TIME *notBefore; /* 0 */
+	ASN1_TIME *notAfter;  /* 1 */
+} CRMF_OPTIONALVALIDITY;
+DECLARE_ASN1_FUNCTIONS(CRMF_OPTIONALVALIDITY)
+
+/*
+CertTemplate ::= SEQUENCE {
+ version      [0] Version               OPTIONAL,
+ serialNumber [1] INTEGER               OPTIONAL,
+ signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
+ issuer       [3] Name                  OPTIONAL,
+ validity     [4] OptionalValidity      OPTIONAL,
+ subject      [5] Name                  OPTIONAL,
+ publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
+ issuerUID    [7] UniqueIdentifier      OPTIONAL,
+ subjectUID   [8] UniqueIdentifier      OPTIONAL,
+ extensions   [9] Extensions            OPTIONAL }
+ */
+
+typedef struct crmf_certtemplate_st
+{
+	ASN1_INTEGER *version;       /* 0 */
+	/* serialNumber MUST be omitted.  This field is assigned by the CA
+	 * during certificate creation. */
+	ASN1_INTEGER *serialNumber;  /* 1 */
+	/* signingAlg MUST be omitted.  This field is assigned by the CA
+	 * during certificate creation. */
+	X509_ALGOR   *signingAlg;    /* 2 */
+	X509_NAME    *issuer;        /* 3 */
+	CRMF_OPTIONALVALIDITY *validity; /* 4 */
+	X509_NAME    *subject;       /* 5 */
+	X509_PUBKEY  *publicKey;     /* 6 */
+	/* According to rfc 3280:
+	   UniqueIdentifier  ::=  BIT STRING
+	   */
+	/* issuerUID is deprecated in version 2 */
+	ASN1_BIT_STRING *issuerUID;  /* 7 */
+	/* subjectUID is deprecated in version 2 */
+	ASN1_BIT_STRING *subjectUID; /* 8 */
+	STACK_OF(X509_EXTENSION)  *extensions; /* 9 */
+	// X509_EXTENSIONS  *extensions; /* 9 */
+
+} CRMF_CERTTEMPLATE;
+DECLARE_ASN1_FUNCTIONS(CRMF_CERTTEMPLATE)
+
+/*
+CertRequest ::= SEQUENCE {
+ certReqId     INTEGER,          -- ID for matching request and reply
+ certTemplate  CertTemplate,  -- Selected fields of cert to be issued
+ controls      Controls OPTIONAL }   -- Attributes affecting issuance
+ */
+typedef struct crmf_certrequest_st
+{
+	ASN1_INTEGER      *certReqId;
+	CRMF_CERTTEMPLATE *certTemplate;
+	STACK_OF(CRMF_ATTRIBUTETYPEANDVALUE) *controls;
+} CRMF_CERTREQUEST;
+DECLARE_ASN1_FUNCTIONS(CRMF_CERTREQUEST)
+CRMF_CERTREQUEST *CRMF_CERTREQUEST_dup( CRMF_CERTREQUEST *atav);
+
+typedef struct crmf_attributetypeandvalue_st
+{
+	ASN1_OBJECT *type;
+	union {
+		/* NID_id_regCtrl_regToken */ 
+		ASN1_UTF8STRING *regToken;
+
+		/* NID_id_regCtrl_authenticator */ 
+		ASN1_UTF8STRING *authenticator;
+
+		/* NID_id_regCtrl_pkiPublicationInfo */
+		CRMF_PKIPUBLICATIONINFO *pkiPublicationInfo;
+
+		/* NID_id_regCtrl_pkiArchiveOptions */ 
+		CRMF_PKIARCHIVEOPTIONS *pkiArchiveOptions;
+
+		/* NID_id_regCtrl_oldCertID */
+		CRMF_CERTID     *oldCertId;
+
+		/* NID_id_regCtrl_protocolEncrKey */
+		X509_PUBKEY     *protocolEncrKey;
+
+		/* NID_id_regInfo_utf8Pairs */ 
+		ASN1_UTF8STRING *utf8pairs;
+
+		/* NID_id_regInfo_certReq */ 
+		CRMF_CERTREQUEST *certReq;
+
+		ASN1_TYPE *other;
+	} value;
+} CRMF_ATTRIBUTETYPEANDVALUE;
+DECLARE_ASN1_FUNCTIONS(CRMF_ATTRIBUTETYPEANDVALUE)
+DECLARE_STACK_OF(CRMF_ATTRIBUTETYPEANDVALUE)
+CRMF_ATTRIBUTETYPEANDVALUE *CRMF_ATTRIBUTETYPEANDVALUE_dup( CRMF_ATTRIBUTETYPEANDVALUE *atav);
+
+/*
+CertReqMessages ::= SEQUENCE SIZE (1..MAX) OF CertReqMsg
+
+CertReqMsg ::= SEQUENCE {
+ certReq   CertRequest,
+ popo       ProofOfPossession  OPTIONAL,
+ -- content depends upon key type
+ regInfo   SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue OPTIONAL }
+ */
+typedef struct crmf_certreqmsg_st
+{
+	CRMF_CERTREQUEST           *certReq;
+	CRMF_PROOFOFPOSSESION      *popo;    /* 0 */
+	STACK_OF(CRMF_ATTRIBUTETYPEANDVALUE) *regInfo; /* 1 */
+} CRMF_CERTREQMSG;
+DECLARE_ASN1_FUNCTIONS(CRMF_CERTREQMSG)
+
+#if 0
+typedef STACK_OF(CRMF_CERTREQMSG) CRMF_CERTREQMESSAGES;
+DECLARE_ASN1_FUNCTIONS(CRMF_CERTREQMESSAGES);
+#endif 
+DECLARE_STACK_OF(CRMF_CERTREQMSG) /* CertReqMessages */
+DECLARE_ASN1_SET_OF(CRMF_CERTREQMSG) /* CertReqMessages */
+
+
+/* DECLARATIONS */
+/* crmf_msg.c */
+CRMF_CERTREQMSG * CRMF_cr_new( const long certReqId, const EVP_PKEY *pkey, const X509_NAME *subject, const int compatibility, int popoMethod, X509_EXTENSIONS *extensions);
+
+/* crmf_pbm.c */
+CRMF_PBMPARAMETER * CRMF_pbm_new(void);
+int CRMF_passwordBasedMac_new( const CRMF_PBMPARAMETER *pbm,
+                           const unsigned char* msg, size_t msgLen,
+                           const unsigned char* secret, size_t secretLen,
+                           unsigned char** mac, unsigned int* macLen);
+
+
+/* crmf_lib.c */
+int CRMF_CERTREQMSG_push0_control( CRMF_CERTREQMSG *certReqMsg, CRMF_ATTRIBUTETYPEANDVALUE *control);
+int CRMF_CERTREQMSG_push1_control( CRMF_CERTREQMSG *certReqMsg, CRMF_ATTRIBUTETYPEANDVALUE *control);
+int CRMF_CERTREQMSG_set1_control_regToken( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *tok);
+int CRMF_CERTREQMSG_set1_control_authenticator( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *auth);
+int CRMF_CERTREQMSG_push0_regInfo( CRMF_CERTREQMSG *certReqMsg, CRMF_ATTRIBUTETYPEANDVALUE *regInfo);
+int CRMF_CERTREQMSG_set1_regInfo_regToken( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *tok);
+
+int CRMF_CERTREQMSG_set_version2( CRMF_CERTREQMSG *certReqMsg);
+int CRMF_CERTREQMSG_set_validity( CRMF_CERTREQMSG *certReqMsg, time_t notBefore, time_t notAfter);
+int CRMF_CERTREQMSG_set_certReqId( CRMF_CERTREQMSG *certReqMsg, const long certReqId);
+int CRMF_CERTREQMSG_set1_publicKey( CRMF_CERTREQMSG *certReqMsg, const EVP_PKEY *pkey);
+int CRMF_CERTREQMSG_set1_subject( CRMF_CERTREQMSG *certReqMsg, const X509_NAME *subject);
+int CRMF_CERTREQMSG_push0_extension( CRMF_CERTREQMSG *certReqMsg, X509_EXTENSION *ext);
+
+int CRMF_CERTREQMSG_calc_and_set_popo( CRMF_CERTREQMSG *certReqMsg, const EVP_PKEY *pkey, int popoMethod);
+
+CRMF_POPOSIGNINGKEY * CRMF_poposigningkey_new( CRMF_CERTREQUEST *certReq, const EVP_PKEY *pkey);
+
+int CRMF_CERTREQMSG_set1_control_oldCertId( CRMF_CERTREQMSG *certReqMsg, X509 *oldCert);
+
+/* crmf_atav.c */
+void CRMF_ATTRIBUTETYPEANDVALUE_get0(ASN1_OBJECT **paobj, int *pptype, void **ppval, CRMF_ATTRIBUTETYPEANDVALUE *atav);
+int CRMF_ATTRIBUTETYPEANDVALUE_set0(CRMF_ATTRIBUTETYPEANDVALUE *atav, ASN1_OBJECT *aobj, int ptype, void *pval);
+int CRMF_ATTRIBUTETYPEANDVALUE_set0_nid_utf8string( CRMF_ATTRIBUTETYPEANDVALUE *atav, int nid, ASN1_UTF8STRING *utf8str);
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_CRMF_strings(void);
+
+/* Error codes for the CRMF functions. */
+
+/* Function codes. */
+#define CRMF_F_CRMF_CERTREQMSG_PUSH0_CONTROL		 100
+#define CRMF_F_CRMF_CERTREQMSG_PUSH0_EXTENSION		 101
+#define CRMF_F_CRMF_CERTREQMSG_PUSH0_REGINFO		 102
+#define CRMF_F_CRMF_CERTREQMSG_SET1_PUBLICKEY		 103
+#define CRMF_F_CRMF_CERTREQMSG_SET_VALIDITY		 104
+#define CRMF_F_CRMF_CR_NEW				 105
+#define CRMF_F_CRMF_PASSWORDBASEDMAC_NEW		 106
+
+/* Reason codes. */
+#define CRMF_R_CRMFERROR				 100
+#define CRMF_R_ERROR_SETTING_PUBLIC_KEY			 101
+#define CRMF_R_UNSUPPORTED_ALGORITHM			 102
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
Index: openssl-1.0.0i-cmp/crypto/crmf/crmf_lib.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/crmf/crmf_lib.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/crmf/crmf_lib.c	(revision 469)
@@ -0,0 +1,678 @@
+/* crypto/crmf/crmf_lib.c
+ * CRMF (RFC 4211) library functions for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ */
+
+ /* NAMING
+  * The 0 version uses the supplied structure pointer directly in the parent and 
+  * it will be freed up when the parent is freed. In the above example crl would 
+  * be freed but rev would not.
+  *
+  * The 1 function uses a copy of the supplied structure pointer (or in some 
+  * cases increases its link count) in the parent and so both (x and obj above) 
+  * should be freed up. 
+ */
+
+/* ############################################################################ *
+ * In this file are the functions which set the individual items inside         *
+ * the CRMF structures                                                          *
+ * ############################################################################ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/cmp.h>
+#include <openssl/crmf.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+
+/* ############################################################################ *
+ * Pushes the given control attribute into the controls stack of a CertRequest
+ * ############################################################################ */
+int CRMF_CERTREQMSG_push0_control( CRMF_CERTREQMSG *certReqMsg, CRMF_ATTRIBUTETYPEANDVALUE *control) {
+	int newControls = 0;
+
+	if( !certReqMsg) return 0;
+	if( !control) return 0;
+
+	if( !(certReqMsg->certReq->controls)) {
+		/* OPTIONAL, not initialized yet */
+		if( !(certReqMsg->certReq->controls = sk_CRMF_ATTRIBUTETYPEANDVALUE_new_null())) 
+			return 0;
+		newControls = 1;
+	}
+	if( !sk_CRMF_ATTRIBUTETYPEANDVALUE_push( certReqMsg->certReq->controls, control)) goto err;
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_PUSH0_CONTROL, CRMF_R_CRMFERROR);
+
+	if( newControls) {
+		sk_CRMF_ATTRIBUTETYPEANDVALUE_pop_free(certReqMsg->certReq->controls, CRMF_ATTRIBUTETYPEANDVALUE_free);
+		certReqMsg->certReq->controls = NULL;
+	}
+	return 0;
+}
+
+/* ############################################################################ *
+ * Same as above, except here the given control is duplicated so the pointer is
+ * not directly used here.
+ * ############################################################################ */
+int CRMF_CERTREQMSG_push1_control( CRMF_CERTREQMSG *certReqMsg, CRMF_ATTRIBUTETYPEANDVALUE *control) {
+	CRMF_ATTRIBUTETYPEANDVALUE * controlDup=NULL;
+
+	if( !certReqMsg) return 0;
+	if( !control) return 0;
+
+	controlDup = CRMF_ATTRIBUTETYPEANDVALUE_dup( control);
+
+	if( !CRMF_CERTREQMSG_push0_control( certReqMsg, controlDup)) goto err;
+	controlDup = NULL;
+
+	return 1;
+err:
+	if( controlDup) CRMF_ATTRIBUTETYPEANDVALUE_free( controlDup);
+	return 0;
+}
+
+
+/* ############################################################################ *
+ * Pushes the attribute given in regInfo in to the CertReqMsg->regInfo stack.
+ * ############################################################################ */
+int CRMF_CERTREQMSG_push0_regInfo( CRMF_CERTREQMSG *certReqMsg, CRMF_ATTRIBUTETYPEANDVALUE *regInfo) {
+	int newRegInfo = 0;
+
+	if( !certReqMsg) return 0;
+	if( !regInfo) return 0;
+
+	if( !(certReqMsg->regInfo)) {
+		/* OPTIONAL, not initialized yet */
+		if( !(certReqMsg->regInfo = sk_CRMF_ATTRIBUTETYPEANDVALUE_new_null())) 
+			return 0;
+		newRegInfo = 1;
+	}
+	if( !sk_CRMF_ATTRIBUTETYPEANDVALUE_push( certReqMsg->regInfo, regInfo)) goto err;
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_PUSH0_REGINFO, CRMF_R_CRMFERROR);
+
+	if( newRegInfo) {
+		sk_CRMF_ATTRIBUTETYPEANDVALUE_pop_free(certReqMsg->regInfo, CRMF_ATTRIBUTETYPEANDVALUE_free);
+		certReqMsg->regInfo = NULL;
+	}
+	return 0;
+}
+
+/* ############################################################################ *
+ * Creates a new control attribute of type NID_id_regCtrl_oldCertID and adds
+ * it to the control stack of the given certReqMesg.
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_oldCertId( CRMF_CERTREQMSG *certReqMsg, X509 *oldCert) { 
+	CRMF_ATTRIBUTETYPEANDVALUE *atav   = NULL;
+	CRMF_CERTID                *certId = NULL;
+	GENERAL_NAME               *gName  = NULL;
+
+	if ( !certReqMsg) goto err;
+	if ( !oldCert) goto err;
+
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())
+			|| !(certId = CRMF_CERTID_new())
+			|| !(gName = GENERAL_NAME_new()))
+		goto err;
+
+	/* note: X509_NAME_set does not consume the pointer so this is ok */
+	X509_NAME_set( &gName->d.directoryName, X509_get_issuer_name( oldCert));
+	gName->type = GEN_DIRNAME;
+	certId->issuer = gName;
+	certId->serialNumber = ASN1_INTEGER_dup(X509_get_serialNumber(oldCert));
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_oldCertID);
+	atav->value.oldCertId = certId;
+
+	if (!CRMF_CERTREQMSG_push0_control( certReqMsg, atav)) goto err;
+
+	return 1;
+err:
+	if (gName) GENERAL_NAME_free(gName);
+	if (certId) CRMF_CERTID_free(certId);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+}
+
+
+/* ############################################################################ *
+ * Creates a new regToken attribute and adds it to the controls stack of the
+ * given CertReqMsg.
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_regToken( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *tok) {
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+	ASN1_UTF8STRING *tokDup=NULL;
+
+	if (!msg) return 0;
+	if (!tok) return 0;
+
+	if (!(tokDup = ASN1_STRING_dup( tok))) goto err;
+	
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_regToken);
+	atav->value.regToken = tokDup;
+	tokDup = NULL;
+
+	if( !CRMF_CERTREQMSG_push0_control( msg, atav)) goto err;
+	atav = NULL;
+	
+	return 1;
+err:
+	if (tokDup) ASN1_UTF8STRING_free( tokDup);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+}
+
+/* ############################################################################ *
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_authenticator( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *auth) {
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+	ASN1_UTF8STRING *authDup=NULL;
+
+	if (!msg) return 0;
+	if (!auth) return 0;
+
+	if (!(authDup = ASN1_STRING_dup( auth))) goto err;
+	
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_authenticator);
+	atav->value.regToken = authDup;
+	authDup = NULL;
+	if( !CRMF_CERTREQMSG_push0_control( msg, atav)) goto err;
+	atav = NULL;
+	
+	return 1;
+err:
+	if (authDup) ASN1_UTF8STRING_free( authDup);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+}
+
+/* ############################################################################ *
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_pkiPublicationInfo( CRMF_CERTREQMSG *msg, CRMF_PKIPUBLICATIONINFO *pubinfo) {
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+	CRMF_PKIPUBLICATIONINFO *pubinfoDup=NULL;
+
+	if (!msg) return 0;
+	if (!pubinfo) return 0;
+
+	if (!(pubinfoDup = CRMF_PKIPUBLICATIONINFO_dup( pubinfo))) goto err;
+	
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_pkiPublicationInfo);
+	atav->value.pkiPublicationInfo = pubinfoDup;
+	pubinfoDup = NULL;
+	if( !CRMF_CERTREQMSG_push0_control( msg, atav)) goto err;
+	atav = NULL;
+	
+	return 1;
+err:
+	if (pubinfoDup) CRMF_PKIPUBLICATIONINFO_free( pubinfoDup);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+}
+
+/* ############################################################################ */
+/* ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_pkiArchiveOptions( CRMF_CERTREQMSG *msg, CRMF_PKIARCHIVEOPTIONS *archopts) {
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+	CRMF_PKIARCHIVEOPTIONS *archoptsDup=NULL;
+
+	if (!msg) return 0;
+	if (!archopts) return 0;
+
+	if (!(archoptsDup = CRMF_PKIARCHIVEOPTIONS_dup( archopts))) goto err;
+	
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_pkiArchiveOptions);
+	atav->value.pkiArchiveOptions = archoptsDup;
+	archoptsDup = NULL;
+	if( !CRMF_CERTREQMSG_push0_control( msg, atav)) goto err;
+	atav = NULL;
+	
+	return 1;
+err:
+	if (archoptsDup) CRMF_PKIARCHIVEOPTIONS_free( archoptsDup);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+}
+
+/* For some reason X509_PUBKEY_dup() does not appear to be implemented by 
+ * OpenSSL's X509 code, so we implement it here. It's only needed in the following
+ * function so it can be declared static. */
+static IMPLEMENT_ASN1_DUP_FUNCTION(X509_PUBKEY);
+
+/* ############################################################################ *
+ * Makes a copy of the given public key and adds it to the controls stack as
+ * the protocolEncrKey type.
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_control_protocolEncrKey( CRMF_CERTREQMSG *msg, X509_PUBKEY *pubkey) {	
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+	X509_PUBKEY *pubkeyDup=NULL;
+
+	if (!msg) return 0;
+	if (!pubkey) return 0;
+
+	if (!(pubkeyDup = X509_PUBKEY_dup(pubkey))) goto err;
+
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_protocolEncrKey);
+	atav->value.protocolEncrKey = pubkeyDup;
+	if( !CRMF_CERTREQMSG_push0_control( msg, atav)) goto err;
+	atav = NULL;
+	
+	return 1;
+err:
+	if (pubkeyDup) X509_PUBKEY_free(pubkeyDup);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+}
+
+	
+/* ############################################################################ */
+
+/* REGINFO */
+/* ############################################################################ *
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_regInfo_utf8Pairs( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *utf8pairs) {
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+	ASN1_UTF8STRING *utf8pairsDup=NULL;
+
+	if (!msg) return 0;
+	if (!utf8pairs) return 0;
+
+	if (!(utf8pairsDup = ASN1_STRING_dup( utf8pairs))) goto err;
+	
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regInfo_utf8Pairs);
+	atav->value.utf8pairs = utf8pairsDup;
+	utf8pairsDup = NULL;
+
+	if( !CRMF_CERTREQMSG_push0_regInfo( msg, atav)) goto err;
+	atav = NULL;
+	
+	return 1;
+err:
+	if (utf8pairsDup) ASN1_UTF8STRING_free( utf8pairsDup);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+}
+
+/* ############################################################################ *
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_regInfo_regToken( CRMF_CERTREQMSG *msg, ASN1_UTF8STRING *tok) {
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+	ASN1_UTF8STRING *tokDup=NULL;
+
+	if (!msg) return 0;
+	if (!tok) return 0;
+
+	if (!(tokDup = ASN1_STRING_dup( tok))) goto err;
+	
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regCtrl_regToken);
+	atav->value.regToken = tokDup;
+	tokDup = NULL;
+
+	if( !CRMF_CERTREQMSG_push0_regInfo( msg, atav)) goto err;
+	atav = NULL;
+	
+	return 1;
+err:
+	if (tokDup) ASN1_UTF8STRING_free( tokDup);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+}
+
+/* ############################################################################ *
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_regInfo_certReq( CRMF_CERTREQMSG *msg, CRMF_CERTREQUEST *certReq) {
+	CRMF_ATTRIBUTETYPEANDVALUE *atav=NULL;
+	CRMF_CERTREQUEST *certReqDup=NULL;
+
+	if (!msg) return 0;
+	if (!certReq) return 0;
+
+	if (!(certReqDup = CRMF_CERTREQUEST_dup( certReq))) goto err;
+	
+	if (!(atav = CRMF_ATTRIBUTETYPEANDVALUE_new())) goto err;
+
+	atav->type = OBJ_nid2obj(NID_id_regInfo_certReq);
+	atav->value.certReq = (CRMF_CERTREQUEST*) certReqDup;
+	certReqDup = NULL;
+
+	if( !CRMF_CERTREQMSG_push0_regInfo( msg, atav)) goto err;
+	atav = NULL;
+	
+	return 1;
+err:
+	if (certReqDup) CRMF_CERTREQUEST_free( certReqDup);
+	if (atav) CRMF_ATTRIBUTETYPEANDVALUE_free( atav);
+	return 0;
+}
+
+
+/* ############################################################################ */
+
+/* CERTTEMPLATE */
+/* ############################################################################ *
+ * CertRequest syntax:
+ * version MUST be 2 if supplied.  It SHOULD be omitted.
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set_version2( CRMF_CERTREQMSG *certReqMsg) {
+	if (! certReqMsg) return 0;
+
+	if (! certReqMsg->certReq->certTemplate->version)
+		/* OPTIONAL, not initialized yet */
+		certReqMsg->certReq->certTemplate->version = ASN1_INTEGER_new();
+	ASN1_INTEGER_set( certReqMsg->certReq->certTemplate->version, 2L);
+	return 1;
+}
+
+/* ############################################################################ */
+/* returns 1 on success, 0 on error */
+/* sets notBefore and/or notAfter in certTemplate of the given certreqmsg - if they are not given as 0 */
+/* ############################################################################ */
+int CRMF_CERTREQMSG_set_validity( CRMF_CERTREQMSG *certReqMsg, time_t notBefore, time_t notAfter) {
+	CRMF_OPTIONALVALIDITY *validity=NULL;
+	ASN1_TIME *notBeforeAsn=NULL;
+	ASN1_TIME *notAfterAsn=NULL;
+
+	if (! certReqMsg) return 0;
+
+	if (notBefore) {
+		if( !(notBeforeAsn = ASN1_TIME_set(NULL, notBefore))) goto err;
+	}
+	if (notAfter) {
+		if( !(notAfterAsn = ASN1_TIME_set(NULL, notAfter))) goto err;
+	}
+	if (!(validity = CRMF_OPTIONALVALIDITY_new())) goto err;
+
+	validity->notBefore = notBeforeAsn;
+	validity->notAfter  = notAfterAsn;
+
+	certReqMsg->certReq->certTemplate->validity = validity;
+
+	return 1;
+err:
+    CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET_VALIDITY, CRMF_R_CRMFERROR);
+
+	if (validity) CRMF_OPTIONALVALIDITY_free(validity);
+	if (notBeforeAsn) ASN1_TIME_free(notBeforeAsn);
+	if (notAfterAsn) ASN1_TIME_free(notAfterAsn);
+	return 0;
+}
+
+/* ############################################################################ */
+/* set the certReqId */
+/*
+      certReqId contains an integer value that is used by the
+      certificate requestor to associate a specific certificate request
+      with a certificate response.
+*/
+/* ############################################################################ */
+int CRMF_CERTREQMSG_set_certReqId( CRMF_CERTREQMSG *certReqMsg, const long certReqId) {
+	if (! certReqMsg) return 0;
+
+	return ASN1_INTEGER_set(certReqMsg->certReq->certReqId, certReqId);
+}
+
+/* ############################################################################ */
+/* set the public Key */
+/* ############################################################################ */
+int CRMF_CERTREQMSG_set1_publicKey( CRMF_CERTREQMSG *certReqMsg, const EVP_PKEY *pkey) {
+	if (! certReqMsg) goto err;
+	if (! pkey) goto err;
+
+	/* this function is *not* consuming the pointer */
+	return X509_PUBKEY_set(&(certReqMsg->certReq->certTemplate->publicKey), (EVP_PKEY*) pkey);
+
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_SET1_PUBLICKEY, CRMF_R_CRMFERROR);
+	return 0;
+}
+
+/* ############################################################################ *
+ * Set the subject name in the given certificate template 
+ * ############################################################################ */
+int CRMF_CERTREQMSG_set1_subject( CRMF_CERTREQMSG *certReqMsg, const X509_NAME *subject) {
+	if (! certReqMsg) return 0;
+	if (! subject) return 0;
+
+	/* this function is *not* consuming the pointer */
+	return X509_NAME_set(&(certReqMsg->certReq->certTemplate->subject), (X509_NAME*) subject);
+}
+
+/* ############################################################################ *
+ * returns 1 on success, 0 on error
+ * push an extension to the extension stack
+ * ############################################################################ */
+int CRMF_CERTREQMSG_push0_extension( CRMF_CERTREQMSG *certReqMsg, X509_EXTENSION *ext) {
+	int createdStack = 0;
+
+	if (! certReqMsg) goto err;
+	if (! ext) goto err;
+
+	if (! certReqMsg->certReq->certTemplate->extensions) {
+		if( !(certReqMsg->certReq->certTemplate->extensions = sk_X509_EXTENSION_new_null())) 
+			goto err;
+		createdStack = 1;
+	}
+
+	if( !sk_X509_EXTENSION_push(certReqMsg->certReq->certTemplate->extensions, ext)) goto err;
+	return 1;
+err:
+	CRMFerr(CRMF_F_CRMF_CERTREQMSG_PUSH0_EXTENSION, CRMF_R_CRMFERROR);
+
+	if (createdStack) {
+		sk_X509_EXTENSION_pop_free( certReqMsg->certReq->certTemplate->extensions, X509_EXTENSION_free);
+		certReqMsg->certReq->certTemplate->extensions = NULL;
+	}
+	return 0;
+}
+
+/* ############################################################################ */
+/* TODO check */
+/*
+   1.  The certificate subject has not yet established an authenticated
+       identity with a CA/RA, but has a password and identity string
+       from the CA/RA.  In this case, the POPOSigningKeyInput structure
+       would be filled out using the publicKeyMAC choice for authInfo,
+       and the password and identity would be used to compute the
+       publicKeyMAC value.  The public key for the certificate being
+       requested would be placed in both the POPOSigningKeyInput and the
+       Certificate Template structures.  The signature field is computed
+       over the DER-encoded POPOSigningKeyInput structure.
+       */
+/*
+      poposkInput contains the data to be signed, when present.  This
+      field MUST be present when the certificate template does not
+      contain both the public key value and a subject name value.
+
+      algorithmIdentifier identifiers the signature algorithm and an
+      associated parameters used to produce the POP value.
+
+      signature contains the POP value produce.  If poposkInput is
+      present, the signature is computed over the DER-encoded value of
+      poposkInput.  If poposkInput is absent, the signature is computed
+      over the DER-encoded value of certReq.
+      */
+/* ############################################################################ *
+ * Create proof-of-posession information by signing the certrequest with our 
+ * private key. Algorithm is chosen based on key type.
+ * ############################################################################ */
+CRMF_POPOSIGNINGKEY * CRMF_poposigningkey_new( CRMF_CERTREQUEST *certReq, const EVP_PKEY *pkey) {
+	CRMF_POPOSIGNINGKEY *poposig=NULL;
+	size_t certReqSize, maxSignatureSize;
+	unsigned int sigLen;
+	unsigned char *certReqDer=NULL;
+	unsigned char *signature=NULL;
+	const EVP_MD *alg=NULL;
+
+	EVP_MD_CTX *ctx=NULL;
+
+	/* TODO: what about PoposkInput? */
+	if( !(poposig = CRMF_POPOSIGNINGKEY_new())) goto err;
+	/* get DER representation */
+	certReqSize = i2d_CRMF_CERTREQUEST( certReq, &certReqDer);
+
+	maxSignatureSize = EVP_PKEY_size( (EVP_PKEY*) pkey);
+	signature = OPENSSL_malloc(maxSignatureSize);
+
+	/* set the type of the algorithm */
+	if (EVP_PKEY_type(pkey->type) == EVP_PKEY_DSA) {
+		X509_ALGOR_set0(poposig->algorithmIdentifier, OBJ_nid2obj(NID_dsaWithSHA1), V_ASN1_NULL, NULL);
+		alg = EVP_dss1();
+	}
+	/* XXX can it be some other type of key? */
+	else { /* assume RSA */
+		X509_ALGOR_set0(poposig->algorithmIdentifier, OBJ_nid2obj(NID_sha1WithRSAEncryption), V_ASN1_NULL, NULL);
+		alg = EVP_sha1();
+	}
+
+	ctx=EVP_MD_CTX_create();
+	if (!(EVP_SignInit_ex(ctx, alg, NULL))) goto err;
+	if (!(EVP_SignUpdate(ctx, certReqDer, certReqSize))) goto err;
+	if (!(EVP_SignFinal(ctx, signature, &sigLen, (EVP_PKEY*) pkey))) goto err;
+
+	/* set the signature value */
+	if (!(ASN1_BIT_STRING_set( poposig->signature, signature, sigLen))) goto err;
+
+	/* Actually this should not be needed but OpenSSL defaults all bitstrings to be a NamedBitList */
+	poposig->signature->flags &= ~0x07;
+	poposig->signature->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+
+	/* cleanup */
+	OPENSSL_free(certReqDer);
+	EVP_MD_CTX_destroy(ctx);
+	OPENSSL_free(signature);
+	return poposig;
+err:
+	if( poposig) CRMF_POPOSIGNINGKEY_free( poposig);
+	if( certReqDer) OPENSSL_free(certReqDer);
+	if( ctx) EVP_MD_CTX_destroy(ctx);
+	if( signature) OPENSSL_free(signature);
+	return NULL;
+}
+
+/* ############################################################################ *
+ * calculate and set the proof of possession
+ * ############################################################################ */
+int CRMF_CERTREQMSG_calc_and_set_popo( CRMF_CERTREQMSG *certReqMsg, const EVP_PKEY *pkey, int popoMethod) {
+	CRMF_PROOFOFPOSSESION *newPopo=NULL;
+
+	if (! certReqMsg) return 0;
+	if (! pkey) return 0;
+
+	if( !(newPopo = CRMF_PROOFOFPOSSESION_new())) goto err;
+
+	switch (popoMethod) {
+		case CMP_POPO_SIGNATURE:
+			newPopo->value.signature = CRMF_poposigningkey_new( certReqMsg->certReq, pkey);
+			if( !(newPopo->value.signature)) goto err;
+			newPopo->type = CRMF_PROOFOFPOSESSION_SIGNATURE;
+			break;
+
+		case CMP_POPO_ENCRCERT:
+			newPopo->type = CRMF_PROOFOFPOSESSION_KEYENCIPHERMENT;
+			newPopo->value.keyEncipherment = CRMF_POPOPRIVKEY_new();
+
+			newPopo->value.keyEncipherment->type = CRMF_POPOPRIVKEY_SUBSEQUENTMESSAGE;
+			
+			newPopo->value.keyEncipherment->value.subsequentMessage = ASN1_INTEGER_new();
+			ASN1_INTEGER_set(newPopo->value.keyEncipherment->value.subsequentMessage, CRMF_SUBSEQUENTMESSAGE_ENCRCERT);
+			break;
+
+		default: goto err;
+	}
+
+	if(certReqMsg->popo) 
+		/* OPTIONAL, initialized before */
+		CRMF_PROOFOFPOSSESION_free(certReqMsg->popo);
+	certReqMsg->popo = newPopo;
+
+	CMP_printf("INFO: proof-of-posession set\n");
+
+	return 1;
+err:
+	if( newPopo) CRMF_PROOFOFPOSSESION_free( newPopo);
+	return 0;
+}
+
Index: openssl-1.0.0i-cmp/crypto/crmf/crmf_msg.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/crmf/crmf_msg.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/crmf/crmf_msg.c	(revision 469)
@@ -0,0 +1,150 @@
+/* crypto/crmf/crmf_msg.c
+ * Functions for creating CRMF (RFC 4211) messages for OpenSSL
+ */
+/* ====================================================================
+ * Originally written by Martin Peylo for the OpenSSL project.
+ * <martin dot peylo at nsn dot com>
+ * 2010-2012 Miikka Viljanen <mviljane@users.sourceforge.net>
+ */
+/* ====================================================================
+ * Copyright (c) 2007-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2007-2010 Nokia Siemens Networks Oy. ALL RIGHTS RESERVED.
+ * CMP support in OpenSSL originally developed by 
+ * Nokia Siemens Networks for contribution to the OpenSSL project.
+ */
+
+/* =========================== CHANGE LOG =============================
+ * 2007 - Martin Peylo - Initial Creation
+ */
+
+/* ############################################################################ */
+/* In this file are the functions which build and evaluate the CRMF messages    */
+/* ############################################################################ */
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/crmf.h>
+#include <openssl/evp.h>
+#include <openssl/cmp.h> /* for the CMP_COMPAT_* flags */
+#include <openssl/err.h>
+#include <openssl/x509.h>
+#include <string.h>
+
+
+/* ############################################################################ */
+/* XXX is the naming of this function sane? Is it too connected to CMP? */
+/* TODO there are some optional settings which are not cared for right now */
+CRMF_CERTREQMSG * CRMF_cr_new( const long certReqId, const EVP_PKEY *pkey, const X509_NAME *subject, const int compatibility, int popoMethod, X509_EXTENSIONS *extensions) {
+	CRMF_CERTREQMSG *certReqMsg;
+	int i;
+
+	if( !(certReqMsg = CRMF_CERTREQMSG_new())) goto err;
+
+	/* version MUST be 2 if supplied.  It SHOULD be omitted. */
+	/* CRMF_CERTREQMSG_set_version2( certReqMsg); */
+
+#if 0
+	/* serialNumber MUST be ommited - INSTA does it but it does *NOT require* it */
+	if( 
+      (compatibility == CMP_COMPAT_INSTA_3_3)) {
+		certReqMsg->certReq->certTemplate->serialNumber = ASN1_INTEGER_new();
+		ASN1_INTEGER_set( certReqMsg->certReq->certTemplate->serialNumber, 0L);
+#warning serialNumber for INSTA is hardcoded
+	}
+
+	/* signingAlg MUST be ommited - INSTA does it but it does *NOT require* it */
+	if( 
+      (compatibility == CMP_COMPAT_INSTA_3_3)) {
+		certReqMsg->certReq->certTemplate->signingAlg = X509_ALGOR_new();
+		X509_ALGOR_set0( certReqMsg->certReq->certTemplate->signingAlg, OBJ_nid2obj(NID_sha1WithRSAEncryption), V_ASN1_NULL, NULL);
+#warning signingAlg for INSTA is hardcoded
+	}
+#endif
+
+	CRMF_CERTREQMSG_set_certReqId( certReqMsg, certReqId);
+	if (!CRMF_CERTREQMSG_set1_publicKey( certReqMsg, pkey)) {
+		CRMFerr(CRMF_F_CRMF_CR_NEW, CRMF_R_ERROR_SETTING_PUBLIC_KEY);
+		goto err;
+	}
+
+#if 0
+	/* CL supports this (for client certificates) for up to 3 years in the future for both dates
+	 * in case the notBefore date is in the past it will be set to the current date without any comment */
+	int CRMF_CERTREQMSG_set_validity( CRMF_CERTREQMSG *certReqMsg, time_t notBefore, time_t notAfter);
+#endif
+	CRMF_CERTREQMSG_set1_subject( certReqMsg, subject);
+
+#if 0
+	/* this could be done here */
+	int CRMF_CERTREQMSG_push0_extension( CRMF_CERTREQMSG *certReqMsg, X509_EXTENSION *ext);
+#endif
+
+	/* sk_X509_EXTENSION_num will return -1 if extensions is NULL so this is ok */
+	for (i = 0; i < sk_X509_EXTENSION_num(extensions); i++)
+		/* X509v3_add_ext will allocate new stack if there isn't one already */
+		X509v3_add_ext(&certReqMsg->certReq->certTemplate->extensions, sk_X509_EXTENSION_value(extensions, i), i);
+
+
+	if (popoMethod != CMP_POPO_NONE)
+		CRMF_CERTREQMSG_calc_and_set_popo( certReqMsg, pkey, popoMethod);
+
+	return certReqMsg;
+err:
+	CRMFerr(CRMF_F_CRMF_CR_NEW, CRMF_R_CRMFERROR);
+	if( certReqMsg)
+		CRMF_CERTREQMSG_free( certReqMsg);
+	return NULL;
+}
+
Index: openssl-1.0.0i-cmp/crypto/crmf/crmf_err.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/crmf/crmf_err.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/crmf/crmf_err.c	(revision 469)
@@ -0,0 +1,103 @@
+/* crypto/crmf/crmf_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2010 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/* NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/crmf.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+#define ERR_FUNC(func) ERR_PACK(ERR_LIB_CRMF,func,0)
+#define ERR_REASON(reason) ERR_PACK(ERR_LIB_CRMF,0,reason)
+
+static ERR_STRING_DATA CRMF_str_functs[]=
+	{
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_PUSH0_CONTROL),	"CRMF_CERTREQMSG_push0_control"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_PUSH0_EXTENSION),	"CRMF_CERTREQMSG_push0_extension"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_PUSH0_REGINFO),	"CRMF_CERTREQMSG_push0_regInfo"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET1_PUBLICKEY),	"CRMF_CERTREQMSG_set1_publicKey"},
+{ERR_FUNC(CRMF_F_CRMF_CERTREQMSG_SET_VALIDITY),	"CRMF_CERTREQMSG_set_validity"},
+{ERR_FUNC(CRMF_F_CRMF_CR_NEW),	"CRMF_cr_new"},
+{ERR_FUNC(CRMF_F_CRMF_PASSWORDBASEDMAC_NEW),	"CRMF_passwordBasedMac_new"},
+{0,NULL}
+	};
+
+static ERR_STRING_DATA CRMF_str_reasons[]=
+	{
+{ERR_REASON(CRMF_R_CRMFERROR)            ,"crmferror"},
+{ERR_REASON(CRMF_R_ERROR_SETTING_PUBLIC_KEY),"error setting public key"},
+{ERR_REASON(CRMF_R_UNSUPPORTED_ALGORITHM),"unsupported algorithm"},
+{0,NULL}
+	};
+
+#endif
+
+void ERR_load_CRMF_strings(void)
+	{
+#ifndef OPENSSL_NO_ERR
+
+	if (ERR_func_error_string(CRMF_str_functs[0].error) == NULL)
+		{
+		ERR_load_strings(0,CRMF_str_functs);
+		ERR_load_strings(0,CRMF_str_reasons);
+		}
+#endif
+	}
Index: openssl-1.0.0i-cmp/crypto/crmf/rfc4211.txt
===================================================================
--- openssl-1.0.0i-cmp/crypto/crmf/rfc4211.txt	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/crmf/rfc4211.txt	(revision 469)
@@ -0,0 +1,2243 @@
+
+
+
+
+
+
+Network Working Group                                          J. Schaad
+Request for Comments: 4211                       Soaring Hawk Consulting
+Obsoletes: 2511                                           September 2005
+Category: Standards Track
+
+
+               Internet X.509 Public Key Infrastructure
+               Certificate Request Message Format (CRMF)
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2005).
+
+Abstract
+
+   This document describes the Certificate Request Message Format (CRMF)
+   syntax and semantics.  This syntax is used to convey a request for a
+   certificate to a Certification Authority (CA), possibly via a
+   Registration Authority (RA), for the purposes of X.509 certificate
+   production.  The request will typically include a public key and the
+   associated registration information.  This document does not define a
+   certificate request protocol.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                     [Page 1]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+Table Of Contents
+
+   1. Introduction and Terminology ....................................3
+   2. Overview ........................................................3
+      2.1. Changes since RFC 2511 .....................................4
+   3. CertReqMessage Syntax ...........................................4
+   4. Proof-of-Possession (POP) .......................................5
+      4.1. Signature Key POP ..........................................7
+      4.2. Key Encipherment Keys ......................................9
+           4.2.1. Private Key Info Content Type ......................11
+           4.2.2. Private Key Structures .............................12
+           4.2.3. Challenge-Response Guidelines ......................13
+      4.3. Key Agreement Keys ........................................14
+      4.4. Use of Password-Based MAC .................................14
+   5. CertRequest syntax .............................................16
+   6. Controls Syntax ................................................18
+      6.1. Registration Token Control ................................18
+      6.2. Authenticator Control .....................................19
+      6.3. Publication Information Control ...........................19
+      6.4. Archive Options Control ...................................21
+      6.5. OldCert ID Control ........................................23
+      6.6. Protocol Encryption Key Control ...........................23
+   7. RegInfo Controls ...............................................23
+      7.1. utf8Pairs .................................................23
+      7.2. certReq ...................................................24
+   8. Object Identifiers .............................................24
+   9. Security Considerations ........................................25
+   10. References ....................................................26
+      10.1. Normative References .....................................26
+      10.2. Informative References ...................................27
+   11. Acknowledgements ..............................................28
+   Appendix A.  Use of RegInfo for Name-Value Pairs ..................29
+      A.1.  Defined Names ............................................29
+      A.2.  IssuerName, SubjectName, and Validity Value Encoding .....29
+   Appendix B.  ASN.1 Structures and OIDs ............................32
+   Appendix C.  Why do Proof-of-Possession (POP) .....................38
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                     [Page 2]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+1.  Introduction and Terminology
+
+   This document describes the Certificate Request Message Format
+   (CRMF).  A Certificate Request Message object is used within a
+   protocol to convey a request for a certificate to a Certification
+   Authority (CA), possibly via a Registration Authority (RA), for the
+   purposes of X.509 certificate production.  The request will typically
+   include a public key and the associated registration information.
+
+   The certificate request object defined in this document is not a
+   stand-alone protocol.  The information defined in this document is
+   designed to be used by an externally defined Certificate Request
+   Protocol (CRP).  The referencing protocol is expected to define what
+   algorithms are used, and what registration information and control
+   structures are defined.  Many of the requirements in this document
+   refer to the referencing Certificate Request Protocol (CRP).
+
+   Certificate requests may be submitted by an RA requesting a
+   certificate on behalf of a Subject, by a CA requesting a cross-
+   certificate from another CA, or directly by an End Entity (EE).
+
+   The key words "MUST", "REQUIRED", "SHOULD", "RECOMMENDED", and "MAY"
+   in this document (in uppercase, as shown) are to be interpreted as
+   described in RFC 2119 [RFC2119].
+
+2.  Overview
+
+   Construction of a certification request involves the following steps:
+
+   a)  A CertRequest object is constructed.  This object may include the
+       public key, all or a portion of the Subject name, other requested
+       certificate fields, and additional control information related to
+       the registration process.  Depending on the CRP, this information
+       can be specified by the Subject and potentially modified by an
+       RA, or specified by the RA based on knowledge of the Subject or
+       documentation presented by the Subject.
+
+   b)  If required, a proof-of-possession (of the private key
+       corresponding to the public key for which a certificate is being
+       requested) value is calculated.
+
+   c)  Additional registration information can be combined with the
+       proof-of-possession value and the CertRequest structure to form a
+       CertReqMessage.  Additional registration information can be added
+       by both the Subject and an RA.
+
+
+
+
+
+
+Schaad                      Standards Track                     [Page 3]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   d)  The CertReqMessage is securely communicated to a CA.  Specific
+       means of secure transport are to be specified by each CRP that
+       refers to this document.
+
+2.1.  Changes since RFC 2511
+
+   1.  Addition of an introduction section.
+
+   2.  Addition of the concept of a CRP and language relating to CRPs.
+
+   3.  In section 6.2, changed regToken to authenticator.
+
+   4.  Add information describing the contents of the EncryptedValue
+       structure.
+
+   5.  Changed name and contents of OID {id-regInfo 1}.
+
+   6.  Added text detailing what goes into the fields of the different
+       structures defined in the document.
+
+   7.  Replaced Appendix A with a reference to [RFC2875].  The only
+       difference is that the old text specified to use subject alt name
+       instead of subject name if subject name was empty.  This is not
+       possible for a CA certificate issued using PKIX.  It would
+       however be useful to update RFC 2875 to have this fallback
+       position.
+
+   7.  Insert Appendix C describing why POP is necessary and what some
+       of the different POP attacks are.
+
+   8.  pop field in the CertReqMsg structure has been renamed to popo to
+       avoid confusion between POP and pop.
+
+   9.  The use of the EncryptedValue structure has been deprecated in
+       favor of the EnvelopedData structure.
+
+   10.  Add details on how private keys are to be structured when
+       encrypted.
+
+   11.  Allow for POP on key agreement algorithms other than DH.
+
+3.  CertReqMessage Syntax
+
+   A certificate request message is composed of the certificate request,
+   an optional proof-of-possession field, and an optional registration
+   information field.
+
+
+
+
+
+Schaad                      Standards Track                     [Page 4]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   CertReqMessages ::= SEQUENCE SIZE (1..MAX) OF CertReqMsg
+
+   CertReqMsg ::= SEQUENCE {
+      certReq   CertRequest,
+      popo       ProofOfPossession  OPTIONAL,
+      -- content depends upon key type
+      regInfo   SEQUENCE SIZE(1..MAX) of AttributeTypeAndValue OPTIONAL
+   }
+
+   The fields of CertReqMsg have the following meaning:
+
+      certReq contains the template of the certificate being requested.
+      The template is filled in by (or on behalf of) the Subject.  Not
+      all fields within the template need to be specified.  Details on
+      this field are found in section 5.
+
+      popo contains the value used to demonstrate that the entity that
+      will be identified as the Subject of the certificate is actually
+      in possession of the corresponding private key.  This field varies
+      in structure and content based on the public key algorithm and the
+      mode (encryption vs. signature) in which the algorithm is used, as
+      specified in the KeyUsage field of the certificate to be issued.
+      Details on this field are found in section 4.
+
+      regInfo field SHOULD contain only supplementary information
+      relating to the context of the certificate request, where such
+      information is required to fulfill the request.  This information
+      might include subscriber contact information, billing information,
+      or other ancillary information useful to fulfillment of the
+      request.
+
+   Information directly related to certificate content SHOULD be
+   included in the certReq content.  However, inclusion of additional
+   certReq content by RAs can invalidate the popo field (depending on
+   the details of the POP method used).  Therefore, data intended for
+   certificate content MAY be provided in regInfo.
+
+   It is the responsibility of a referencing CRP to define the details
+   of what can be specified in the regInfo field.  This document
+   describes one method of encoding the information found in this field.
+   Details on this encoding are found in Appendix A.
+
+4.  Proof-of-Possession (POP)
+
+   In order to prevent certain attacks (see Appendix C) and to allow a
+   CA/RA to properly check the validity of the binding between a subject
+   and a key pair, the PKI management structures specified here make it
+   possible for a subject to prove that it has possession of (i.e., is
+
+
+
+Schaad                      Standards Track                     [Page 5]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   able to use) the private key corresponding to the public key for
+   which a certificate is requested.  A given CRP is free to choose how
+   to enforce POP (e.g., out-of-band procedural means versus the CRMF
+   in-band message) in its certification exchanges.  Within a given CRP,
+   CAs and RAs are free to choose from among the POP methods provided
+   (i.e., this is a policy issue local to an RA/CA).  A CRP SHOULD
+   define either which POP methods are required, or specify a mechanism
+   for clients to discover the POP methods supported.
+
+   Any CRP referencing this document MUST enforce POP by some means.
+   There are currently many non-PKIX operational protocols in use
+   (various electronic mail protocols are one example) that do not
+   explicitly check the binding between the end entity and the private
+   key.  Until operational protocols that do verify the binding (for
+   signature, encryption, and key agreement key pairs) exist, and are
+   ubiquitous, this binding cannot be assumed to have been verified by
+   the CA/RA.  Therefore, one cannot truly know if the binding of the
+   public key and the identity in the certificate is actually correct.
+
+   POP is accomplished in different ways depending on the type of key
+   for which a certificate is requested.  If a key can be used for
+   multiple purposes (e.g., a signing and decryption RSA key), then any
+   of the methods MAY be used.  Protocol designers need to be aware that
+   there can be hardware limitations on what POP methods may be usable,
+   e.g., if the private key is maintained in a hardware token.
+
+   This specification allows for cases where POP is validated by the CA,
+   the RA, or both.  Some policies require the CA to verify POP during
+   certificate issuance, in which case the RA MUST forward the end
+   entity's CertRequest and ProofOfPossession fields unaltered to the
+   CA.  (In this case, the RA could verify the POP and reject failing
+   certificate requests rather than forwarding them to the CA.)  If the
+   CA is not required by policy to verify POP, then the RA SHOULD
+   forward the end entity's request and proof, unaltered, to the CA as
+   above.  If this is not possible (for example because the RA verifies
+   POP by an out-of-band method), then the RA uses the raVerified
+   element to attest to the CA that the required proof has been
+   validated.  If the CA/RA uses an out-of-band method to verify POP
+   (such as physical delivery of CA/RA-generated private keys), then the
+   ProofOfPossession field is omitted.
+
+   ProofOfPossession ::= CHOICE {
+       raVerified        [0] NULL,
+       signature         [1] POPOSigningKey,
+       keyEncipherment   [2] POPOPrivKey,
+       keyAgreement      [3] POPOPrivKey }
+
+
+
+
+
+Schaad                      Standards Track                     [Page 6]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The fields of ProofOfPossession have the following meaning:
+
+      raVerified indicates that the RA has performed the POP required on
+      the certificate request.  This field is used by an RA when 1) the
+      CA is not required to do its own POP verification and 2) the RA
+      needs to change the contents of the certReq field.  CRPs MUST
+      provide a method for the RA to sign the ProofOfPossession.  A
+      requestor MUST NOT set this field and an RA/CA MUST NOT accept a
+      ProofOfPossession where the requestor sets this field.
+
+      signature is used for performing POP with signature keys.  The
+      details of this field are covered in section 4.1.
+
+      keyEncipherment is used for performing POP with key encipherment
+      encryption based keys (i.e., RSA).  The details of this field are
+      covered in section 4.2.
+
+      keyAgreement is used for performing POP with key agreement type
+      encryption keys (i.e., DH).  The details of this field are covered
+      in section 4.3.
+
+4.1.  Signature Key POP
+
+   POP for a signature key is accomplished by performing a signature
+   operation on a piece of data containing the identity for which the
+   certificate is desired.
+
+   There are three cases that need to be looked at when doing a POP for
+   a signature key:
+
+   1.  The certificate subject has not yet established an authenticated
+       identity with a CA/RA, but has a password and identity string
+       from the CA/RA.  In this case, the POPOSigningKeyInput structure
+       would be filled out using the publicKeyMAC choice for authInfo,
+       and the password and identity would be used to compute the
+       publicKeyMAC value.  The public key for the certificate being
+       requested would be placed in both the POPOSigningKeyInput and the
+       Certificate Template structures.  The signature field is computed
+       over the DER-encoded POPOSigningKeyInput structure.
+
+   2.  The CA/RA has established an authenticated identity for the
+       certificate subject, but the requestor is not placing it into the
+       certificate request.  In this case, the POPOSigningKeyInput
+       structure would be filled out using the sender choice for
+       authInfo.  The public key for the certificate being requested
+       would be placed in both the POPOSigningKeyInput and the
+       Certificate Template structures.  The signature field is computed
+       over the DER-encoded POPOSigningKeyInput structure.
+
+
+
+Schaad                      Standards Track                     [Page 7]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   3.  The certificate subject places its name in the Certificate
+       Template structure along with the public key.  In this case the
+       poposkInput field is omitted from the POPOSigningKey structure.
+       The signature field is computed over the DER-encoded certificate
+       template structure.
+
+   POPOSigningKey ::= SEQUENCE {
+       poposkInput         [0] POPOSigningKeyInput OPTIONAL,
+       algorithmIdentifier     AlgorithmIdentifier,
+       signature               BIT STRING }
+
+   The fields of POPOSigningKey have the following meaning:
+
+      poposkInput contains the data to be signed, when present.  This
+      field MUST be present when the certificate template does not
+      contain both the public key value and a subject name value.
+
+      algorithmIdentifier identifiers the signature algorithm and an
+      associated parameters used to produce the POP value.
+
+      signature contains the POP value produce.  If poposkInput is
+      present, the signature is computed over the DER-encoded value of
+      poposkInput.  If poposkInput is absent, the signature is computed
+      over the DER-encoded value of certReq.
+
+   POPOSigningKeyInput ::= SEQUENCE {
+       authInfo            CHOICE {
+           sender              [0] GeneralName,
+           -- used only if an authenticated identity has been
+           -- established for the sender (e.g., a DN from a
+           -- previously-issued and currently-valid certificate)
+           publicKeyMAC        PKMACValue },
+           -- used if no authenticated GeneralName currently exists for
+           -- the sender; publicKeyMAC contains a password-based MAC
+           -- on the DER-encoded value of publicKey
+       publicKey           SubjectPublicKeyInfo }  -- from CertTemplate
+
+   The fields of POPOSigningKeyInput have the following meaning:
+
+      sender contains an authenticated identity that has been previously
+      established for the subject.
+
+      publicKeyMAC contains a computed value that uses a shared secret
+      between the CA/RA and the certificate requestor.
+
+      publicKey contains a copy of the public key from the certificate
+      template.  This MUST be exactly the same value as is contained in
+      the certificate template.
+
+
+
+Schaad                      Standards Track                     [Page 8]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   PKMACValue ::= SEQUENCE {
+      algId  AlgorithmIdentifier,
+      value  BIT STRING }
+
+   The fields of PKMACValue have the following meaning:
+
+      algId identifies the algorithm used to compute the MAC value.  All
+      implementations MUST support id-PasswordBasedMAC.  The details on
+      this algorithm are presented in section 4.4.
+
+      value contains the computed MAC value.  The MAC value is computed
+      over the DER-encoded public key of the certificate subject.
+
+   The CA/RA identifies the shared secret to be used by looking at 1)
+   the general name field in the certificate request or 2) either the
+   regToken (see section 6.1) or authToken (see section 6.2) controls.
+
+4.2.  Key Encipherment Keys
+
+   POP for key encipherment keys is accomplished by one of three
+   different methods.  The private key can be provided to the CA/RA, an
+   encrypted challenge from the CA/RA can be decrypted (direct method),
+   or the created certificate can be returned encrypted and used as the
+   challenge response (indirect method).
+
+   POPOPrivKey ::= CHOICE {
+       thisMessage       [0] BIT STRING,   -- deprecated
+       subsequentMessage [1] SubsequentMessage,
+       dhMAC             [2] BIT STRING,   -- deprecated
+       agreeMAC          [3] PKMACValue,
+       encryptedKey      [4] EnvelopedData }
+     -- for keyAgreement (only), possession is proven in this message
+     -- (which contains a MAC (over the DER-encoded value of the
+     -- certReq parameter in CertReqMsg, which must include both subject
+     -- and publicKey) based on a key derived from the end entity's
+     -- private DH key and the CA's public DH key);
+     -- the dhMAC value MUST be calculated as per the directions given
+     -- in RFC 2875 for static DH proof-of-possession.
+
+   SubsequentMessage ::= INTEGER {
+       encrCert (0),
+       challengeResp (1) }
+
+   The fields of POPOPrivKey have the following meaning:
+
+      thisMessage contains the encrypted private key for which a
+      certificate is to be issued.  The possession of the private key is
+      proved by providing it to the CA/RA.  This field was incorrectly
+
+
+
+Schaad                      Standards Track                     [Page 9]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      typed when the specification was first written.  The correct way
+      to use this field is to create an EncryptedValue structure where
+      the encrypted content is the private key, the EncryptedValue
+      structure is then wrapped in the BIT STRING type.  This field has
+      been deprecated in favor of encryptedKey.
+
+      subsequentMessage is used to indicate that the POP will be
+      completed by decrypting a message from the CA/RA and returning a
+      response.  The type of message to be decrypted is indicated by the
+      value used.
+
+         encrCert indicates that the certificate issued is to be
+         returned in an encrypted form.  The requestor is required to
+         decrypt the certificate and prove success to the CA/RA.  The
+         details of this are provided by the CRP.
+
+         challengeResponse indicates that a challenge message is to be
+         sent from the CA/RA to the requestor.  The details of the
+         challenge message and the response are to be provided by the
+         CRP.
+
+      dhMAC is used for Diffie-Hellman key agreement keys.  It contains
+      a computed MAC that is obtained by using the requestor's private
+      key and the CA/RA public key.  The use of this field is deprecated
+      in favor of the agreeMAC field.  Details are covered in section
+      4.3.
+
+      agreeMAC is used for key agreement keys.  It contains a computed
+      MAC that is obtained by using the requestor's private key and a
+      matching CA/RA public key.  Details are covered in section 4.3.
+
+         macAlg contains the algorithm identifying the method used to
+         compute the MAC value.
+
+         macValue contains the computed MAC value.
+
+      encryptedKey contains the encrypted private key matching the
+      public key for which the certificate is to be issued.  It also
+      contains an identification value to indicate it was constructed by
+      the requestor of the certificate.  The enveloped content type MUST
+      be id-ct-encKeyWithID.
+
+   It is expected that protocols that incorporate this specification
+   will include the confirmation and challenge-response messages
+   necessary for a complete protocol.
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 10]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+4.2.1.  Private Key Info Content Type
+
+   This content type is used for 1) proving possession of private keys
+   and 2) escrow of private keys (using the archive options control in
+   section 6.4).  This structure is based on the private key info
+   structure from [PKCS8] but has one deliberate difference.  There is a
+   potential attack on escrow agents if they decrypt the private key but
+   don't know to whom the encrypted key is supposed to belong.  An
+   attacker could intercept the encrypted private key, build a
+   certificate request around it and then ask for a recovery operation
+   on the private key.
+
+   This content type and its structure are:
+
+      id-ct-encKeyWithID OBJECT IDENTIFIER ::= {id-ct 21}
+
+      EncKeyWithID ::= SEQUENCE {
+        privateKey           PrivateKeyInfo,
+        identifier CHOICE {
+          string               UTF8String,
+          generalName          GeneralName
+        } OPTIONAL
+      }
+
+      PrivateKeyInfo ::= SEQUENCE {
+         version                   INTEGER,
+         privateKeyAlgorithm       AlgorithmIdentifier,
+         privateKey                OCTET STRING,
+         attributes                [0] IMPLICIT Attributes OPTIONAL
+      }
+
+   Attributes ::= SET OF Attribute
+
+   The fields of EncKeyWithID are defined as:
+
+      privateKey contains the encoded private key.  Definitions for
+      three private key formats are included in this document.
+      Specifications for asymmetric algorithms need to include both the
+      public and private key definitions for consistency.
+
+      identifier contains a name that the CA/RA can associate with the
+      requestor.  This will generally be either the DN of a certificate
+      or a text token passed and known to both the requestor and the
+      CA/RA.  This field MUST be present if the purpose is to prove
+      possession of the private key.  The field SHOULD be present if
+      archiving a key and the archive agent is expected to decrypt the
+      key.
+
+
+
+
+Schaad                      Standards Track                    [Page 11]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The fields of PrivatekeyInfo are define as:
+
+      version MUST be the value 0
+
+      privateKeyAlgorithm contains the identifier for the private key
+      object
+
+      privateKey is an octet string whose contents is the private key
+      and whose format is defined by the value of privateKeyAlgorithm.
+
+      attributes is a set of attributes.  They are extended information
+      that is part of the private key information.
+
+4.2.2.  Private Key Structures
+
+   We are defining the structures here to be used for three algorithms.
+
+4.2.2.1.  D-H Private Keys
+
+   When creating a PrivateKeyInfo for a D-H key, the following rules
+   apply:
+
+     1. The privateKeyAlgorithm MUST be set to id-dh-private-number.
+        The parameter for id-dh-private-number is DomainParameters
+        (imported from [PKIXALG]).
+
+     2. The ASN structure for privateKey MUST be
+
+        DH-PrivateKey ::= INTEGER
+
+     3. The attributes field MUST be omitted.
+
+4.2.2.2.  DSA Private Keys
+
+   When creating a PrivateKeyInfo for a DSA key, the following rules
+   apply:
+
+     1. The privateKeyAlgorithm MUST be set to id-dsa.  The parameters
+        for id-dsa is Dss-Parms (imported from [PKIXALG]).
+
+     2. The ASN structure for privateKey MUST be
+
+        DSA-PrivateKey ::= INTEGER
+
+     3. The attributes field MUST be omitted.
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 12]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+4.2.2.3.  RSA Private Keys
+
+   When creating a PrivateKeyInfo for an RSA key, the following rules
+   apply:
+
+     1. The privateKeyAlgorithm MUST be set to rsaEncryption.
+
+     2. The ASN structure for privateKey MUST be RSAPrivateKey (defined
+        in [PKCS1])
+
+     3. The attributes field MUST be omitted.
+
+4.2.3.  Challenge-Response Guidelines
+
+   The following provides guidelines to enrollment protocol authors
+   about how an indirect proof-of-possession is expected to work and
+   about some of the areas where one needs to be careful in crafting the
+   messages to implement this POP method.
+
+   1.  The original enrollment request includes a proof of identity of
+       some type and the public portion of the encryption key.  Note
+       that the proof of identity needs to cover the public portion of
+       the encryption key to prevent substitution attacks (where the
+       attacker changes your public key for his public key).
+
+   2.  The response message from the server includes an encrypted data
+       value of some type.  That value needs to be authenticated in some
+       fashion as having come from the server.  The specification needs
+       to include the specifics of how this value is returned for the
+       different key types.  For RSA keys, the value can be specified as
+       being directly encrypted by the RSA public key; this will not
+       work for a D-H key where you need to specify an indirect
+       mechanism to encrypt the value.
+
+   3.  The second request message includes a hash of the decrypted
+       value.  This message MUST NOT be just the hash of the encrypted
+       value, as one should never "sign" a completely random value.  It
+       is desirable to include information such as the identity string
+       in the hashing process so that this can be made explicitly.  This
+       returned value MUST be included in a second proof of identity.
+
+   It is strongly suggested that transaction identifiers and nonce
+   values be required when performing indirect POP, as this allows for
+   1) tying the different messages in the process together and 2)
+   letting each entity inject some amount of random data into the
+   process of doing identity proofs.
+
+
+
+
+
+Schaad                      Standards Track                    [Page 13]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+4.3.  Key Agreement Keys
+
+   POP for key agreement keys is accomplished by one of four different
+   methods.  The first three are identical to those presented above for
+   key encryption keys.  The fourth method takes advantage of the fact
+   that a shared secret is produced and that the value can be used to
+   MAC information.
+
+   When the direct or indirect encryption methods presented above are
+   used, the CA/RA will need to create an ephemeral key for those cases
+   where the encryption algorithm parameters do not match between the
+   CA/RA and the requestor.
+
+   The end entity may also MAC the certificate request (using a shared
+   secret key derived from computation) as a fourth alternative for
+   demonstrating POP.  This option may be used only if the CA/RA already
+   has a certificate that is known to the end entity and if the Subject
+   is able to use the CA/RA's parameters.
+
+   For the DH key agreement algorithm, all implementations MUST support
+   the static DH Proof-of-Possession.  Details on this algorithm can be
+   found in section 3 of [RFC2875].  NOTE: If either the subject or
+   issuer name in the CA certificate is empty, then the alternative name
+   should be used in its place.
+
+4.4.  Use of Password-Based MAC
+
+   This MAC algorithm was designed to take a shared secret (a password)
+   and use it to compute a check value over a piece of information.  The
+   assumption is that, without the password, the correct check value
+   cannot be computed.  The algorithm computes the one-way function
+   multiple times in order to slow down any dictionary attacks against
+   the password value.
+
+   The algorithm identifier and parameter structure used for Password-
+   Based MAC is:
+
+      id-PasswordBasedMAC OBJECT IDENTIFIER ::=
+                                         { 1 2 840 113533 7 66 13}
+
+      PBMParameter ::= SEQUENCE {
+         salt                OCTET STRING,
+         owf                 AlgorithmIdentifier,
+         iterationCount      INTEGER,
+         mac                 AlgorithmIdentifier
+         )
+
+
+
+
+
+Schaad                      Standards Track                    [Page 14]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The fields of PEMParameter have the following meaning:
+
+      salt contains a randomly generated value used in computing the key
+      of the MAC process.  The salt SHOULD be at least 8 octets (64
+      bits) long.
+
+      owf identifies the algorithm and associated parameters used to
+      compute the key used in the MAC process.  All implementations MUST
+      support SHA-1.
+
+      iterationCount identifies the number of times the hash is applied
+      during the key computation process.  The iterationCount MUST be a
+      minimum of 100.  Many people suggest using values as high as 1000
+      iterations as the minimum value.  The trade off here is between
+      protection of the password from attacks and the time spent by the
+      server processing all of the different iterations in deriving
+      passwords.  Hashing is generally considered a cheap operation but
+      this may not be true with all hash functions in the future.
+
+      mac identifies the algorithm and associated parameters of the MAC
+      function to be used.  All implementations MUST support HMAC-SHA1
+      [HMAC].  All implementations SHOULD support DES-MAC and Triple-
+      DES-MAC [PKCS11].
+
+   The following is pseudo-code for the algorithm:
+
+   Inputs:
+          pw   - an octet string containing the user's password
+          data - an octet string containing the value to be MAC-ed
+          Iter - iteration count
+
+   Output:
+          MAC  - an octet string containing the resultant MAC value
+
+   1.  Generate a random salt value S
+
+   2.  Append the salt to the pw.  K = pw || salt.
+
+   3.  Hash the value of K.  K = HASH(K)
+
+   4.  If Iter is greater than zero.  Iter = Iter - 1.  Goto step 3.
+
+   5.  Compute an HMAC as documented in [HMAC].
+
+       MAC = HASH( K XOR opad, HASH( K XOR ipad, data) )
+
+       Where opad and ipad are defined in [HMAC].
+
+
+
+
+Schaad                      Standards Track                    [Page 15]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+5.  CertRequest syntax
+
+   The CertRequest syntax consists of a request identifier, a template
+   of certificate content, and an optional sequence of control
+   information.
+
+   CertRequest ::= SEQUENCE {
+      certReqId     INTEGER,        -- ID for matching request and reply
+      certTemplate  CertTemplate, --Selected fields of cert to be issued
+      controls      Controls OPTIONAL } -- Attributes affecting issuance
+
+   CertTemplate ::= SEQUENCE {
+      version      [0] Version               OPTIONAL,
+      serialNumber [1] INTEGER               OPTIONAL,
+      signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
+      issuer       [3] Name                  OPTIONAL,
+      validity     [4] OptionalValidity      OPTIONAL,
+      subject      [5] Name                  OPTIONAL,
+      publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
+      issuerUID    [7] UniqueIdentifier      OPTIONAL,
+      subjectUID   [8] UniqueIdentifier      OPTIONAL,
+      extensions   [9] Extensions            OPTIONAL }
+
+   OptionalValidity ::= SEQUENCE {
+      notBefore  [0] Time OPTIONAL,
+      notAfter   [1] Time OPTIONAL } --at least one must be present
+
+   Time ::= CHOICE {
+      utcTime        UTCTime,
+      generalTime    GeneralizedTime }
+
+   The fields of CertRequest have the following meaning:
+
+      certReqId contains an integer value that is used by the
+      certificate requestor to associate a specific certificate request
+      with a certificate response.
+
+      certTemplate contains a template of an X.509 certificate.  The
+      requestor fills in those fields for which specific values are
+      desired.  Details on the fields are given below.
+
+      controls contains attributes that are not part of the certificate,
+      but control the context in which the certificate is to be issued.
+      Details on the controls defined in this document can be found in
+      section 6.  Other documents may define other controls.  CRPs are
+      responsible for specifying which controls are required.
+
+
+
+
+
+Schaad                      Standards Track                    [Page 16]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The fields of CertTemplate have the following meaning:
+
+      version MUST be 2 if supplied.  It SHOULD be omitted.
+
+      serialNumber MUST be omitted.  This field is assigned by the CA
+      during certificate creation.
+
+      signingAlg MUST be omitted.  This field is assigned by the CA
+      during certificate creation.
+
+      issuer is normally omitted.  It would be filled in with the CA
+      that the requestor desires to issue the certificate in situations
+      where an RA is servicing more than one CA.
+
+      validity is normally omitted.  It can be used to request that
+      certificates either start at some point in the future or expire at
+      some specific time.  A case where this field would commonly be
+      used is when a cross certificate is issued for a CA.  In this case
+      the validity of an existing certificate would be placed in this
+      field so that the new certificate would have the same validity
+      period as the existing certificate.  If validity is not omitted,
+      then at least one of the sub-fields MUST be specified.  The sub-
+      fields are as follows:
+
+         notBefore contains the requested start time of the certificate.
+         The time follows the same rules as the notBefore time in
+         [PROFILE].
+
+         notAfter contains the requested expiration time of the
+         certificate.  The time follows the same rules as the notAfter
+         time in [PROFILE].
+
+      subject is filled in with the suggested name for the requestor.
+      This would normally be filled in by a name that has been
+      previously issued to the requestor by the CA.
+
+      publicKey contains the public key for which the certificate is
+      being created.  This field MUST be filled in if the requestor
+      generates its own key.  The field is omitted if the key is
+      generated by the RA/CA.
+
+      issuerUID MUST be omitted.  This field has been deprecated in
+      [PROFILE].
+
+      subjectUID MUST be omitted.  This field has been deprecated in
+      [PROFILE].
+
+
+
+
+
+Schaad                      Standards Track                    [Page 17]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      extensions contains extensions that the requestor wants to have
+      placed in the certificate.  These extensions would generally deal
+      with things such as setting the key usage to keyEncipherment.
+
+   With the exception of the publicKey field, the CA/RA is permitted to
+   alter any requested field.  The returned certificate needs to be
+   checked by the requestor to see if the fields have been set in an
+   acceptable manner.  CA/RA SHOULD use the template fields if possible.
+
+   There are cases where all fields of the template can be omitted.  If
+   the key generation is being done at the CA/RA and the identity proof
+   is placed in a different location (such as the id-regCtrl-regToken
+   below), then there are no fields that need to be specified by the
+   certificate requestor.
+
+6.  Controls Syntax
+
+   The generator of a CertRequest may include one or more control values
+   pertaining to the processing of the request.
+
+   Controls  ::= SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue
+
+   The following controls are defined by this document:  regToken
+   (section 6.1); authenticator (section 6.2); pkiPublicationInfo
+   (section 6.3); pkiArchiveOptions (section 6.4); oldCertID (section
+   6.5); protocolEncrKey (section 6.6).  Each CRP MUST define the set of
+   controls supported by that protocol.  Additional controls may be
+   defined by additional RFCs or by the CRP protocol itself.
+
+6.1.  Registration Token Control
+
+   A regToken control contains one-time information (either based on a
+   secret value or other shared information) intended to be used by the
+   CA to verify the identity of the subject prior to issuing a
+   certificate.  Upon receipt of a certification request containing a
+   value for regToken, the receiving CA verifies the information in
+   order to confirm the identity claimed in the certification request.
+
+   The value for regToken may be generated by the CA and provided out of
+   band to the subscriber, or may otherwise be available to both the CA
+   and the subscriber.  The security of any out-of-band exchange should
+   be commensurate with the risk that the CA will tolerate with regard
+   to accepting an intercepted value from someone other than the
+   intended subscriber.  The regToken value is not encrypted on return,
+   if the data is considered to be sensitive, it needs to be shrouded by
+   the requestor.
+
+
+
+
+
+Schaad                      Standards Track                    [Page 18]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The regToken control is used only for initialization of an end entity
+   into the PKI, whereas the authenticator control (see section 7.2) can
+   be used for the initial as well as subsequent certification requests.
+
+   In some instances of use the value for regToken could be a text
+   string or a numeric quantity such as a random number.  In the latter
+   case, the value is encoded as a text string representation of the
+   binary quantity.  The encoding of regToken SHALL be UTF8String.
+
+   id-regCtrl-regToken            OBJECT IDENTIFIER ::= { id-regCtrl 1 }
+
+   Without prior agreement between the subscriber and CA agents, this
+   value would be a textual shared secret of some type.  If a computed
+   value based on that shared secret is to be used instead, it is
+   suggested that the CRP define a new registration control for that
+   specific computation.
+
+6.2.  Authenticator Control
+
+   An authenticator control contains information used on an ongoing
+   basis to establish a non-cryptographic check of identity in
+   communication with the CA.  Examples include:  mother's maiden name,
+   last four digits of social security number, or other knowledge-based
+   information shared with the subscriber's CA; a hash of such
+   information; or other information produced for this purpose.  The
+   value for an authenticator control may be generated by the subscriber
+   or by the CA.
+
+   In some instances of use, the value for authenticator could be a text
+   string or a numeric quantity such as a random number.  The value in
+   the latter case is encoded as a text string representation of the
+   binary quantity.  The encoding of authenticator SHALL be UTF8String.
+
+   id-regCtrl-authenticator       OBJECT IDENTIFIER ::= { id-regCtrl 2 }
+
+   When deciding whether to use an authenticator or a regToken, use the
+   following guidelines.  If the value is a one-time usage value, then
+   regToken would be used.  If the value has a long-term usage, then the
+   authenticator control would be used.
+
+6.3.  Publication Information Control
+
+   The pkiPublicationInfo control enables subscribers to influence the
+   CA/RA's publication of the certificate.  This control is considered
+   advisory and can be ignored by CAs/RAs.  It is defined by the
+   following OID and syntax:
+
+
+
+
+
+Schaad                      Standards Track                    [Page 19]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   id-regCtrl-pkiPublicationInfo  OBJECT IDENTIFIER ::= { id-regCtrl 3 }
+
+   PKIPublicationInfo ::= SEQUENCE {
+        action     INTEGER {
+                     dontPublish (0),
+                     pleasePublish (1) },
+        pubInfos  SEQUENCE SIZE (1..MAX) OF SinglePubInfo OPTIONAL }
+
+   SinglePubInfo ::= SEQUENCE {
+         pubMethod    INTEGER {
+             dontCare    (0),
+             x500        (1),
+             web         (2),
+             ldap        (3) },
+         pubLocation  GeneralName OPTIONAL }
+
+   The fields of PKIPublicationInfo have the following meaning:
+
+      action indicates whether or not the requestor wishes the CA/RA to
+      publish the certificate.  The values and their means are:
+
+         dontPublish indicates that the requester wishes the CA/RA not
+         to publish the certificate (this may indicate that the
+         requester intends to publish the certificate him/herself).  If
+         dontPublish is used, the pubInfos field MUST be omitted.
+
+         pleasePublish indicates that the requestor wishes the CA/RA to
+         publish the certificate.
+
+      pubInfos holds the locations where the requestor desires the CA/RA
+      to publish the certificate.  This field is omitted if the
+      dontPublish choice is selected.  If the requestor wants to specify
+      some locations for the certificate to be published, and to allow
+      the CA/RA to publish in other locations, it would specify multiple
+      values of the SinglePubInfo structure, one of which would be
+      dontCare.
+
+   The fields of SinglePubInfo have the following meaning:
+
+      pubMethod indicates the address type for the location at which the
+      requestor desires the certificate to be placed by the CA/RA.
+
+         dontCare indicates that the CA/RA can publish the certificate
+         in whatever locations it chooses.  If dontCare is used, the
+         pubInfos field MUST be omitted.
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 20]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+         x500 indicates that the requestor wishes for the CA/RA to
+         publish the certificate in a specific location.  The location
+         is indicated in the x500 field of pubLocation.
+
+         ldap indicates that the requestor wishes for the CA/RA to
+         publish the certificate in a specific location.  The location
+         is indicated in the ldap field of pubLocation.
+
+         web indicates that the requestor wishes for the CA/RA to
+         publish the certificate in a specific location.  The location
+         is indicated in the http field of pubLocation.
+
+      pubLocation contains the address at which the certificate is to be
+      placed.  The choice in the general name field is dictated by the
+      pubMethod selection in this structure.
+
+   Publication locations can be supplied in any order.  All locations
+   are to be processed by the CA for purposes of publication.
+
+6.4.  Archive Options Control
+
+   The pkiArchiveOptions control enables subscribers to supply
+   information needed to establish an archive of the private key
+   corresponding to the public key of the certification request.  It is
+   defined by the following OID and syntax:
+
+   id-regCtrl-pkiArchiveOptions   OBJECT IDENTIFIER ::= { id-regCtrl 4 }
+
+   PKIArchiveOptions ::= CHOICE {
+      encryptedPrivKey     [0] EncryptedKey,
+      -- the actual value of the private key
+      keyGenParameters     [1] KeyGenParameters,
+      -- parameters which allow the private key to be re-generated
+      archiveRemGenPrivKey [2] BOOLEAN }
+      -- set to TRUE if sender wishes receiver to archive the private
+      -- key of a key pair that the receiver generates in response to
+      -- this request; set to FALSE if no archival is desired.
+
+   EncryptedKey ::= CHOICE {
+      encryptedValue        EncryptedValue, -- deprecated
+      envelopedData     [0] EnvelopedData }
+      -- The encrypted private key MUST be placed in the envelopedData
+      -- encryptedContentInfo encryptedContent OCTET STRING.
+
+   EncryptedValue ::= SEQUENCE {
+      intendedAlg   [0] AlgorithmIdentifier  OPTIONAL,
+      -- the intended algorithm for which the value will be used
+      symmAlg       [1] AlgorithmIdentifier  OPTIONAL,
+
+
+
+Schaad                      Standards Track                    [Page 21]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      -- the symmetric algorithm used to encrypt the value
+      encSymmKey    [2] BIT STRING           OPTIONAL,
+      -- the (encrypted) symmetric key used to encrypt the value
+      keyAlg        [3] AlgorithmIdentifier  OPTIONAL,
+      -- algorithm used to encrypt the symmetric key
+      valueHint     [4] OCTET STRING         OPTIONAL,
+      -- a brief description or identifier of the encValue content
+      -- (may be meaningful only to the sending entity, and used only
+      -- if EncryptedValue might be re-examined by the sending entity
+      -- in the future)
+      encValue       BIT STRING }
+   -- The use of the EncryptedValue field has been deprecated in favor
+   -- of the EnvelopedData structure.
+   --
+   -- When EncryptedValue is used to carry a private key (as opposed to
+   -- a certificate), implementations MUST support the encValue field
+   -- containing an encrypted PrivateKeyInfo as defined in [PKCS11],
+   -- section 12.11.  If encValue contains some other format/encoding
+   -- for the private key, the first octet of valueHint MAY be used
+   -- to indicate the format/encoding (but note that the possible values
+   -- of this octet are not specified at this time).  In all cases, the
+   -- intendedAlg field MUST be used to indicate at least the OID of
+   -- the intended algorithm of the private key, unless this information
+   -- is known a priori to both sender and receiver by some other means.
+
+   KeyGenParameters ::= OCTET STRING
+
+   The fields of PKIArchiveOptions have the following meaning:
+
+      encryptedPrivKey contains an encrypted version of the private key.
+
+      keyGenParameters contains the information needed by the requestor
+      to regenerate the private key.  As an example, for many RSA
+      implementations one could send the first random number(s) tested
+      for primality.  The structure to go here is not defined by this
+      document.  CRPs that define content for this structure MUST define
+      not only the content that is to go here, but also how that data is
+      shrouded from unauthorized access.
+
+      archiveRemGenPrivKey indicates that the requestor desires that the
+      key generated by the CA/RA on the requestor's behalf be archived.
+
+   The fields of EncryptedKey have the following meaning:
+
+      encryptedValue is longer used.  This field has been deprecated
+      along with the EncryptedValue structure.
+
+
+
+
+
+Schaad                      Standards Track                    [Page 22]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      envelopedData contains the encrypted value of the private key.
+      CPRs that use this structure MUST define the entity or entities
+      for whom the data is to be encrypted (the EE, escrow agents, CAs)
+      and how that key or set of keys is to be determined.  Details on
+      constructing an EnvelopedData structure are found in [CMS].  The
+      encrypted content MUST be an id-ct-encKeyWithID.  The identifier
+      can be omitted unless this structure is also being used to do
+      proof-of-possession.
+
+6.5.  OldCert ID Control
+
+   If present, the OldCertID control specifies the certificate to be
+   updated by the current certification request.  The OID and syntax is:
+
+   id-regCtrl-oldCertID           OBJECT IDENTIFIER ::= { id-regCtrl 5 }
+
+   CertId ::= SEQUENCE {
+         issuer           GeneralName,
+         serialNumber     INTEGER
+     }
+
+6.6.  Protocol Encryption Key Control
+
+   If present, the protocolEncrKey control specifies a key that the CA
+   is to use in encrypting a response to CertReqMessages.  The OID for
+   this control is id-regCtrl-protocolEncrKey.  The parameter structure
+   for this field is SubjectPublicKeyInfo.  (This structure is defined
+   in [PROFILE].)
+
+   id-regCtrl-protocolEncrKey     OBJECT IDENTIFIER ::= { id-regCtrl 6 }
+
+   This control is used when a CA has information to send to the
+   subscriber that needs to be encrypted.  Such information includes a
+   private key generated by the CA for use by the subscriber.
+
+7.  RegInfo Controls
+
+   This section documents the controls that are to be placed in the
+   regInfo field of the CertReqMsg structure.
+
+7.1.  utf8Pairs
+
+   This control is used to convey text-based information from the
+   Subject to an RA to a CA issuing a certificate.  The OID for this
+   structure is id-regInfo-utf8Paris and has a type of UTF8String.
+
+      id-regInfo-utf8Pairs    OBJECT IDENTIFIER ::= { id-regInfo 1 }
+
+
+
+
+Schaad                      Standards Track                    [Page 23]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   The name is terminated by the question mark character ('?').  The
+   value is terminated by the percent character '%'.  Name value pairs
+   can be repeated.  Thus the syntax is:
+
+      Name?Value%[Name?Value%]*
+
+   The %xx mechanism of [RFC1738] is used to encode '?' (%3f) and '%'
+   (%25) if they are not being used for their reserved purpose.  Names
+   MUST NOT start with a numeric character.
+
+   This control can appear multiple times in the regInfo structure.
+   Resolution of conflicts of information is a matter of local policy on
+   the RA/CA.
+
+   Appendix A contains a set of common names and data formats
+   corresponding to fields that commonly appear in certificates and
+   directories.
+
+7.2.  certReq
+
+   This control is designed to deal with the problem where an RA needs
+   to modify the certificate template proposed by a Subject, but the
+   Subject used the certificate template as part of its POP calculation.
+   In this case, the RA can place a new certificate template in the
+   regInfo sequence.
+
+   This control has the OID id-regInfo-certReq and the structure
+   CertRequest.  There can only be one instance of this attribute in the
+   regInfo sequence.  If this control exists in the regInfo structure,
+   then the certificate template in the request is ignored.  The RA MUST
+   copy all data from the core template to this attribute.
+
+      id-regInfo-certReq       OBJECT IDENTIFIER ::= { id-regInfo 2 }
+
+8.  Object Identifiers
+
+   The OID id-pkix has the value
+
+   id-pkix  OBJECT IDENTIFIER  ::= { iso(1) identified-organization(3)
+   dod(6) internet(1) security(5) mechanisms(5) pkix(7) }
+
+   -- arc for Internet X.509 PKI protocols and their components
+   id-pkip  OBJECT IDENTIFIER :: { id-pkix pkip(5) }
+
+   -- arc for Registration Controls in CRMF
+   id-regCtrl  OBJECT IDENTIFIER ::= { id-pkip regCtrl(1) }
+
+
+
+
+
+Schaad                      Standards Track                    [Page 24]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   -- arc for Registration Info in CRMF
+   id-regInfo       OBJECT IDENTIFIER ::= { id-pkip id-regInfo(2) }
+
+9.  Security Considerations
+
+   Enrollment protocols, by their very nature, involve large amounts of
+   private information.  This can include private keys, identity
+   numbers, credit card numbers, and the like.  The security of any CRP
+   is based on the security mechanisms of the protocol and/or process
+   used to communicate between CAs, RAs and EEs.  All protocols must
+   provide for masking, either via encryption or off-line processing, of
+   all subscriber-sensitive information.
+
+   Many enrollment protocols provide for the initial establishment of
+   identity between the CA/RA and the EE by the use of a token.
+   Generally this token is delivered using an out-of-band delivery
+   method (such as the governmental mail system).  The security of any
+   out-of-band exchange needs to be commensurate with the risk that the
+   CA/RA will tolerate with regard to interception of the token by a
+   third party.
+
+   Implementation must implement Proof-of-Possession (POP) values during
+   certificate enrollment processes.  A good POP algorithm needs to
+   provide proof of two things: 1) that the key is tied to a specific
+   user and 2) that the user has use of the key in question.  Failure to
+   implement POP allows people to create certificates where the public
+   key and the name values do not correctly bind.  This allows for
+   impersonation on signature keys and interception of encrypted
+   messages.
+
+   Implementations must use high entropy random number generators in
+   producing private keys.  Implementations must randomly generate
+   content-encryption keys, message-authentication keys, initialization
+   vectors (IVs), salt, and padding.  The use of inadequate pseudo-
+   random number generators (PRNGs) to generate cryptographic keys can
+   result in little or no security.  An attacker may find it much easier
+   to reproduce the PRNG environment that produced the keys, searching
+   the resulting small set of possibilities, rather than brute force
+   searching the whole key space.  The generation of quality random
+   numbers is difficult.  RFC 4086 [RANDOM] offers important guidance in
+   this area and Appendix 3 of FIPS Pub 186 [DSS] provides one quality
+   PRNG technique.
+
+   Implementations must protect private keys.  The compromise of a
+   signer's private key permits third parties to masquerade as the
+   signer.  The compromise of a decryption private key allows for
+   interception of messages by a third party.
+
+
+
+
+Schaad                      Standards Track                    [Page 25]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   One feature of the certificate message request syntax is for the key
+   generation to be performed remotely from the creation of the
+   certificate request.  This feature should never be used for
+   generation of signing keys.  If signing keys are generated for the
+   user, then an element of repudiation comes into play.  The user can
+   claim that an item was signed by the entity that generated the key as
+   well as any entity that might have seen the key value during transfer
+   from the generator the to EE.  Care must be taken to protect
+   encryption keys by the remote key generator to protect against
+   interception of the keys by a third party.  This means that the
+   encryption algorithms used need to be secure, and a content
+   encryption key or a key encryption key must be used to mask the
+   private key during transport back to the user.  CRP protocols must
+   never assume that a signature key generated by the user can be used
+   to decrypt the package in which an encryption private key is
+   transported.
+
+   This document describes a method by which key escrow may be done.
+   There are several issues that need to be taken into account when
+   doing key escrow.  First, the client must be able to correctly
+   identify the entity to which a key is to be escrowed or the CRP must
+   provide a method by which the client can discover this information.
+   A CRP cannot assume that the key escrow agent and the CA are the same
+   entity and thus have the same names.  Second, the algorithms used to
+   mask the private key or other key generation information during
+   transport to the escrow agent need to be commensurate with the value
+   of the data being protected by the key.  Third, the escrow agent
+   needs to provide sufficient safeguards that an escrowed key is
+   returned only to entities that should be able to obtain the private
+   key.  Generally, this should be restricted to the entity that
+   escrowed the data.  Fourth, the escrow data base needs to be stored
+   in a secure manner.  One common method for doing this is to re-
+   encrypt the data to keys that only the escrow agent has access to.
+   In this case, one may need to escrow the escrow agent key as well.
+   Access to either the escrow agent or the archived key would amount to
+   access to all private keys that have been escrowed with that agent.
+
+10.  References
+
+10.1.  Normative References
+
+   [PKCS1]   Jonsson, J. and B. Kaliski, "Public-Key Cryptography
+             Standards (PKCS) #1: RSA Cryptography Specifications
+             Version 2.1", RFC 3447, February 2003.
+
+   [HMAC]    Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:
+             Keyed-Hashing for Message Authentication", RFC 2104,
+             February 1997.
+
+
+
+Schaad                      Standards Track                    [Page 26]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   [PKCS11]  RSA Laboratories, The Public-Key Cryptography Standards -
+             "PKCS #11 v2.11:  Cryptographic Token Interface Standard",
+             RSA Security Inc., June 2001.
+
+   [RFC2119] Bradner, S., "Key words for use in RFCs to Indicate
+             Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [PROFILE] Housley, R., Polk, W., Ford, W., and D. Solo, "Internet
+             X.509 Public Key Infrastructure Certificate and Certificate
+             Revocation List (CRL) Profile", RFC 3280, April 2002.
+
+   [PKIXALG] Bassham, L., Polk, W., and R. Housley, "Algorithms and
+             Identifiers for the Internet X.509 Public Key
+             Infrastructure Certificate and Certificate Revocation List
+             (CRL) Profile", RFC 3279, April 2002.
+
+   [CMS]     Housley, R., "Cryptographic Message Syntax (CMS)", RFC
+             3852, July 2004.
+
+   [RFC2875] Prafullchandra, H. and J. Schaad, "Diffie-Hellman
+             Proof-of-Possession Algorithms", RFC 2875, July 2000.
+
+10.2.  Informative References
+
+   [DSS]     National Institute of Standards and Technology, FIPS Pub
+             186: Digital Signature Standard, May 1994.
+
+   [PKCS8]   RSA Laboratories, "PKCS #8: Private-Key Information Syntax
+             Standard", PKCS #8 v1.2, November 1993.
+
+   [RANDOM]  Eastlake, D., 3rd, Schiller, J., and S. Crocker,
+             "Randomness Requirements for Security", BCP 106, RFC 4086,
+             June 2005.
+
+   [RFC2202] Cheng, P. and R. Glenn, "Test Cases for HMAC-MD5 and
+             HMAC-SHA-1", RFC 2202, September 1997.
+
+   [RFC1738] Berners-Lee, T., Masinter, L., and M. McCahill, "Uniform
+             Resource Locators (URL)", RFC 1738, December 1994.
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 27]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+11.  Acknowledgements
+
+   The working group would like to thank Michael Myers, Carlisle Adams,
+   Dave Solo, and David Kemp, who authored the original version of this
+   document.
+
+   The working group also gratefully acknowledges the contributions of
+   Barbara Fox, Warwick Ford, Russ Housley, and John Pawling, whose
+   review and comments significantly clarified and improved the utility
+   of this specification.  The members of the ca-talk mailing list also
+   provided significant input with respect to interoperability testing.
+
+   The text of Appendix C (Why do POP) was taken from an e-mail message
+   by Al Arsenault and was originally part of the PKIX Roadmap document.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 28]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+Appendix A.  Use of RegInfo for Name-Value Pairs
+
+   The "value" field of the id-regInfo-utf8Pairs string (with "tag"
+   field equal to 12 and appropriate "length" field) will contain a
+   series of UTF-8 name/value pairs.
+
+   This Appendix lists some common examples of such pairs for the
+   purpose of promoting interoperability among independent
+   implementations of this specification.  It is recognized that this
+   list is not exhaustive and will grow with time and implementation
+   experience.
+
+A.1.  Defined Names
+
+   The following table defines a recommended set of named elements.  The
+   value in the column "Name Value" is the exact text string that will
+   appear in the regInfo.
+
+      Name Value
+      ----------
+      version            -- version of this variation of regInfo use
+      corp_company       -- company affiliation of subscriber
+      org_unit           -- organizational unit
+      mail_firstName     -- personal name component
+      mail_middleName    -- personal name component
+      mail_lastName      -- personal name component
+      mail_email         -- subscriber's email address
+      jobTitle           -- job title of subscriber
+      employeeID         -- employee identification number or string
+      mailStop           -- mail stop
+      issuerName         -- name of CA
+      subjectName        -- name of Subject
+      validity           -- validity interval
+
+   For example:
+
+      version?1%corp_company?Example, Inc.%org_unit?Engineering%
+      mail_firstName?John%mail_lastName?Smith%jobTitle?Team Leader%
+      mail_email?john@example.com%
+
+A.2.  IssuerName, SubjectName, and Validity Value Encoding
+
+   When they appear in id-regInfo-utf8Pairs syntax as named elements,
+   the encoding of values for issuerName, subjectName, and validity
+   SHALL use the following syntax.  The characters [] indicate an
+   optional field, ::= and | have their usual BNF meanings, and all
+   other symbols (except spaces, which are insignificant) outside non-
+   terminal names are terminals.  Alphabetics are case-sensitive.
+
+
+
+Schaad                      Standards Track                    [Page 29]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      issuerName  ::= <names>
+      subjectName ::= <names>
+      <names>     ::= <name> | <names>:<name>
+
+      <validity>  ::= validity ? [<notbefore>]-[<notafter>]
+
+      <notbefore> ::= <time>
+      <notafter>  ::= <time>
+
+   Where <time> is UTC time in the form YYYYMMDD[HH[MM[SS]]].  HH, MM,
+   and SS default to 00 and are omitted if at the and of value 00.
+
+   Example validity encoding:
+
+      validity?-19991231%
+
+   is a validity interval with no value for notBefore, and a value of
+   December 31, 1999 for notAfter.
+
+   Each name comprises a single character name form identifier, followed
+   by a name value of one or more UTF-8 characters.  Within a name
+   value, when it is necessary to disambiguate a character that has
+   formatting significance at an outer level, the escape sequence %xx
+   SHALL be used, where xx represents the hex value for the encoding
+   concerned.  The percent symbol is represented by %%.
+
+      <name> ::= X<xname>|O<oname>|E<ename>|D<dname>|U<uname>|I<iname>
+
+   Name forms and value formats are as follows:
+
+   X.500 directory name form (identifier "X"):
+
+      <xname> ::= <rdns>
+      <rdns>  ::= <rdn> | <rdns> , <rdn>
+      <rdn>   ::= <avas>
+      <avas>  ::= <ava> | <avas> + <ava>
+      <ava>   ::= <attyp> = <avalue>
+      <attyp> ::= OID.<oid> | <stdat>
+
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 30]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+   Standard attribute type <stdat> is an alphabetic attribute type
+   identifier from the following set:
+
+      C      (country)
+      L      (locality)
+      ST     (state or province)
+      O      (organization)
+      OU     (organizational unit)
+      CN     (common name)
+      STREET (street address)
+      E      (E-mail address).
+
+   <avalue> is a name component in the form of a UTF-8 character string
+   of 1 to 64 characters, with the restriction that in the IA5 subset of
+   UTF-8 only the characters of ASN.1 PrintableString may be used.
+
+   Other name form (identifier "O"):
+      <oname> ::= <oid> , <utf8string>
+
+   E-mail address (rfc822name) name form (identifier "E"):
+      <ename> ::= <ia5string>
+
+   DNS name form (identifier "D"):
+      <dname> ::= <ia5string>
+
+   URI name form (identifier "U"):
+      <uname> ::= <ia5string>
+
+   IP address (identifier "I"):
+      <iname> ::= <oid>
+
+   For example:
+
+      issuerName?XOU=Our CA,O=Example,C=US% subjectName?XCN=John Smith,
+      O=Example, C=US, E=john@example.com%
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 31]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+Appendix B.  ASN.1 Structures and OIDs
+
+PKIXCRMF-2005 {iso(1) identified-organization(3) dod(6) internet(1)
+security(5) mechanisms(5) pkix(7) id-mod(0) id-mod-crmf2005(36)}
+
+DEFINITIONS IMPLICIT TAGS ::=
+BEGIN
+
+IMPORTS
+  -- Directory Authentication Framework (X.509)
+     Version, AlgorithmIdentifier, Name, Time,
+     SubjectPublicKeyInfo, Extensions, UniqueIdentifier, Attribute
+        FROM PKIX1Explicit88 {iso(1) identified-organization(3) dod(6)
+            internet(1) security(5) mechanisms(5) pkix(7) id-mod(0)
+            id-pkix1-explicit(18)} -- found in [PROFILE]
+
+  -- Certificate Extensions (X.509)
+     GeneralName
+        FROM PKIX1Implicit88 {iso(1) identified-organization(3) dod(6)
+               internet(1) security(5) mechanisms(5) pkix(7) id-mod(0)
+               id-pkix1-implicit(19)}  -- found in [PROFILE]
+
+  -- Cryptographic Message Syntax
+     EnvelopedData
+        FROM CryptographicMessageSyntax2004 { iso(1) member-body(2)
+             us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16)
+             modules(0) cms-2004(24) };  -- found in [CMS]
+
+-- The following definition may be uncommented for use with
+-- ASN.1 compilers that do not understand UTF8String.
+
+-- UTF8String ::= [UNIVERSAL 12] IMPLICIT OCTET STRING
+       -- The contents of this type correspond to RFC 2279.
+
+id-pkix  OBJECT IDENTIFIER  ::= { iso(1) identified-organization(3)
+dod(6) internet(1) security(5) mechanisms(5) 7 }
+
+-- arc for Internet X.509 PKI protocols and their components
+
+id-pkip  OBJECT IDENTIFIER ::= { id-pkix 5 }
+
+id-smime OBJECT IDENTIFIER ::= { iso(1) member-body(2)
+             us(840) rsadsi(113549) pkcs(1) pkcs9(9) 16 }
+
+id-ct   OBJECT IDENTIFIER ::= { id-smime  1 }  -- content types
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 32]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+-- Core definitions for this module
+
+CertReqMessages ::= SEQUENCE SIZE (1..MAX) OF CertReqMsg
+
+CertReqMsg ::= SEQUENCE {
+ certReq   CertRequest,
+ popo       ProofOfPossession  OPTIONAL,
+ -- content depends upon key type
+ regInfo   SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue OPTIONAL }
+
+CertRequest ::= SEQUENCE {
+ certReqId     INTEGER,          -- ID for matching request and reply
+ certTemplate  CertTemplate,  -- Selected fields of cert to be issued
+ controls      Controls OPTIONAL }   -- Attributes affecting issuance
+
+CertTemplate ::= SEQUENCE {
+ version      [0] Version               OPTIONAL,
+ serialNumber [1] INTEGER               OPTIONAL,
+ signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
+ issuer       [3] Name                  OPTIONAL,
+ validity     [4] OptionalValidity      OPTIONAL,
+ subject      [5] Name                  OPTIONAL,
+ publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
+ issuerUID    [7] UniqueIdentifier      OPTIONAL,
+ subjectUID   [8] UniqueIdentifier      OPTIONAL,
+ extensions   [9] Extensions            OPTIONAL }
+
+OptionalValidity ::= SEQUENCE {
+ notBefore  [0] Time OPTIONAL,
+ notAfter   [1] Time OPTIONAL } -- at least one MUST be present
+
+Controls  ::= SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue
+AttributeTypeAndValue ::= SEQUENCE {
+ type         OBJECT IDENTIFIER,
+ value        ANY DEFINED BY type }
+
+ProofOfPossession ::= CHOICE {
+ raVerified        [0] NULL,
+ -- used if the RA has already verified that the requester is in
+ -- possession of the private key
+ signature         [1] POPOSigningKey,
+ keyEncipherment   [2] POPOPrivKey,
+ keyAgreement      [3] POPOPrivKey }
+
+POPOSigningKey ::= SEQUENCE {
+ poposkInput           [0] POPOSigningKeyInput OPTIONAL,
+ algorithmIdentifier   AlgorithmIdentifier,
+ signature             BIT STRING }
+
+
+
+Schaad                      Standards Track                    [Page 33]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+ -- The signature (using "algorithmIdentifier") is on the
+ -- DER-encoded value of poposkInput.  NOTE: If the CertReqMsg
+ -- certReq CertTemplate contains the subject and publicKey values,
+ -- then poposkInput MUST be omitted and the signature MUST be
+ -- computed over the DER-encoded value of CertReqMsg certReq.  If
+ -- the CertReqMsg certReq CertTemplate does not contain both the
+ -- public key and subject values (i.e., if it contains only one
+ -- of these, or neither), then poposkInput MUST be present and
+ -- MUST be signed.
+
+
+POPOSigningKeyInput ::= SEQUENCE {
+ authInfo            CHOICE {
+     sender              [0] GeneralName,
+     -- used only if an authenticated identity has been
+     -- established for the sender (e.g., a DN from a
+     -- previously-issued and currently-valid certificate)
+     publicKeyMAC        PKMACValue },
+     -- used if no authenticated GeneralName currently exists for
+     -- the sender; publicKeyMAC contains a password-based MAC
+     -- on the DER-encoded value of publicKey
+ publicKey           SubjectPublicKeyInfo }  -- from CertTemplate
+
+PKMACValue ::= SEQUENCE {
+algId  AlgorithmIdentifier,
+-- algorithm value shall be PasswordBasedMac {1 2 840 113533 7 66 13}
+-- parameter value is PBMParameter
+value  BIT STRING }
+
+PBMParameter ::= SEQUENCE {
+   salt                OCTET STRING,
+   owf                 AlgorithmIdentifier,
+   -- AlgId for a One-Way Function (SHA-1 recommended)
+   iterationCount      INTEGER,
+   -- number of times the OWF is applied
+   mac                 AlgorithmIdentifier
+   -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
+}   -- or HMAC [HMAC, RFC2202])
+
+POPOPrivKey ::= CHOICE {
+ thisMessage       [0] BIT STRING,         -- Deprecated
+ -- possession is proven in this message (which contains the private
+ -- key itself (encrypted for the CA))
+ subsequentMessage [1] SubsequentMessage,
+ -- possession will be proven in a subsequent message
+ dhMAC             [2] BIT STRING,         -- Deprecated
+ agreeMAC          [3] PKMACValue,
+ encryptedKey      [4] EnvelopedData }
+
+
+
+Schaad                      Standards Track                    [Page 34]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+ -- for keyAgreement (only), possession is proven in this message
+ -- (which contains a MAC (over the DER-encoded value of the
+ -- certReq parameter in CertReqMsg, which MUST include both subject
+ -- and publicKey) based on a key derived from the end entity's
+ -- private DH key and the CA's public DH key);
+
+SubsequentMessage ::= INTEGER {
+ encrCert (0),
+ -- requests that resulting certificate be encrypted for the
+ -- end entity (following which, POP will be proven in a
+ -- confirmation message)
+ challengeResp (1) }
+ -- requests that CA engage in challenge-response exchange with
+ -- end entity in order to prove private key possession
+
+-- Object identifier assignments --
+
+-- Registration Controls in CRMF
+id-regCtrl OBJECT IDENTIFIER ::= { id-pkip 1 }
+
+
+id-regCtrl-regToken OBJECT IDENTIFIER ::= { id-regCtrl 1 }
+--with syntax:
+RegToken ::= UTF8String
+
+id-regCtrl-authenticator OBJECT IDENTIFIER ::= { id-regCtrl 2 }
+--with syntax:
+Authenticator ::= UTF8String
+
+id-regCtrl-pkiPublicationInfo OBJECT IDENTIFIER ::= { id-regCtrl 3 }
+--with syntax:
+
+PKIPublicationInfo ::= SEQUENCE {
+action     INTEGER {
+             dontPublish (0),
+             pleasePublish (1) },
+pubInfos  SEQUENCE SIZE (1..MAX) OF SinglePubInfo OPTIONAL }
+  -- pubInfos MUST NOT be present if action is "dontPublish"
+  -- (if action is "pleasePublish" and pubInfos is omitted,
+  -- "dontCare" is assumed)
+
+SinglePubInfo ::= SEQUENCE {
+ pubMethod    INTEGER {
+     dontCare    (0),
+     x500        (1),
+     web         (2),
+     ldap        (3) },
+ pubLocation  GeneralName OPTIONAL }
+
+
+
+Schaad                      Standards Track                    [Page 35]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+
+id-regCtrl-pkiArchiveOptions     OBJECT IDENTIFIER ::= { id-regCtrl 4 }
+--with syntax:
+PKIArchiveOptions ::= CHOICE {
+ encryptedPrivKey     [0] EncryptedKey,
+ -- the actual value of the private key
+ keyGenParameters     [1] KeyGenParameters,
+ -- parameters that allow the private key to be re-generated
+ archiveRemGenPrivKey [2] BOOLEAN }
+ -- set to TRUE if sender wishes receiver to archive the private
+ -- key of a key pair that the receiver generates in response to
+ -- this request; set to FALSE if no archival is desired.
+
+EncryptedKey ::= CHOICE {
+ encryptedValue        EncryptedValue,   -- Deprecated
+ envelopedData     [0] EnvelopedData }
+ -- The encrypted private key MUST be placed in the envelopedData
+ -- encryptedContentInfo encryptedContent OCTET STRING.
+
+EncryptedValue ::= SEQUENCE {
+ intendedAlg   [0] AlgorithmIdentifier  OPTIONAL,
+ -- the intended algorithm for which the value will be used
+ symmAlg       [1] AlgorithmIdentifier  OPTIONAL,
+ -- the symmetric algorithm used to encrypt the value
+ encSymmKey    [2] BIT STRING           OPTIONAL,
+ -- the (encrypted) symmetric key used to encrypt the value
+ keyAlg        [3] AlgorithmIdentifier  OPTIONAL,
+ -- algorithm used to encrypt the symmetric key
+ valueHint     [4] OCTET STRING         OPTIONAL,
+ -- a brief description or identifier of the encValue content
+ -- (may be meaningful only to the sending entity, and used only
+ -- if EncryptedValue might be re-examined by the sending entity
+ -- in the future)
+ encValue       BIT STRING }
+ -- the encrypted value itself
+-- When EncryptedValue is used to carry a private key (as opposed to
+-- a certificate), implementations MUST support the encValue field
+-- containing an encrypted PrivateKeyInfo as defined in [PKCS11],
+-- section 12.11.  If encValue contains some other format/encoding
+-- for the private key, the first octet of valueHint MAY be used
+-- to indicate the format/encoding (but note that the possible values
+-- of this octet are not specified at this time).  In all cases, the
+-- intendedAlg field MUST be used to indicate at least the OID of
+-- the intended algorithm of the private key, unless this information
+-- is known a priori to both sender and receiver by some other means.
+
+KeyGenParameters ::= OCTET STRING
+
+
+
+
+Schaad                      Standards Track                    [Page 36]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+id-regCtrl-oldCertID          OBJECT IDENTIFIER ::= { id-regCtrl 5 }
+--with syntax:
+OldCertId ::= CertId
+
+CertId ::= SEQUENCE {
+ issuer           GeneralName,
+ serialNumber     INTEGER }
+
+id-regCtrl-protocolEncrKey    OBJECT IDENTIFIER ::= { id-regCtrl 6 }
+--with syntax:
+ProtocolEncrKey ::= SubjectPublicKeyInfo
+
+-- Registration Info in CRMF
+id-regInfo OBJECT IDENTIFIER ::= { id-pkip 2 }
+
+id-regInfo-utf8Pairs    OBJECT IDENTIFIER ::= { id-regInfo 1 }
+--with syntax
+UTF8Pairs ::= UTF8String
+
+
+id-regInfo-certReq       OBJECT IDENTIFIER ::= { id-regInfo 2 }
+--with syntax
+CertReq ::= CertRequest
+
+-- id-ct-encKeyWithID is a new content type used for CMS objects.
+-- it contains both a private key and an identifier for key escrow
+-- agents to check against recovery requestors.
+
+id-ct-encKeyWithID OBJECT IDENTIFIER ::= {id-ct 21}
+
+EncKeyWithID ::= SEQUENCE {
+  privateKey           PrivateKeyInfo,
+  identifier CHOICE {
+    string             UTF8String,
+    generalName        GeneralName
+  } OPTIONAL
+}
+
+PrivateKeyInfo ::= SEQUENCE {
+   version                   INTEGER,
+   privateKeyAlgorithm       AlgorithmIdentifier,
+   privateKey                OCTET STRING,
+   attributes                [0] IMPLICIT Attributes OPTIONAL
+}
+
+Attributes ::= SET OF Attribute
+
+END
+
+
+
+Schaad                      Standards Track                    [Page 37]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+Appendix C.  Why do Proof-of-Possession (POP)
+
+   Proof-of-Possession, or POP, means that the CA is adequately
+   convinced that the entity requesting a certificate for the public key
+   Y, has access to the corresponding private key X.
+
+   POP is important because it provides an appropriate level of
+   assurance of the correct operation of the PKI as a whole.  At its
+   lowest level, POP counters the "self-inflicted denial of service";
+   that is, an entity voluntarily gets a certificate that cannot be used
+   to sign or encrypt/decrypt information.  However, as the following
+   two examples demonstrate, POP also counters less direct, but more
+   severe, threats:
+
+      POP for signing keys: it is important to provide POP for keys used
+      to sign material, in order to provide non-repudiation of
+      transactions.  For example, suppose Alice legitimately has private
+      key X and its corresponding public key Y.  Alice has a certificate
+      from Charlie, a CA, containing Y.  Alice uses X to sign a
+      transaction T.  Without POP, Mal could also get a certificate from
+      Charlie containing the same public key, Y.  Now, there are two
+      possible threats: Mal could claim to have been the real signer of
+      T; or Alice can falsely deny signing T, claiming that it was
+      instead Mal.  Since no one can reliably prove that Mal did or did
+      not ever possess X, neither of these claims can be refuted, and
+      thus the service provided by and the confidence in the PKI has
+      been defeated.  (Of course, if Mal really did possess X, Alice's
+      private key, then no POP mechanism in the world will help, but
+      that is a different problem.)
+
+      Note that one level of protection can be gained by having Alice
+      (as the true signer of the transaction) include in the signed
+      information, her certificate or an identifier of her certificate
+      (e.g., a hash of her certificate).  This might make it more
+      difficult for Mal to claim authorship; he would have to assert
+      that he incorrectly included Alice's certificate, rather than his
+      own.  However, it would not stop Alice from falsely repudiating
+      her actions.  Since the certificate itself is a public item, Mal
+      indeed could have inserted Alice's certificate or identifier into
+      the signed transaction, and thus its presence does not indicate
+      that Alice was the one who participated in the now-repudiated
+      transaction.  The only reliable way to stop this attack is to
+      require that Mal prove he possesses X before his certificate is
+      issued.
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 38]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+      For signing keys used only for authentication, and not for non-
+      repudiation, the threat is lower because users may not care about
+      Alice's after-the-fact repudiation, and thus POP becomes less
+      important.  However, POP SHOULD still be done wherever feasible in
+      this environment, by either off-line or on-line means.
+
+      POP for key management keys:  Similarly, POP for key management
+      keys (that is, keys used for either key agreement or key exchange)
+      can help to prevent undermining confidence in the PKI.  Suppose
+      that Al is a new instructor in the Computer Science Department of
+      a local university.  Al has created a draft final exam for the
+      Introduction to Networking course he is teaching.  He wants to
+      send a copy of the draft final to Dorothy, the Department Head,
+      for her review prior to giving the exam.  This exam will of course
+      be encrypted, as several students have access to the computer
+      system.  However, a quick search of the certificate repository
+      (e.g., search the repository for all records with
+      subjectPublicKey=Dorothy's-value) turns up the fact that several
+      students have certificates containing the same public key
+      management key as Dorothy.  At this point, if no POP has been done
+      by the CA, Al has no way of knowing whether all of the students
+      have simply created these certificates without knowing the
+      corresponding private key (and thus it is safe to send the
+      encrypted exam to Dorothy), or whether the students have somehow
+      acquired Dorothy's private key (and thus it is certainly not safe
+      to send the exam).  Thus, the service to be provided by the PKI
+      allowing users to communicate with one another, with confidence in
+      who they are communicating with, has been totally defeated.  If
+      the CA is providing POP, then either no students will have such
+      certificates, or Al can know with certainty that the students do
+      indeed know Dorothy's private key, and act accordingly.
+
+Author's Address
+
+   Jim Schaad
+   Soaring Hawk Consulting
+   PO Box 675
+   Gold Bar, WA 98251
+
+   EMail: jimsch@exmsft.com
+
+
+
+
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 39]
+
+RFC 4211                  Internet X.509 CRMF             September 2005
+
+
+Full Copyright Statement
+
+   Copyright (C) The Internet Society (2005).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
+   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
+   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
+   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at ietf-
+   ipr@ietf.org.
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+
+Schaad                      Standards Track                    [Page 40]
+
Index: openssl-1.0.0i-cmp/crypto/crmf/crmf_atav.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/crmf/crmf_atav.c	(revision 0)
+++ openssl-1.0.0i-cmp/crypto/crmf/crmf_atav.c	(revision 469)
@@ -0,0 +1,140 @@
+/* crypto/crmf/crmf_itav.c */
+
+/* Adjusted by Martin Peylo <martin.peylo@nsn.com> */
+
+/* this file is derived from x_algor.c,
+ * written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL
+ * project 2000.
+ */
+
+/* ====================================================================
+ * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ */
+
+#include <stddef.h>
+#include <openssl/crmf.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+
+#if 0
+/* ############################################################################ */
+/* ############################################################################ */
+int CRMF_ATTRIBUTETYPEANDVALUE_set0(CRMF_ATTRIBUTETYPEANDVALUE *atav, ASN1_OBJECT *aobj, int ptype, void *pval)
+	{
+	if (!atav)
+		return 0;
+	if (ptype != V_ASN1_UNDEF) {
+		if (atav->value == NULL)
+			atav->value = ASN1_TYPE_new();
+		if (atav->value == NULL)
+			return 0;
+	}
+	if (atav) {
+		if (atav->type)
+			ASN1_OBJECT_free(atav->type);
+		atav->type = aobj;
+	}
+	if (ptype == 0)
+		return 1;	
+	if (ptype == V_ASN1_UNDEF) {
+		if (atav->value) {
+			ASN1_TYPE_free(atav->value);
+			atav->value = NULL;
+		}
+	}
+	else
+		ASN1_TYPE_set(atav->value, ptype, pval);
+	return 1;
+}
+
+
+/* ############################################################################ */
+/* ############################################################################ */
+void CRMF_ATTRIBUTETYPEANDVALUE_get0(ASN1_OBJECT **paobj, int *pptype, void **ppval, CRMF_ATTRIBUTETYPEANDVALUE *atav) {
+	if (paobj)
+		*paobj = atav->type;
+	if (pptype) {
+		if (atav->value == NULL) {
+			*pptype = V_ASN1_UNDEF;
+			return;
+		} else
+			*pptype = atav->value->type;
+		if (ppval)
+			*ppval = atav->value->value.ptr;
+		}
+}
+
+/* ############################################################################ */
+/* ############################################################################ */
+int CRMF_ATTRIBUTETYPEANDVALUE_set0_nid_utf8string( CRMF_ATTRIBUTETYPEANDVALUE *atav, int nid, ASN1_UTF8STRING *utf8str) {
+	unsigned char *utf8strDer=NULL;
+	int utf8strDerLen;
+	ASN1_STRING *utf8strStr=NULL;
+
+	if (!atav) goto err;
+	if (!utf8str) goto err;
+
+	utf8strDerLen = i2d_ASN1_UTF8STRING( utf8str, &utf8strDer);
+	if (!(utf8strStr = ASN1_STRING_new())) goto err;
+	ASN1_STRING_set( utf8strStr, utf8strDer, utf8strDerLen);
+	utf8strDer = NULL;
+
+	if( !CRMF_ATTRIBUTETYPEANDVALUE_set0( atav, OBJ_nid2obj(nid), V_ASN1_UTF8STRING, utf8strStr)) goto err;
+	utf8strStr = NULL;
+
+	return 1;
+err:	
+	if (utf8strStr) ASN1_STRING_free( utf8strStr);
+	if (utf8strDer) OPENSSL_free( utf8strDer);
+	return 0;
+}
+#endif
Index: openssl-1.0.0i-cmp/crypto/err/err_all.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/err/err_all.c	(revision 377)
+++ openssl-1.0.0i-cmp/crypto/err/err_all.c	(working copy)
@@ -104,6 +104,9 @@
 #endif
 #include <openssl/comp.h>
 
+#include <openssl/cmp.h>
+#include <openssl/crmf.h>
+
 void ERR_load_crypto_strings(void)
 	{
 #ifndef OPENSSL_NO_ERR
@@ -157,4 +160,10 @@
 #endif
 	ERR_load_COMP_strings();
 #endif
+
+#ifndef OPENSSL_NO_CMP
+	ERR_load_CMP_strings();
+	ERR_load_CRMF_strings();
+#endif
+
 	}
Index: openssl-1.0.0i-cmp/crypto/err/err.c
===================================================================
--- openssl-1.0.0i-cmp/crypto/err/err.c	(revision 377)
+++ openssl-1.0.0i-cmp/crypto/err/err.c	(working copy)
@@ -156,6 +156,8 @@
 {ERR_PACK(ERR_LIB_FIPS,0,0)		,"FIPS routines"},
 {ERR_PACK(ERR_LIB_CMS,0,0)		,"CMS routines"},
 {ERR_PACK(ERR_LIB_HMAC,0,0)		,"HMAC routines"},
+{ERR_PACK(ERR_LIB_CMP,0,0)		,"CMP routines"},
+{ERR_PACK(ERR_LIB_CRMF,0,0)		,"CRMF routines"},
 {0,NULL},
 	};
 
@@ -203,6 +205,8 @@
 {ERR_R_ENGINE_LIB			,"ENGINE lib"},
 {ERR_R_OCSP_LIB				,"OCSP lib"},
 {ERR_R_TS_LIB				,"TS lib"},
+{ERR_R_CMP_LIB				,"CMP lib"},
+{ERR_R_CRMF_LIB				,"CRMF lib"},
 
 {ERR_R_NESTED_ASN1_ERROR		,"nested asn1 error"},
 {ERR_R_BAD_ASN1_OBJECT_HEADER		,"bad asn1 object header"},
Index: openssl-1.0.0i-cmp/crypto/err/openssl.ec
===================================================================
--- openssl-1.0.0i-cmp/crypto/err/openssl.ec	(revision 377)
+++ openssl-1.0.0i-cmp/crypto/err/openssl.ec	(working copy)
@@ -35,6 +35,8 @@
 L HMAC		crypto/hmac/hmac.h		crypto/hmac/hmac_err.c
 L CMS		crypto/cms/cms.h		crypto/cms/cms_err.c
 L JPAKE		crypto/jpake/jpake.h		crypto/jpake/jpake_err.c
+L CMP		crypto/cmp/cmp.h		crypto/cmp/cmp_err.c
+L CRMF		crypto/crmf/crmf.h		crypto/crmf/crmf_err.c
 
 # additional header files to be scanned for function names
 L NONE		crypto/x509/x509_vfy.h		NONE
Index: openssl-1.0.0i-cmp/crypto/err/err.h
===================================================================
--- openssl-1.0.0i-cmp/crypto/err/err.h	(revision 377)
+++ openssl-1.0.0i-cmp/crypto/err/err.h	(working copy)
@@ -198,6 +198,8 @@
 #define ERR_LIB_TS		47
 #define ERR_LIB_HMAC		48
 #define ERR_LIB_JPAKE		49
+#define ERR_LIB_CMP		50
+#define ERR_LIB_CRMF		51
 
 #define ERR_LIB_USER		128
 
@@ -234,6 +236,8 @@
 #define TSerr(f,r) ERR_PUT_error(ERR_LIB_TS,(f),(r),__FILE__,__LINE__)
 #define HMACerr(f,r) ERR_PUT_error(ERR_LIB_HMAC,(f),(r),__FILE__,__LINE__)
 #define JPAKEerr(f,r) ERR_PUT_error(ERR_LIB_JPAKE,(f),(r),__FILE__,__LINE__)
+#define CMPerr(f,r) ERR_PUT_error(ERR_LIB_CMP,(f),(r),__FILE__,__LINE__)
+#define CRMFerr(f,r) ERR_PUT_error(ERR_LIB_CRMF,(f),(r),__FILE__,__LINE__)
 
 /* Borland C seems too stupid to be able to shift and do longs in
  * the pre-processor :-( */
@@ -290,6 +294,8 @@
 #define ERR_R_ECDH_LIB  ERR_LIB_ECDH	 /* 43 */
 #define ERR_R_STORE_LIB ERR_LIB_STORE    /* 44 */
 #define ERR_R_TS_LIB	ERR_LIB_TS       /* 45 */
+#define ERR_R_CMP_LIB	ERR_LIB_CMP      /* 50 */
+#define ERR_R_CRMF_LIB	ERR_LIB_CRMF     /* 51 */
 
 #define ERR_R_NESTED_ASN1_ERROR			58
 #define ERR_R_BAD_ASN1_OBJECT_HEADER		59
Index: openssl-1.0.0i-cmp/crypto/stack/safestack.h
===================================================================
--- openssl-1.0.0i-cmp/crypto/stack/safestack.h	(revision 469)
+++ openssl-1.0.0i-cmp/crypto/stack/safestack.h	(working copy)
@@ -381,6 +381,28 @@
 #define sk_ASN1_UTF8STRING_sort(st) SKM_sk_sort(ASN1_UTF8STRING, (st))
 #define sk_ASN1_UTF8STRING_is_sorted(st) SKM_sk_is_sorted(ASN1_UTF8STRING, (st))
 
+#define sk_ASN1_UTF8STRING_new(cmp) SKM_sk_new(ASN1_UTF8STRING, (cmp))
+#define sk_ASN1_UTF8STRING_new_null() SKM_sk_new_null(ASN1_UTF8STRING)
+#define sk_ASN1_UTF8STRING_free(st) SKM_sk_free(ASN1_UTF8STRING, (st))
+#define sk_ASN1_UTF8STRING_num(st) SKM_sk_num(ASN1_UTF8STRING, (st))
+#define sk_ASN1_UTF8STRING_value(st, i) SKM_sk_value(ASN1_UTF8STRING, (st), (i))
+#define sk_ASN1_UTF8STRING_set(st, i, val) SKM_sk_set(ASN1_UTF8STRING, (st), (i), (val))
+#define sk_ASN1_UTF8STRING_zero(st) SKM_sk_zero(ASN1_UTF8STRING, (st))
+#define sk_ASN1_UTF8STRING_push(st, val) SKM_sk_push(ASN1_UTF8STRING, (st), (val))
+#define sk_ASN1_UTF8STRING_unshift(st, val) SKM_sk_unshift(ASN1_UTF8STRING, (st), (val))
+#define sk_ASN1_UTF8STRING_find(st, val) SKM_sk_find(ASN1_UTF8STRING, (st), (val))
+#define sk_ASN1_UTF8STRING_find_ex(st, val) SKM_sk_find_ex(ASN1_UTF8STRING, (st), (val))
+#define sk_ASN1_UTF8STRING_delete(st, i) SKM_sk_delete(ASN1_UTF8STRING, (st), (i))
+#define sk_ASN1_UTF8STRING_delete_ptr(st, ptr) SKM_sk_delete_ptr(ASN1_UTF8STRING, (st), (ptr))
+#define sk_ASN1_UTF8STRING_insert(st, val, i) SKM_sk_insert(ASN1_UTF8STRING, (st), (val), (i))
+#define sk_ASN1_UTF8STRING_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(ASN1_UTF8STRING, (st), (cmp))
+#define sk_ASN1_UTF8STRING_dup(st) SKM_sk_dup(ASN1_UTF8STRING, st)
+#define sk_ASN1_UTF8STRING_pop_free(st, free_func) SKM_sk_pop_free(ASN1_UTF8STRING, (st), (free_func))
+#define sk_ASN1_UTF8STRING_shift(st) SKM_sk_shift(ASN1_UTF8STRING, (st))
+#define sk_ASN1_UTF8STRING_pop(st) SKM_sk_pop(ASN1_UTF8STRING, (st))
+#define sk_ASN1_UTF8STRING_sort(st) SKM_sk_sort(ASN1_UTF8STRING, (st))
+#define sk_ASN1_UTF8STRING_is_sorted(st) SKM_sk_is_sorted(ASN1_UTF8STRING, (st))
+
 #define sk_ASN1_VALUE_new(cmp) SKM_sk_new(ASN1_VALUE, (cmp))
 #define sk_ASN1_VALUE_new_null() SKM_sk_new_null(ASN1_VALUE)
 #define sk_ASN1_VALUE_free(st) SKM_sk_free(ASN1_VALUE, (st))
@@ -469,6 +491,226 @@
 #define sk_BY_DIR_HASH_sort(st) SKM_sk_sort(BY_DIR_HASH, (st))
 #define sk_BY_DIR_HASH_is_sorted(st) SKM_sk_is_sorted(BY_DIR_HASH, (st))
 
+#define sk_CMP_CERTRESPONSE_new(cmp) SKM_sk_new(CMP_CERTRESPONSE, (cmp))
+#define sk_CMP_CERTRESPONSE_new_null() SKM_sk_new_null(CMP_CERTRESPONSE)
+#define sk_CMP_CERTRESPONSE_free(st) SKM_sk_free(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_num(st) SKM_sk_num(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_value(st, i) SKM_sk_value(CMP_CERTRESPONSE, (st), (i))
+#define sk_CMP_CERTRESPONSE_set(st, i, val) SKM_sk_set(CMP_CERTRESPONSE, (st), (i), (val))
+#define sk_CMP_CERTRESPONSE_zero(st) SKM_sk_zero(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_push(st, val) SKM_sk_push(CMP_CERTRESPONSE, (st), (val))
+#define sk_CMP_CERTRESPONSE_unshift(st, val) SKM_sk_unshift(CMP_CERTRESPONSE, (st), (val))
+#define sk_CMP_CERTRESPONSE_find(st, val) SKM_sk_find(CMP_CERTRESPONSE, (st), (val))
+#define sk_CMP_CERTRESPONSE_find_ex(st, val) SKM_sk_find_ex(CMP_CERTRESPONSE, (st), (val))
+#define sk_CMP_CERTRESPONSE_delete(st, i) SKM_sk_delete(CMP_CERTRESPONSE, (st), (i))
+#define sk_CMP_CERTRESPONSE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_CERTRESPONSE, (st), (ptr))
+#define sk_CMP_CERTRESPONSE_insert(st, val, i) SKM_sk_insert(CMP_CERTRESPONSE, (st), (val), (i))
+#define sk_CMP_CERTRESPONSE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_CERTRESPONSE, (st), (cmp))
+#define sk_CMP_CERTRESPONSE_dup(st) SKM_sk_dup(CMP_CERTRESPONSE, st)
+#define sk_CMP_CERTRESPONSE_pop_free(st, free_func) SKM_sk_pop_free(CMP_CERTRESPONSE, (st), (free_func))
+#define sk_CMP_CERTRESPONSE_shift(st) SKM_sk_shift(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_pop(st) SKM_sk_pop(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_sort(st) SKM_sk_sort(CMP_CERTRESPONSE, (st))
+#define sk_CMP_CERTRESPONSE_is_sorted(st) SKM_sk_is_sorted(CMP_CERTRESPONSE, (st))
+
+#define sk_CMP_CERTSTATUS_new(cmp) SKM_sk_new(CMP_CERTSTATUS, (cmp))
+#define sk_CMP_CERTSTATUS_new_null() SKM_sk_new_null(CMP_CERTSTATUS)
+#define sk_CMP_CERTSTATUS_free(st) SKM_sk_free(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_num(st) SKM_sk_num(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_value(st, i) SKM_sk_value(CMP_CERTSTATUS, (st), (i))
+#define sk_CMP_CERTSTATUS_set(st, i, val) SKM_sk_set(CMP_CERTSTATUS, (st), (i), (val))
+#define sk_CMP_CERTSTATUS_zero(st) SKM_sk_zero(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_push(st, val) SKM_sk_push(CMP_CERTSTATUS, (st), (val))
+#define sk_CMP_CERTSTATUS_unshift(st, val) SKM_sk_unshift(CMP_CERTSTATUS, (st), (val))
+#define sk_CMP_CERTSTATUS_find(st, val) SKM_sk_find(CMP_CERTSTATUS, (st), (val))
+#define sk_CMP_CERTSTATUS_find_ex(st, val) SKM_sk_find_ex(CMP_CERTSTATUS, (st), (val))
+#define sk_CMP_CERTSTATUS_delete(st, i) SKM_sk_delete(CMP_CERTSTATUS, (st), (i))
+#define sk_CMP_CERTSTATUS_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_CERTSTATUS, (st), (ptr))
+#define sk_CMP_CERTSTATUS_insert(st, val, i) SKM_sk_insert(CMP_CERTSTATUS, (st), (val), (i))
+#define sk_CMP_CERTSTATUS_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_CERTSTATUS, (st), (cmp))
+#define sk_CMP_CERTSTATUS_dup(st) SKM_sk_dup(CMP_CERTSTATUS, st)
+#define sk_CMP_CERTSTATUS_pop_free(st, free_func) SKM_sk_pop_free(CMP_CERTSTATUS, (st), (free_func))
+#define sk_CMP_CERTSTATUS_shift(st) SKM_sk_shift(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_pop(st) SKM_sk_pop(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_sort(st) SKM_sk_sort(CMP_CERTSTATUS, (st))
+#define sk_CMP_CERTSTATUS_is_sorted(st) SKM_sk_is_sorted(CMP_CERTSTATUS, (st))
+
+#define sk_CMP_CHALLENGE_new(cmp) SKM_sk_new(CMP_CHALLENGE, (cmp))
+#define sk_CMP_CHALLENGE_new_null() SKM_sk_new_null(CMP_CHALLENGE)
+#define sk_CMP_CHALLENGE_free(st) SKM_sk_free(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_num(st) SKM_sk_num(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_value(st, i) SKM_sk_value(CMP_CHALLENGE, (st), (i))
+#define sk_CMP_CHALLENGE_set(st, i, val) SKM_sk_set(CMP_CHALLENGE, (st), (i), (val))
+#define sk_CMP_CHALLENGE_zero(st) SKM_sk_zero(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_push(st, val) SKM_sk_push(CMP_CHALLENGE, (st), (val))
+#define sk_CMP_CHALLENGE_unshift(st, val) SKM_sk_unshift(CMP_CHALLENGE, (st), (val))
+#define sk_CMP_CHALLENGE_find(st, val) SKM_sk_find(CMP_CHALLENGE, (st), (val))
+#define sk_CMP_CHALLENGE_find_ex(st, val) SKM_sk_find_ex(CMP_CHALLENGE, (st), (val))
+#define sk_CMP_CHALLENGE_delete(st, i) SKM_sk_delete(CMP_CHALLENGE, (st), (i))
+#define sk_CMP_CHALLENGE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_CHALLENGE, (st), (ptr))
+#define sk_CMP_CHALLENGE_insert(st, val, i) SKM_sk_insert(CMP_CHALLENGE, (st), (val), (i))
+#define sk_CMP_CHALLENGE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_CHALLENGE, (st), (cmp))
+#define sk_CMP_CHALLENGE_dup(st) SKM_sk_dup(CMP_CHALLENGE, st)
+#define sk_CMP_CHALLENGE_pop_free(st, free_func) SKM_sk_pop_free(CMP_CHALLENGE, (st), (free_func))
+#define sk_CMP_CHALLENGE_shift(st) SKM_sk_shift(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_pop(st) SKM_sk_pop(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_sort(st) SKM_sk_sort(CMP_CHALLENGE, (st))
+#define sk_CMP_CHALLENGE_is_sorted(st) SKM_sk_is_sorted(CMP_CHALLENGE, (st))
+
+#define sk_CMP_CMPCERTIFICATE_new(cmp) SKM_sk_new(CMP_CMPCERTIFICATE, (cmp))
+#define sk_CMP_CMPCERTIFICATE_new_null() SKM_sk_new_null(CMP_CMPCERTIFICATE)
+#define sk_CMP_CMPCERTIFICATE_free(st) SKM_sk_free(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_num(st) SKM_sk_num(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_value(st, i) SKM_sk_value(CMP_CMPCERTIFICATE, (st), (i))
+#define sk_CMP_CMPCERTIFICATE_set(st, i, val) SKM_sk_set(CMP_CMPCERTIFICATE, (st), (i), (val))
+#define sk_CMP_CMPCERTIFICATE_zero(st) SKM_sk_zero(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_push(st, val) SKM_sk_push(CMP_CMPCERTIFICATE, (st), (val))
+#define sk_CMP_CMPCERTIFICATE_unshift(st, val) SKM_sk_unshift(CMP_CMPCERTIFICATE, (st), (val))
+#define sk_CMP_CMPCERTIFICATE_find(st, val) SKM_sk_find(CMP_CMPCERTIFICATE, (st), (val))
+#define sk_CMP_CMPCERTIFICATE_find_ex(st, val) SKM_sk_find_ex(CMP_CMPCERTIFICATE, (st), (val))
+#define sk_CMP_CMPCERTIFICATE_delete(st, i) SKM_sk_delete(CMP_CMPCERTIFICATE, (st), (i))
+#define sk_CMP_CMPCERTIFICATE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_CMPCERTIFICATE, (st), (ptr))
+#define sk_CMP_CMPCERTIFICATE_insert(st, val, i) SKM_sk_insert(CMP_CMPCERTIFICATE, (st), (val), (i))
+#define sk_CMP_CMPCERTIFICATE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_CMPCERTIFICATE, (st), (cmp))
+#define sk_CMP_CMPCERTIFICATE_dup(st) SKM_sk_dup(CMP_CMPCERTIFICATE, st)
+#define sk_CMP_CMPCERTIFICATE_pop_free(st, free_func) SKM_sk_pop_free(CMP_CMPCERTIFICATE, (st), (free_func))
+#define sk_CMP_CMPCERTIFICATE_shift(st) SKM_sk_shift(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_pop(st) SKM_sk_pop(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_sort(st) SKM_sk_sort(CMP_CMPCERTIFICATE, (st))
+#define sk_CMP_CMPCERTIFICATE_is_sorted(st) SKM_sk_is_sorted(CMP_CMPCERTIFICATE, (st))
+
+#define sk_CMP_INFOTYPEANDVALUE_new(cmp) SKM_sk_new(CMP_INFOTYPEANDVALUE, (cmp))
+#define sk_CMP_INFOTYPEANDVALUE_new_null() SKM_sk_new_null(CMP_INFOTYPEANDVALUE)
+#define sk_CMP_INFOTYPEANDVALUE_free(st) SKM_sk_free(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_num(st) SKM_sk_num(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_value(st, i) SKM_sk_value(CMP_INFOTYPEANDVALUE, (st), (i))
+#define sk_CMP_INFOTYPEANDVALUE_set(st, i, val) SKM_sk_set(CMP_INFOTYPEANDVALUE, (st), (i), (val))
+#define sk_CMP_INFOTYPEANDVALUE_zero(st) SKM_sk_zero(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_push(st, val) SKM_sk_push(CMP_INFOTYPEANDVALUE, (st), (val))
+#define sk_CMP_INFOTYPEANDVALUE_unshift(st, val) SKM_sk_unshift(CMP_INFOTYPEANDVALUE, (st), (val))
+#define sk_CMP_INFOTYPEANDVALUE_find(st, val) SKM_sk_find(CMP_INFOTYPEANDVALUE, (st), (val))
+#define sk_CMP_INFOTYPEANDVALUE_find_ex(st, val) SKM_sk_find_ex(CMP_INFOTYPEANDVALUE, (st), (val))
+#define sk_CMP_INFOTYPEANDVALUE_delete(st, i) SKM_sk_delete(CMP_INFOTYPEANDVALUE, (st), (i))
+#define sk_CMP_INFOTYPEANDVALUE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_INFOTYPEANDVALUE, (st), (ptr))
+#define sk_CMP_INFOTYPEANDVALUE_insert(st, val, i) SKM_sk_insert(CMP_INFOTYPEANDVALUE, (st), (val), (i))
+#define sk_CMP_INFOTYPEANDVALUE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_INFOTYPEANDVALUE, (st), (cmp))
+#define sk_CMP_INFOTYPEANDVALUE_dup(st) SKM_sk_dup(CMP_INFOTYPEANDVALUE, st)
+#define sk_CMP_INFOTYPEANDVALUE_pop_free(st, free_func) SKM_sk_pop_free(CMP_INFOTYPEANDVALUE, (st), (free_func))
+#define sk_CMP_INFOTYPEANDVALUE_shift(st) SKM_sk_shift(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_pop(st) SKM_sk_pop(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_sort(st) SKM_sk_sort(CMP_INFOTYPEANDVALUE, (st))
+#define sk_CMP_INFOTYPEANDVALUE_is_sorted(st) SKM_sk_is_sorted(CMP_INFOTYPEANDVALUE, (st))
+
+#define sk_CMP_PKIMESSAGE_new(cmp) SKM_sk_new(CMP_PKIMESSAGE, (cmp))
+#define sk_CMP_PKIMESSAGE_new_null() SKM_sk_new_null(CMP_PKIMESSAGE)
+#define sk_CMP_PKIMESSAGE_free(st) SKM_sk_free(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_num(st) SKM_sk_num(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_value(st, i) SKM_sk_value(CMP_PKIMESSAGE, (st), (i))
+#define sk_CMP_PKIMESSAGE_set(st, i, val) SKM_sk_set(CMP_PKIMESSAGE, (st), (i), (val))
+#define sk_CMP_PKIMESSAGE_zero(st) SKM_sk_zero(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_push(st, val) SKM_sk_push(CMP_PKIMESSAGE, (st), (val))
+#define sk_CMP_PKIMESSAGE_unshift(st, val) SKM_sk_unshift(CMP_PKIMESSAGE, (st), (val))
+#define sk_CMP_PKIMESSAGE_find(st, val) SKM_sk_find(CMP_PKIMESSAGE, (st), (val))
+#define sk_CMP_PKIMESSAGE_find_ex(st, val) SKM_sk_find_ex(CMP_PKIMESSAGE, (st), (val))
+#define sk_CMP_PKIMESSAGE_delete(st, i) SKM_sk_delete(CMP_PKIMESSAGE, (st), (i))
+#define sk_CMP_PKIMESSAGE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_PKIMESSAGE, (st), (ptr))
+#define sk_CMP_PKIMESSAGE_insert(st, val, i) SKM_sk_insert(CMP_PKIMESSAGE, (st), (val), (i))
+#define sk_CMP_PKIMESSAGE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_PKIMESSAGE, (st), (cmp))
+#define sk_CMP_PKIMESSAGE_dup(st) SKM_sk_dup(CMP_PKIMESSAGE, st)
+#define sk_CMP_PKIMESSAGE_pop_free(st, free_func) SKM_sk_pop_free(CMP_PKIMESSAGE, (st), (free_func))
+#define sk_CMP_PKIMESSAGE_shift(st) SKM_sk_shift(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_pop(st) SKM_sk_pop(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_sort(st) SKM_sk_sort(CMP_PKIMESSAGE, (st))
+#define sk_CMP_PKIMESSAGE_is_sorted(st) SKM_sk_is_sorted(CMP_PKIMESSAGE, (st))
+
+#define sk_CMP_PKISTATUSINFO_new(cmp) SKM_sk_new(CMP_PKISTATUSINFO, (cmp))
+#define sk_CMP_PKISTATUSINFO_new_null() SKM_sk_new_null(CMP_PKISTATUSINFO)
+#define sk_CMP_PKISTATUSINFO_free(st) SKM_sk_free(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_num(st) SKM_sk_num(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_value(st, i) SKM_sk_value(CMP_PKISTATUSINFO, (st), (i))
+#define sk_CMP_PKISTATUSINFO_set(st, i, val) SKM_sk_set(CMP_PKISTATUSINFO, (st), (i), (val))
+#define sk_CMP_PKISTATUSINFO_zero(st) SKM_sk_zero(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_push(st, val) SKM_sk_push(CMP_PKISTATUSINFO, (st), (val))
+#define sk_CMP_PKISTATUSINFO_unshift(st, val) SKM_sk_unshift(CMP_PKISTATUSINFO, (st), (val))
+#define sk_CMP_PKISTATUSINFO_find(st, val) SKM_sk_find(CMP_PKISTATUSINFO, (st), (val))
+#define sk_CMP_PKISTATUSINFO_find_ex(st, val) SKM_sk_find_ex(CMP_PKISTATUSINFO, (st), (val))
+#define sk_CMP_PKISTATUSINFO_delete(st, i) SKM_sk_delete(CMP_PKISTATUSINFO, (st), (i))
+#define sk_CMP_PKISTATUSINFO_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_PKISTATUSINFO, (st), (ptr))
+#define sk_CMP_PKISTATUSINFO_insert(st, val, i) SKM_sk_insert(CMP_PKISTATUSINFO, (st), (val), (i))
+#define sk_CMP_PKISTATUSINFO_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_PKISTATUSINFO, (st), (cmp))
+#define sk_CMP_PKISTATUSINFO_dup(st) SKM_sk_dup(CMP_PKISTATUSINFO, st)
+#define sk_CMP_PKISTATUSINFO_pop_free(st, free_func) SKM_sk_pop_free(CMP_PKISTATUSINFO, (st), (free_func))
+#define sk_CMP_PKISTATUSINFO_shift(st) SKM_sk_shift(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_pop(st) SKM_sk_pop(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_sort(st) SKM_sk_sort(CMP_PKISTATUSINFO, (st))
+#define sk_CMP_PKISTATUSINFO_is_sorted(st) SKM_sk_is_sorted(CMP_PKISTATUSINFO, (st))
+
+#define sk_CMP_POLLREP_new(cmp) SKM_sk_new(CMP_POLLREP, (cmp))
+#define sk_CMP_POLLREP_new_null() SKM_sk_new_null(CMP_POLLREP)
+#define sk_CMP_POLLREP_free(st) SKM_sk_free(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_num(st) SKM_sk_num(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_value(st, i) SKM_sk_value(CMP_POLLREP, (st), (i))
+#define sk_CMP_POLLREP_set(st, i, val) SKM_sk_set(CMP_POLLREP, (st), (i), (val))
+#define sk_CMP_POLLREP_zero(st) SKM_sk_zero(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_push(st, val) SKM_sk_push(CMP_POLLREP, (st), (val))
+#define sk_CMP_POLLREP_unshift(st, val) SKM_sk_unshift(CMP_POLLREP, (st), (val))
+#define sk_CMP_POLLREP_find(st, val) SKM_sk_find(CMP_POLLREP, (st), (val))
+#define sk_CMP_POLLREP_find_ex(st, val) SKM_sk_find_ex(CMP_POLLREP, (st), (val))
+#define sk_CMP_POLLREP_delete(st, i) SKM_sk_delete(CMP_POLLREP, (st), (i))
+#define sk_CMP_POLLREP_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_POLLREP, (st), (ptr))
+#define sk_CMP_POLLREP_insert(st, val, i) SKM_sk_insert(CMP_POLLREP, (st), (val), (i))
+#define sk_CMP_POLLREP_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_POLLREP, (st), (cmp))
+#define sk_CMP_POLLREP_dup(st) SKM_sk_dup(CMP_POLLREP, st)
+#define sk_CMP_POLLREP_pop_free(st, free_func) SKM_sk_pop_free(CMP_POLLREP, (st), (free_func))
+#define sk_CMP_POLLREP_shift(st) SKM_sk_shift(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_pop(st) SKM_sk_pop(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_sort(st) SKM_sk_sort(CMP_POLLREP, (st))
+#define sk_CMP_POLLREP_is_sorted(st) SKM_sk_is_sorted(CMP_POLLREP, (st))
+
+#define sk_CMP_POLLREQ_new(cmp) SKM_sk_new(CMP_POLLREQ, (cmp))
+#define sk_CMP_POLLREQ_new_null() SKM_sk_new_null(CMP_POLLREQ)
+#define sk_CMP_POLLREQ_free(st) SKM_sk_free(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_num(st) SKM_sk_num(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_value(st, i) SKM_sk_value(CMP_POLLREQ, (st), (i))
+#define sk_CMP_POLLREQ_set(st, i, val) SKM_sk_set(CMP_POLLREQ, (st), (i), (val))
+#define sk_CMP_POLLREQ_zero(st) SKM_sk_zero(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_push(st, val) SKM_sk_push(CMP_POLLREQ, (st), (val))
+#define sk_CMP_POLLREQ_unshift(st, val) SKM_sk_unshift(CMP_POLLREQ, (st), (val))
+#define sk_CMP_POLLREQ_find(st, val) SKM_sk_find(CMP_POLLREQ, (st), (val))
+#define sk_CMP_POLLREQ_find_ex(st, val) SKM_sk_find_ex(CMP_POLLREQ, (st), (val))
+#define sk_CMP_POLLREQ_delete(st, i) SKM_sk_delete(CMP_POLLREQ, (st), (i))
+#define sk_CMP_POLLREQ_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_POLLREQ, (st), (ptr))
+#define sk_CMP_POLLREQ_insert(st, val, i) SKM_sk_insert(CMP_POLLREQ, (st), (val), (i))
+#define sk_CMP_POLLREQ_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_POLLREQ, (st), (cmp))
+#define sk_CMP_POLLREQ_dup(st) SKM_sk_dup(CMP_POLLREQ, st)
+#define sk_CMP_POLLREQ_pop_free(st, free_func) SKM_sk_pop_free(CMP_POLLREQ, (st), (free_func))
+#define sk_CMP_POLLREQ_shift(st) SKM_sk_shift(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_pop(st) SKM_sk_pop(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_sort(st) SKM_sk_sort(CMP_POLLREQ, (st))
+#define sk_CMP_POLLREQ_is_sorted(st) SKM_sk_is_sorted(CMP_POLLREQ, (st))
+
+#define sk_CMP_REVDETAILS_new(cmp) SKM_sk_new(CMP_REVDETAILS, (cmp))
+#define sk_CMP_REVDETAILS_new_null() SKM_sk_new_null(CMP_REVDETAILS)
+#define sk_CMP_REVDETAILS_free(st) SKM_sk_free(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_num(st) SKM_sk_num(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_value(st, i) SKM_sk_value(CMP_REVDETAILS, (st), (i))
+#define sk_CMP_REVDETAILS_set(st, i, val) SKM_sk_set(CMP_REVDETAILS, (st), (i), (val))
+#define sk_CMP_REVDETAILS_zero(st) SKM_sk_zero(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_push(st, val) SKM_sk_push(CMP_REVDETAILS, (st), (val))
+#define sk_CMP_REVDETAILS_unshift(st, val) SKM_sk_unshift(CMP_REVDETAILS, (st), (val))
+#define sk_CMP_REVDETAILS_find(st, val) SKM_sk_find(CMP_REVDETAILS, (st), (val))
+#define sk_CMP_REVDETAILS_find_ex(st, val) SKM_sk_find_ex(CMP_REVDETAILS, (st), (val))
+#define sk_CMP_REVDETAILS_delete(st, i) SKM_sk_delete(CMP_REVDETAILS, (st), (i))
+#define sk_CMP_REVDETAILS_delete_ptr(st, ptr) SKM_sk_delete_ptr(CMP_REVDETAILS, (st), (ptr))
+#define sk_CMP_REVDETAILS_insert(st, val, i) SKM_sk_insert(CMP_REVDETAILS, (st), (val), (i))
+#define sk_CMP_REVDETAILS_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CMP_REVDETAILS, (st), (cmp))
+#define sk_CMP_REVDETAILS_dup(st) SKM_sk_dup(CMP_REVDETAILS, st)
+#define sk_CMP_REVDETAILS_pop_free(st, free_func) SKM_sk_pop_free(CMP_REVDETAILS, (st), (free_func))
+#define sk_CMP_REVDETAILS_shift(st) SKM_sk_shift(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_pop(st) SKM_sk_pop(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_sort(st) SKM_sk_sort(CMP_REVDETAILS, (st))
+#define sk_CMP_REVDETAILS_is_sorted(st) SKM_sk_is_sorted(CMP_REVDETAILS, (st))
+
 #define sk_CMS_CertificateChoices_new(cmp) SKM_sk_new(CMS_CertificateChoices, (cmp))
 #define sk_CMS_CertificateChoices_new_null() SKM_sk_new_null(CMS_CertificateChoices)
 #define sk_CMS_CertificateChoices_free(st) SKM_sk_free(CMS_CertificateChoices, (st))
@@ -623,6 +865,72 @@
 #define sk_CONF_VALUE_sort(st) SKM_sk_sort(CONF_VALUE, (st))
 #define sk_CONF_VALUE_is_sorted(st) SKM_sk_is_sorted(CONF_VALUE, (st))
 
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_new(cmp) SKM_sk_new(CRMF_ATTRIBUTETYPEANDVALUE, (cmp))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_new_null() SKM_sk_new_null(CRMF_ATTRIBUTETYPEANDVALUE)
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_free(st) SKM_sk_free(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_num(st) SKM_sk_num(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_value(st, i) SKM_sk_value(CRMF_ATTRIBUTETYPEANDVALUE, (st), (i))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_set(st, i, val) SKM_sk_set(CRMF_ATTRIBUTETYPEANDVALUE, (st), (i), (val))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_zero(st) SKM_sk_zero(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_push(st, val) SKM_sk_push(CRMF_ATTRIBUTETYPEANDVALUE, (st), (val))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_unshift(st, val) SKM_sk_unshift(CRMF_ATTRIBUTETYPEANDVALUE, (st), (val))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_find(st, val) SKM_sk_find(CRMF_ATTRIBUTETYPEANDVALUE, (st), (val))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_find_ex(st, val) SKM_sk_find_ex(CRMF_ATTRIBUTETYPEANDVALUE, (st), (val))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_delete(st, i) SKM_sk_delete(CRMF_ATTRIBUTETYPEANDVALUE, (st), (i))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_delete_ptr(st, ptr) SKM_sk_delete_ptr(CRMF_ATTRIBUTETYPEANDVALUE, (st), (ptr))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_insert(st, val, i) SKM_sk_insert(CRMF_ATTRIBUTETYPEANDVALUE, (st), (val), (i))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CRMF_ATTRIBUTETYPEANDVALUE, (st), (cmp))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_dup(st) SKM_sk_dup(CRMF_ATTRIBUTETYPEANDVALUE, st)
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_pop_free(st, free_func) SKM_sk_pop_free(CRMF_ATTRIBUTETYPEANDVALUE, (st), (free_func))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_shift(st) SKM_sk_shift(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_pop(st) SKM_sk_pop(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_sort(st) SKM_sk_sort(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+#define sk_CRMF_ATTRIBUTETYPEANDVALUE_is_sorted(st) SKM_sk_is_sorted(CRMF_ATTRIBUTETYPEANDVALUE, (st))
+
+#define sk_CRMF_CERTID_new(cmp) SKM_sk_new(CRMF_CERTID, (cmp))
+#define sk_CRMF_CERTID_new_null() SKM_sk_new_null(CRMF_CERTID)
+#define sk_CRMF_CERTID_free(st) SKM_sk_free(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_num(st) SKM_sk_num(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_value(st, i) SKM_sk_value(CRMF_CERTID, (st), (i))
+#define sk_CRMF_CERTID_set(st, i, val) SKM_sk_set(CRMF_CERTID, (st), (i), (val))
+#define sk_CRMF_CERTID_zero(st) SKM_sk_zero(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_push(st, val) SKM_sk_push(CRMF_CERTID, (st), (val))
+#define sk_CRMF_CERTID_unshift(st, val) SKM_sk_unshift(CRMF_CERTID, (st), (val))
+#define sk_CRMF_CERTID_find(st, val) SKM_sk_find(CRMF_CERTID, (st), (val))
+#define sk_CRMF_CERTID_find_ex(st, val) SKM_sk_find_ex(CRMF_CERTID, (st), (val))
+#define sk_CRMF_CERTID_delete(st, i) SKM_sk_delete(CRMF_CERTID, (st), (i))
+#define sk_CRMF_CERTID_delete_ptr(st, ptr) SKM_sk_delete_ptr(CRMF_CERTID, (st), (ptr))
+#define sk_CRMF_CERTID_insert(st, val, i) SKM_sk_insert(CRMF_CERTID, (st), (val), (i))
+#define sk_CRMF_CERTID_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CRMF_CERTID, (st), (cmp))
+#define sk_CRMF_CERTID_dup(st) SKM_sk_dup(CRMF_CERTID, st)
+#define sk_CRMF_CERTID_pop_free(st, free_func) SKM_sk_pop_free(CRMF_CERTID, (st), (free_func))
+#define sk_CRMF_CERTID_shift(st) SKM_sk_shift(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_pop(st) SKM_sk_pop(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_sort(st) SKM_sk_sort(CRMF_CERTID, (st))
+#define sk_CRMF_CERTID_is_sorted(st) SKM_sk_is_sorted(CRMF_CERTID, (st))
+
+#define sk_CRMF_CERTREQMSG_new(cmp) SKM_sk_new(CRMF_CERTREQMSG, (cmp))
+#define sk_CRMF_CERTREQMSG_new_null() SKM_sk_new_null(CRMF_CERTREQMSG)
+#define sk_CRMF_CERTREQMSG_free(st) SKM_sk_free(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_num(st) SKM_sk_num(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_value(st, i) SKM_sk_value(CRMF_CERTREQMSG, (st), (i))
+#define sk_CRMF_CERTREQMSG_set(st, i, val) SKM_sk_set(CRMF_CERTREQMSG, (st), (i), (val))
+#define sk_CRMF_CERTREQMSG_zero(st) SKM_sk_zero(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_push(st, val) SKM_sk_push(CRMF_CERTREQMSG, (st), (val))
+#define sk_CRMF_CERTREQMSG_unshift(st, val) SKM_sk_unshift(CRMF_CERTREQMSG, (st), (val))
+#define sk_CRMF_CERTREQMSG_find(st, val) SKM_sk_find(CRMF_CERTREQMSG, (st), (val))
+#define sk_CRMF_CERTREQMSG_find_ex(st, val) SKM_sk_find_ex(CRMF_CERTREQMSG, (st), (val))
+#define sk_CRMF_CERTREQMSG_delete(st, i) SKM_sk_delete(CRMF_CERTREQMSG, (st), (i))
+#define sk_CRMF_CERTREQMSG_delete_ptr(st, ptr) SKM_sk_delete_ptr(CRMF_CERTREQMSG, (st), (ptr))
+#define sk_CRMF_CERTREQMSG_insert(st, val, i) SKM_sk_insert(CRMF_CERTREQMSG, (st), (val), (i))
+#define sk_CRMF_CERTREQMSG_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(CRMF_CERTREQMSG, (st), (cmp))
+#define sk_CRMF_CERTREQMSG_dup(st) SKM_sk_dup(CRMF_CERTREQMSG, st)
+#define sk_CRMF_CERTREQMSG_pop_free(st, free_func) SKM_sk_pop_free(CRMF_CERTREQMSG, (st), (free_func))
+#define sk_CRMF_CERTREQMSG_shift(st) SKM_sk_shift(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_pop(st) SKM_sk_pop(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_sort(st) SKM_sk_sort(CRMF_CERTREQMSG, (st))
+#define sk_CRMF_CERTREQMSG_is_sorted(st) SKM_sk_is_sorted(CRMF_CERTREQMSG, (st))
+
 #define sk_CRYPTO_EX_DATA_FUNCS_new(cmp) SKM_sk_new(CRYPTO_EX_DATA_FUNCS, (cmp))
 #define sk_CRYPTO_EX_DATA_FUNCS_new_null() SKM_sk_new_null(CRYPTO_EX_DATA_FUNCS)
 #define sk_CRYPTO_EX_DATA_FUNCS_free(st) SKM_sk_free(CRYPTO_EX_DATA_FUNCS, (st))
@@ -755,6 +1063,50 @@
 #define sk_ESS_CERT_ID_sort(st) SKM_sk_sort(ESS_CERT_ID, (st))
 #define sk_ESS_CERT_ID_is_sorted(st) SKM_sk_is_sorted(ESS_CERT_ID, (st))
 
+#define sk_ESS_CERT_ID_new(cmp) SKM_sk_new(ESS_CERT_ID, (cmp))
+#define sk_ESS_CERT_ID_new_null() SKM_sk_new_null(ESS_CERT_ID)
+#define sk_ESS_CERT_ID_free(st) SKM_sk_free(ESS_CERT_ID, (st))
+#define sk_ESS_CERT_ID_num(st) SKM_sk_num(ESS_CERT_ID, (st))
+#define sk_ESS_CERT_ID_value(st, i) SKM_sk_value(ESS_CERT_ID, (st), (i))
+#define sk_ESS_CERT_ID_set(st, i, val) SKM_sk_set(ESS_CERT_ID, (st), (i), (val))
+#define sk_ESS_CERT_ID_zero(st) SKM_sk_zero(ESS_CERT_ID, (st))
+#define sk_ESS_CERT_ID_push(st, val) SKM_sk_push(ESS_CERT_ID, (st), (val))
+#define sk_ESS_CERT_ID_unshift(st, val) SKM_sk_unshift(ESS_CERT_ID, (st), (val))
+#define sk_ESS_CERT_ID_find(st, val) SKM_sk_find(ESS_CERT_ID, (st), (val))
+#define sk_ESS_CERT_ID_find_ex(st, val) SKM_sk_find_ex(ESS_CERT_ID, (st), (val))
+#define sk_ESS_CERT_ID_delete(st, i) SKM_sk_delete(ESS_CERT_ID, (st), (i))
+#define sk_ESS_CERT_ID_delete_ptr(st, ptr) SKM_sk_delete_ptr(ESS_CERT_ID, (st), (ptr))
+#define sk_ESS_CERT_ID_insert(st, val, i) SKM_sk_insert(ESS_CERT_ID, (st), (val), (i))
+#define sk_ESS_CERT_ID_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(ESS_CERT_ID, (st), (cmp))
+#define sk_ESS_CERT_ID_dup(st) SKM_sk_dup(ESS_CERT_ID, st)
+#define sk_ESS_CERT_ID_pop_free(st, free_func) SKM_sk_pop_free(ESS_CERT_ID, (st), (free_func))
+#define sk_ESS_CERT_ID_shift(st) SKM_sk_shift(ESS_CERT_ID, (st))
+#define sk_ESS_CERT_ID_pop(st) SKM_sk_pop(ESS_CERT_ID, (st))
+#define sk_ESS_CERT_ID_sort(st) SKM_sk_sort(ESS_CERT_ID, (st))
+#define sk_ESS_CERT_ID_is_sorted(st) SKM_sk_is_sorted(ESS_CERT_ID, (st))
+
+#define sk_ESS_SIGNING_CERT_new(cmp) SKM_sk_new(ESS_SIGNING_CERT, (cmp))
+#define sk_ESS_SIGNING_CERT_new_null() SKM_sk_new_null(ESS_SIGNING_CERT)
+#define sk_ESS_SIGNING_CERT_free(st) SKM_sk_free(ESS_SIGNING_CERT, (st))
+#define sk_ESS_SIGNING_CERT_num(st) SKM_sk_num(ESS_SIGNING_CERT, (st))
+#define sk_ESS_SIGNING_CERT_value(st, i) SKM_sk_value(ESS_SIGNING_CERT, (st), (i))
+#define sk_ESS_SIGNING_CERT_set(st, i, val) SKM_sk_set(ESS_SIGNING_CERT, (st), (i), (val))
+#define sk_ESS_SIGNING_CERT_zero(st) SKM_sk_zero(ESS_SIGNING_CERT, (st))
+#define sk_ESS_SIGNING_CERT_push(st, val) SKM_sk_push(ESS_SIGNING_CERT, (st), (val))
+#define sk_ESS_SIGNING_CERT_unshift(st, val) SKM_sk_unshift(ESS_SIGNING_CERT, (st), (val))
+#define sk_ESS_SIGNING_CERT_find(st, val) SKM_sk_find(ESS_SIGNING_CERT, (st), (val))
+#define sk_ESS_SIGNING_CERT_find_ex(st, val) SKM_sk_find_ex(ESS_SIGNING_CERT, (st), (val))
+#define sk_ESS_SIGNING_CERT_delete(st, i) SKM_sk_delete(ESS_SIGNING_CERT, (st), (i))
+#define sk_ESS_SIGNING_CERT_delete_ptr(st, ptr) SKM_sk_delete_ptr(ESS_SIGNING_CERT, (st), (ptr))
+#define sk_ESS_SIGNING_CERT_insert(st, val, i) SKM_sk_insert(ESS_SIGNING_CERT, (st), (val), (i))
+#define sk_ESS_SIGNING_CERT_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(ESS_SIGNING_CERT, (st), (cmp))
+#define sk_ESS_SIGNING_CERT_dup(st) SKM_sk_dup(ESS_SIGNING_CERT, st)
+#define sk_ESS_SIGNING_CERT_pop_free(st, free_func) SKM_sk_pop_free(ESS_SIGNING_CERT, (st), (free_func))
+#define sk_ESS_SIGNING_CERT_shift(st) SKM_sk_shift(ESS_SIGNING_CERT, (st))
+#define sk_ESS_SIGNING_CERT_pop(st) SKM_sk_pop(ESS_SIGNING_CERT, (st))
+#define sk_ESS_SIGNING_CERT_sort(st) SKM_sk_sort(ESS_SIGNING_CERT, (st))
+#define sk_ESS_SIGNING_CERT_is_sorted(st) SKM_sk_is_sorted(ESS_SIGNING_CERT, (st))
+
 #define sk_EVP_MD_new(cmp) SKM_sk_new(EVP_MD, (cmp))
 #define sk_EVP_MD_new_null() SKM_sk_new_null(EVP_MD)
 #define sk_EVP_MD_free(st) SKM_sk_free(EVP_MD, (st))
@@ -1305,6 +1657,28 @@
 #define sk_OCSP_SINGLERESP_sort(st) SKM_sk_sort(OCSP_SINGLERESP, (st))
 #define sk_OCSP_SINGLERESP_is_sorted(st) SKM_sk_is_sorted(OCSP_SINGLERESP, (st))
 
+#define sk_PKCS10_ATTRIBUTE_new(cmp) SKM_sk_new(PKCS10_ATTRIBUTE, (cmp))
+#define sk_PKCS10_ATTRIBUTE_new_null() SKM_sk_new_null(PKCS10_ATTRIBUTE)
+#define sk_PKCS10_ATTRIBUTE_free(st) SKM_sk_free(PKCS10_ATTRIBUTE, (st))
+#define sk_PKCS10_ATTRIBUTE_num(st) SKM_sk_num(PKCS10_ATTRIBUTE, (st))
+#define sk_PKCS10_ATTRIBUTE_value(st, i) SKM_sk_value(PKCS10_ATTRIBUTE, (st), (i))
+#define sk_PKCS10_ATTRIBUTE_set(st, i, val) SKM_sk_set(PKCS10_ATTRIBUTE, (st), (i), (val))
+#define sk_PKCS10_ATTRIBUTE_zero(st) SKM_sk_zero(PKCS10_ATTRIBUTE, (st))
+#define sk_PKCS10_ATTRIBUTE_push(st, val) SKM_sk_push(PKCS10_ATTRIBUTE, (st), (val))
+#define sk_PKCS10_ATTRIBUTE_unshift(st, val) SKM_sk_unshift(PKCS10_ATTRIBUTE, (st), (val))
+#define sk_PKCS10_ATTRIBUTE_find(st, val) SKM_sk_find(PKCS10_ATTRIBUTE, (st), (val))
+#define sk_PKCS10_ATTRIBUTE_find_ex(st, val) SKM_sk_find_ex(PKCS10_ATTRIBUTE, (st), (val))
+#define sk_PKCS10_ATTRIBUTE_delete(st, i) SKM_sk_delete(PKCS10_ATTRIBUTE, (st), (i))
+#define sk_PKCS10_ATTRIBUTE_delete_ptr(st, ptr) SKM_sk_delete_ptr(PKCS10_ATTRIBUTE, (st), (ptr))
+#define sk_PKCS10_ATTRIBUTE_insert(st, val, i) SKM_sk_insert(PKCS10_ATTRIBUTE, (st), (val), (i))
+#define sk_PKCS10_ATTRIBUTE_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(PKCS10_ATTRIBUTE, (st), (cmp))
+#define sk_PKCS10_ATTRIBUTE_dup(st) SKM_sk_dup(PKCS10_ATTRIBUTE, st)
+#define sk_PKCS10_ATTRIBUTE_pop_free(st, free_func) SKM_sk_pop_free(PKCS10_ATTRIBUTE, (st), (free_func))
+#define sk_PKCS10_ATTRIBUTE_shift(st) SKM_sk_shift(PKCS10_ATTRIBUTE, (st))
+#define sk_PKCS10_ATTRIBUTE_pop(st) SKM_sk_pop(PKCS10_ATTRIBUTE, (st))
+#define sk_PKCS10_ATTRIBUTE_sort(st) SKM_sk_sort(PKCS10_ATTRIBUTE, (st))
+#define sk_PKCS10_ATTRIBUTE_is_sorted(st) SKM_sk_is_sorted(PKCS10_ATTRIBUTE, (st))
+
 #define sk_PKCS12_SAFEBAG_new(cmp) SKM_sk_new(PKCS12_SAFEBAG, (cmp))
 #define sk_PKCS12_SAFEBAG_new_null() SKM_sk_new_null(PKCS12_SAFEBAG)
 #define sk_PKCS12_SAFEBAG_free(st) SKM_sk_free(PKCS12_SAFEBAG, (st))
@@ -2056,6 +2430,31 @@
 #define sk_OPENSSL_STRING_is_sorted(st) SKM_sk_is_sorted(OPENSSL_STRING, (st))
 
 
+#define sk_OPENSSL_BLOCK_new(cmp) ((STACK_OF(OPENSSL_BLOCK) *)sk_new(CHECKED_SK_CMP_FUNC(void, cmp)))
+#define sk_OPENSSL_BLOCK_new_null() ((STACK_OF(OPENSSL_BLOCK) *)sk_new_null())
+#define sk_OPENSSL_BLOCK_push(st, val) sk_push(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_PTR_OF(void, val))
+#define sk_OPENSSL_BLOCK_find(st, val) sk_find(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_PTR_OF(void, val))
+#define sk_OPENSSL_BLOCK_value(st, i) ((OPENSSL_BLOCK)sk_value(CHECKED_STACK_OF(OPENSSL_BLOCK, st), i))
+#define sk_OPENSSL_BLOCK_num(st) SKM_sk_num(OPENSSL_BLOCK, st)
+#define sk_OPENSSL_BLOCK_pop_free(st, free_func) sk_pop_free(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_SK_FREE_FUNC2(OPENSSL_BLOCK, free_func))
+#define sk_OPENSSL_BLOCK_insert(st, val, i) sk_insert(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_PTR_OF(void, val), i)
+#define sk_OPENSSL_BLOCK_free(st) SKM_sk_free(OPENSSL_BLOCK, st)
+#define sk_OPENSSL_BLOCK_set(st, i, val) sk_set(CHECKED_STACK_OF(OPENSSL_BLOCK, st), i, CHECKED_PTR_OF(void, val))
+#define sk_OPENSSL_BLOCK_zero(st) SKM_sk_zero(OPENSSL_BLOCK, (st))
+#define sk_OPENSSL_BLOCK_unshift(st, val) sk_unshift(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_PTR_OF(void, val))
+#define sk_OPENSSL_BLOCK_find_ex(st, val) sk_find_ex((_STACK *)CHECKED_CONST_PTR_OF(STACK_OF(OPENSSL_BLOCK), st), CHECKED_CONST_PTR_OF(void, val))
+#define sk_OPENSSL_BLOCK_delete(st, i) SKM_sk_delete(OPENSSL_BLOCK, (st), (i))
+#define sk_OPENSSL_BLOCK_delete_ptr(st, ptr) (OPENSSL_BLOCK *)sk_delete_ptr(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_PTR_OF(void, ptr))
+#define sk_OPENSSL_BLOCK_set_cmp_func(st, cmp)  \
+	((int (*)(const void * const *,const void * const *)) \
+	sk_set_cmp_func(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_SK_CMP_FUNC(void, cmp)))
+#define sk_OPENSSL_BLOCK_dup(st) SKM_sk_dup(OPENSSL_BLOCK, st)
+#define sk_OPENSSL_BLOCK_shift(st) SKM_sk_shift(OPENSSL_BLOCK, (st))
+#define sk_OPENSSL_BLOCK_pop(st) (void *)sk_pop(CHECKED_STACK_OF(OPENSSL_BLOCK, st))
+#define sk_OPENSSL_BLOCK_sort(st) SKM_sk_sort(OPENSSL_BLOCK, (st))
+#define sk_OPENSSL_BLOCK_is_sorted(st) SKM_sk_is_sorted(OPENSSL_BLOCK, (st))
+
+
 #define sk_OPENSSL_PSTRING_new(cmp) ((STACK_OF(OPENSSL_PSTRING) *)sk_new(CHECKED_SK_CMP_FUNC(OPENSSL_STRING, cmp)))
 #define sk_OPENSSL_PSTRING_new_null() ((STACK_OF(OPENSSL_PSTRING) *)sk_new_null())
 #define sk_OPENSSL_PSTRING_push(st, val) sk_push(CHECKED_STACK_OF(OPENSSL_PSTRING, st), CHECKED_PTR_OF(OPENSSL_STRING, val))
@@ -2081,31 +2480,6 @@
 #define sk_OPENSSL_PSTRING_is_sorted(st) SKM_sk_is_sorted(OPENSSL_PSTRING, (st))
 
 
-#define sk_OPENSSL_BLOCK_new(cmp) ((STACK_OF(OPENSSL_BLOCK) *)sk_new(CHECKED_SK_CMP_FUNC(void, cmp)))
-#define sk_OPENSSL_BLOCK_new_null() ((STACK_OF(OPENSSL_BLOCK) *)sk_new_null())
-#define sk_OPENSSL_BLOCK_push(st, val) sk_push(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_PTR_OF(void, val))
-#define sk_OPENSSL_BLOCK_find(st, val) sk_find(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_PTR_OF(void, val))
-#define sk_OPENSSL_BLOCK_value(st, i) ((OPENSSL_BLOCK)sk_value(CHECKED_STACK_OF(OPENSSL_BLOCK, st), i))
-#define sk_OPENSSL_BLOCK_num(st) SKM_sk_num(OPENSSL_BLOCK, st)
-#define sk_OPENSSL_BLOCK_pop_free(st, free_func) sk_pop_free(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_SK_FREE_FUNC2(OPENSSL_BLOCK, free_func))
-#define sk_OPENSSL_BLOCK_insert(st, val, i) sk_insert(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_PTR_OF(void, val), i)
-#define sk_OPENSSL_BLOCK_free(st) SKM_sk_free(OPENSSL_BLOCK, st)
-#define sk_OPENSSL_BLOCK_set(st, i, val) sk_set(CHECKED_STACK_OF(OPENSSL_BLOCK, st), i, CHECKED_PTR_OF(void, val))
-#define sk_OPENSSL_BLOCK_zero(st) SKM_sk_zero(OPENSSL_BLOCK, (st))
-#define sk_OPENSSL_BLOCK_unshift(st, val) sk_unshift(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_PTR_OF(void, val))
-#define sk_OPENSSL_BLOCK_find_ex(st, val) sk_find_ex((_STACK *)CHECKED_CONST_PTR_OF(STACK_OF(OPENSSL_BLOCK), st), CHECKED_CONST_PTR_OF(void, val))
-#define sk_OPENSSL_BLOCK_delete(st, i) SKM_sk_delete(OPENSSL_BLOCK, (st), (i))
-#define sk_OPENSSL_BLOCK_delete_ptr(st, ptr) (OPENSSL_BLOCK *)sk_delete_ptr(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_PTR_OF(void, ptr))
-#define sk_OPENSSL_BLOCK_set_cmp_func(st, cmp)  \
-	((int (*)(const void * const *,const void * const *)) \
-	sk_set_cmp_func(CHECKED_STACK_OF(OPENSSL_BLOCK, st), CHECKED_SK_CMP_FUNC(void, cmp)))
-#define sk_OPENSSL_BLOCK_dup(st) SKM_sk_dup(OPENSSL_BLOCK, st)
-#define sk_OPENSSL_BLOCK_shift(st) SKM_sk_shift(OPENSSL_BLOCK, (st))
-#define sk_OPENSSL_BLOCK_pop(st) (void *)sk_pop(CHECKED_STACK_OF(OPENSSL_BLOCK, st))
-#define sk_OPENSSL_BLOCK_sort(st) SKM_sk_sort(OPENSSL_BLOCK, (st))
-#define sk_OPENSSL_BLOCK_is_sorted(st) SKM_sk_is_sorted(OPENSSL_BLOCK, (st))
-
-
 #define d2i_ASN1_SET_OF_ACCESS_DESCRIPTION(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
 	SKM_ASN1_SET_OF_d2i(ACCESS_DESCRIPTION, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
 #define i2d_ASN1_SET_OF_ACCESS_DESCRIPTION(st, pp, i2d_func, ex_tag, ex_class, is_set) \
@@ -2151,6 +2525,24 @@
 #define ASN1_seq_unpack_ASN1_UTF8STRING(buf, len, d2i_func, free_func) \
 	SKM_ASN1_seq_unpack(ASN1_UTF8STRING, (buf), (len), (d2i_func), (free_func))
 
+#define d2i_ASN1_SET_OF_CMP_CERTSTATUS(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
+	SKM_ASN1_SET_OF_d2i(CMP_CERTSTATUS, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+#define i2d_ASN1_SET_OF_CMP_CERTSTATUS(st, pp, i2d_func, ex_tag, ex_class, is_set) \
+	SKM_ASN1_SET_OF_i2d(CMP_CERTSTATUS, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
+#define ASN1_seq_pack_CMP_CERTSTATUS(st, i2d_func, buf, len) \
+	SKM_ASN1_seq_pack(CMP_CERTSTATUS, (st), (i2d_func), (buf), (len))
+#define ASN1_seq_unpack_CMP_CERTSTATUS(buf, len, d2i_func, free_func) \
+	SKM_ASN1_seq_unpack(CMP_CERTSTATUS, (buf), (len), (d2i_func), (free_func))
+
+#define d2i_ASN1_SET_OF_CRMF_CERTREQMSG(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
+	SKM_ASN1_SET_OF_d2i(CRMF_CERTREQMSG, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+#define i2d_ASN1_SET_OF_CRMF_CERTREQMSG(st, pp, i2d_func, ex_tag, ex_class, is_set) \
+	SKM_ASN1_SET_OF_i2d(CRMF_CERTREQMSG, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
+#define ASN1_seq_pack_CRMF_CERTREQMSG(st, i2d_func, buf, len) \
+	SKM_ASN1_seq_pack(CRMF_CERTREQMSG, (st), (i2d_func), (buf), (len))
+#define ASN1_seq_unpack_CRMF_CERTREQMSG(buf, len, d2i_func, free_func) \
+	SKM_ASN1_seq_unpack(CRMF_CERTREQMSG, (buf), (len), (d2i_func), (free_func))
+
 #define d2i_ASN1_SET_OF_DIST_POINT(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
 	SKM_ASN1_SET_OF_d2i(DIST_POINT, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
 #define i2d_ASN1_SET_OF_DIST_POINT(st, pp, i2d_func, ex_tag, ex_class, is_set) \
@@ -2169,6 +2561,15 @@
 #define ASN1_seq_unpack_ESS_CERT_ID(buf, len, d2i_func, free_func) \
 	SKM_ASN1_seq_unpack(ESS_CERT_ID, (buf), (len), (d2i_func), (free_func))
 
+#define d2i_ASN1_SET_OF_ESS_CERT_ID(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
+	SKM_ASN1_SET_OF_d2i(ESS_CERT_ID, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
+#define i2d_ASN1_SET_OF_ESS_CERT_ID(st, pp, i2d_func, ex_tag, ex_class, is_set) \
+	SKM_ASN1_SET_OF_i2d(ESS_CERT_ID, (st), (pp), (i2d_func), (ex_tag), (ex_class), (is_set))
+#define ASN1_seq_pack_ESS_CERT_ID(st, i2d_func, buf, len) \
+	SKM_ASN1_seq_pack(ESS_CERT_ID, (st), (i2d_func), (buf), (len))
+#define ASN1_seq_unpack_ESS_CERT_ID(buf, len, d2i_func, free_func) \
+	SKM_ASN1_seq_unpack(ESS_CERT_ID, (buf), (len), (d2i_func), (free_func))
+
 #define d2i_ASN1_SET_OF_EVP_MD(st, pp, length, d2i_func, free_func, ex_tag, ex_class) \
 	SKM_ASN1_SET_OF_d2i(EVP_MD, (st), (pp), (length), (d2i_func), (free_func), (ex_tag), (ex_class)) 
 #define i2d_ASN1_SET_OF_EVP_MD(st, pp, i2d_func, ex_tag, ex_class, is_set) \
Index: openssl-1.0.0i-cmp/Configure
===================================================================
--- openssl-1.0.0i-cmp/Configure	(revision 377)
+++ openssl-1.0.0i-cmp/Configure	(working copy)
@@ -56,6 +56,7 @@
 # [no-]zlib     [don't] compile support for zlib compression.
 # zlib-dynamic	Like "zlib", but the zlib library is expected to be a shared
 #		library and will be loaded in run-time by the OpenSSL library.
+# [no-]curl     [don't] use libcurl for HTTP transport in CMP module
 # 386           generate 80386 code
 # no-sse2	disables IA-32 SSE2 code, above option implies no-sse2
 # no-<cipher>   build without specified algorithm (rsa, idea, rc5, ...)
@@ -634,6 +635,7 @@
 my $zlib=1;      # but "no-zlib" is default
 my $no_krb5=0;   # but "no-krb5" is implied unless "--with-krb5-..." is used
 my $no_rfc3779=1; # but "no-rfc3779" is default
+my $curl=1;
 my $no_asm=0;
 my $no_dso=0;
 my $no_gmp=0;
@@ -742,6 +744,7 @@
 		s /^threads$/enable-threads/;
 		s /^zlib$/enable-zlib/;
 		s /^zlib-dynamic$/enable-zlib-dynamic/;
+		s /^curl$/enable-curl/;
 
 		if (/^no-(.+)$/ || /^disable-(.+)$/)
 			{
@@ -852,6 +855,14 @@
 				{
 				$withargs{"zlib-include"}="-I$1";
 				}
+			elsif (/^--with-curl-lib=(.*)$/)
+				{
+				$withargs{"curl-lib"}=$1;
+				}
+			elsif (/^--with-curl-include=(.*)$/)
+				{
+				$withargs{"curl-include"}="-I$1";
+				}
 			elsif (/^--cross-compile-prefix=(.*)$/)
 				{
 				$cross_compile_prefix=$1;
@@ -984,6 +995,8 @@
 		{ $no_shared = 1; }
 	elsif (/^zlib$/)
 		{ $zlib = 0; }
+	elsif (/^curl$/)
+		{ $curl = 0; }
 	elsif (/^static-engine$/)
 		{ }
 	elsif (/^zlib-dynamic$/)
@@ -1281,6 +1294,35 @@
 		}
 	}
 
+if ($curl)
+	{
+	$cflags = "-DHAVE_CURL $cflags";
+	
+	if (defined($withargs{"curl-lib"}))
+		{
+		$lflags  = "$lflags -L" . $withargs{"curl-lib"} . " -lcurl -lrt";
+		}
+	else
+		{
+		my $lcurl = `pkg-config --libs libcurl`;
+		$lcurl =~ s/\n//;
+		if ($? != 0) { $lcurl = "-lcurl"; }
+		$lflags = "$lflags $lcurl";
+		}
+
+	if (defined($withargs{"curl-include"}))
+		{
+		$cflags=$withargs{"curl-include"}." $cflags";
+		}
+	else
+		{
+		my $curlflags = `pkg-config --cflags libcurl`;
+		$curlflags =~ s/\n//;
+		if ($? != 0) { $curlflags = ""; }
+		$cflags = "$cflags $curlflags";
+		}
+	}
+
 # You will find shlib_mark1 and shlib_mark2 explained in Makefile.org
 my $shared_mark = "";
 if ($shared_target eq "")
@@ -1547,6 +1589,8 @@
 	s/^LIBKRB5=.*/LIBKRB5=$withargs{"krb5-lib"}/;
 	s/^LIBZLIB=.*/LIBZLIB=$withargs{"zlib-lib"}/;
 	s/^ZLIB_INCLUDE=.*/ZLIB_INCLUDE=$withargs{"zlib-include"}/;
+	s/^LIBCURL=.*/LIBCURL=$withargs{"curl-lib"}/;
+	s/^CURL_INCLUDE=.*/CURL_INCLUDE=$withargs{"curl-include"}/;
 	s/^SHLIB_TARGET=.*/SHLIB_TARGET=$shared_target/;
 	s/^SHLIB_MARK=.*/SHLIB_MARK=$shared_mark/;
 	s/^SHARED_LIBS=.*/SHARED_LIBS=\$(SHARED_CRYPTO) \$(SHARED_SSL)/ if (!$no_shared);
